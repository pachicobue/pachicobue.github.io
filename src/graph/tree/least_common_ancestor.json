{
    "code": "#pragma once\n#include \"../../data_structure/sparse_table/static_rmq.hpp\"\n#include \"../../common.hpp\"\n#include \"../graph.hpp\"\ntemplate<typename C>\nclass LowestCommonAncestor\n{\n    using P = Pair<int, int>;\n\npublic:\n    LowestCommonAncestor(const Graph<C>& g, int r = 0)\n        : m_v(g.v()),\n          m_ins(g.v(), 0),\n          m_ds([&]() {\n              Vec<P> ans;\n              Vec<bool> used(g.v(), false);\n              Fix([&](auto dfs, const P& s) -> void {\n                  const int u = s.second;\n                  used[u] = true;\n                  m_ins[u] = ans.size();\n                  ans.push_back(s);\n                  for (int v : g[u]) {\n                      if (used[v]) { continue; }\n                      dfs(P{s.first + 1, v});\n                      ans.push_back(s);\n                  }\n              })(P{0, r});\n              return ans;\n          }()),\n          m_rmq(m_ds)\n    {}\n    int operator()(int u, int v) const\n    {\n        const auto [ul, vl] = std::minmax({m_ins[u], m_ins[v]});\n        return m_rmq.fold(ul, vl + 1).second;\n    }\n\nprivate:\n    struct Ord\n    {\n        using T = P;\n        bool operator()(const T& p1, const T& p2) const { return p1 < p2; }\n    };\n    int m_v;\n    Vec<int> m_ins;\n    Vec<P> m_ds;\n    StaticRMQ<Ord> m_rmq;\n};\n",
    "result": "NOT_TESTED",
    "verified_with": [
        "verifications/graph/tree/least_common_ancestor.test.cpp"
    ]
}