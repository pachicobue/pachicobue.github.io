{
    "code": "#pragma once\n#include \"../../common.hpp\"\n#include \"../graph.hpp\"\ntemplate<typename T>\nclass HeavyLightDecomposition\n{\n    using P = Pair<int, int>;\n\npublic:\n    HeavyLightDecomposition(Graph<T>& g, int r = 0)\n        : m_v(g.v()),\n          m_ps(m_v, -1),\n          m_tops(m_v, -1),\n          m_ords(m_v, -1),\n          m_ins(m_v, -1),\n          m_outs(m_v, -1)\n    {\n        const int N = g.v();\n        Vec<int> szs(N, 1);\n        Fix([&](auto dfs, int u, int p) -> int {\n            m_ps[u] = p;\n            for (int i : rep(g[u].size())) {\n                const int v = g[u][i];\n                if (p == v) { continue; }\n                szs[u] += dfs(v, u);\n                if (szs[(int)g[u][0]] < szs[v]) { std::swap(g[u][0], g[u][i]); }\n            }\n            return szs[u];\n        })(r, -1);\n        m_tops[r] = r;\n        int index = 0;\n        Fix([&](auto dfs, int u, int p) -> void {\n            m_ins[u] = index++;\n            m_outs[u] = m_ins[u] + szs[u];\n            m_ords[m_ins[u]] = u;\n            for (int i : rep(g[u].size())) {\n                const int v = g[u][i];\n                if (v == p) { continue; }\n                if (i == 0) {\n                    m_tops[v] = m_tops[u];\n                } else {\n                    m_tops[v] = v;\n                }\n                dfs(v, u);\n            }\n        })(r, -1);\n    }\n    int pos(int v) const\n    {\n        assert(0 <= v and v < m_v);\n        return m_ins[v];\n    }\n    int at(int n) const\n    {\n        assert(0 <= n and n < m_v);\n        return m_ords[n];\n    }\n    P sub(int v) const\n    {\n        assert(0 <= v and v < m_v);\n        return {m_ins[v], m_outs[v]};\n    }\n    Vec<P> path(int u, int v) const\n    {\n        assert(0 <= u and u < m_v);\n        assert(0 <= v and v < m_v);\n        Vec<P> head, tail;\n        for (int pu = m_tops[u], pv = m_tops[v]; pu != pv;) {\n            if (m_ins[pu] < m_ins[pv]) {\n                tail.push_back({m_ins[pv], m_ins[v]});\n                v = m_ps[pv];\n                pv = m_tops[v];\n            } else {\n                head.push_back({m_ins[u], m_ins[pu]});\n                u = m_ps[pu];\n                pu = m_tops[u];\n            }\n        }\n        head.push_back({m_ins[u], m_ins[v]});\n        reverseAll(tail);\n        for (const auto& p : tail) { head.push_back(p); }\n        return head;\n    }\n\nprivate:\n    int m_v;\n    Vec<int> m_ps;\n    Vec<int> m_tops;\n    Vec<int> m_ords;\n    Vec<int> m_ins, m_outs;\n};\n",
    "result": "NOT_TESTED",
    "verified_with": [
        "verifications/graph/tree/heavy_light_decomposition.test.cpp"
    ]
}