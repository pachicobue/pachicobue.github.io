{
    "code": "#pragma once\n#include \"../common.hpp\"\n#include \"../algorithm/ext_gcd.hpp\"\ntemplate<u32 mod_, u32 root_, u32 max2p_>\nclass modint\n{\n    template<typename U = u32&>\n    static U modRef()\n    {\n        static u32 s_mod = 0;\n        return s_mod;\n    }\n    template<typename U = u32&>\n    static U rootRef()\n    {\n        static u32 s_root = 0;\n        return s_root;\n    }\n    template<typename U = u32&>\n    static U max2pRef()\n    {\n        static u32 s_max2p = 0;\n        return s_max2p;\n    }\n\npublic:\n    static_assert(mod_ <= LIMMAX<i32>, \"mod(signed int size) only supported!\");\n    static constexpr bool isDynamic() { return (mod_ == 0); }\n    template<typename U = const u32>\n    static constexpr std::enable_if_t<mod_ != 0, U> mod()\n    {\n        return mod_;\n    }\n    template<typename U = const u32>\n    static std::enable_if_t<mod_ == 0, U> mod()\n    {\n        return modRef();\n    }\n    template<typename U = const u32>\n    static constexpr std::enable_if_t<mod_ != 0, U> root()\n    {\n        return root_;\n    }\n    template<typename U = const u32>\n    static std::enable_if_t<mod_ == 0, U> root()\n    {\n        return rootRef();\n    }\n    template<typename U = const u32>\n    static constexpr std::enable_if_t<mod_ != 0, U> max2p()\n    {\n        return max2p_;\n    }\n    template<typename U = const u32>\n    static std::enable_if_t<mod_ == 0, U> max2p()\n    {\n        return max2pRef();\n    }\n    template<typename U = u32>\n    static void setMod(std::enable_if_t<mod_ == 0, U> m)\n    {\n        assert(1 <= m and m <= LIMMAX<i32>);\n        modRef() = m;\n        sinvRef() = {1, 1};\n        factRef() = {1, 1};\n        ifactRef() = {1, 1};\n    }\n    template<typename U = u32>\n    static void setRoot(std::enable_if_t<mod_ == 0, U> r)\n    {\n        rootRef() = r;\n    }\n    template<typename U = u32>\n    static void setMax2p(std::enable_if_t<mod_ == 0, U> m)\n    {\n        max2pRef() = m;\n    }\n    constexpr modint() : m_val{0} {}\n    constexpr modint(i64 v) : m_val{normll(v)} {}\n    constexpr void setRaw(u32 v) { m_val = v; }\n    constexpr modint operator-() const { return modint{0} - (*this); }\n    constexpr modint& operator+=(const modint& m)\n    {\n        m_val = norm(m_val + m.val());\n        return *this;\n    }\n    constexpr modint& operator-=(const modint& m)\n    {\n        m_val = norm(m_val + mod() - m.val());\n        return *this;\n    }\n    constexpr modint& operator*=(const modint& m)\n    {\n        m_val = normll((i64)m_val * (i64)m.val() % (i64)mod());\n        return *this;\n    }\n    constexpr modint& operator/=(const modint& m) { return *this *= m.inv(); }\n    constexpr modint operator+(const modint& m) const\n    {\n        auto v = *this;\n        return v += m;\n    }\n    constexpr modint operator-(const modint& m) const\n    {\n        auto v = *this;\n        return v -= m;\n    }\n    constexpr modint operator*(const modint& m) const\n    {\n        auto v = *this;\n        return v *= m;\n    }\n    constexpr modint operator/(const modint& m) const\n    {\n        auto v = *this;\n        return v /= m;\n    }\n    constexpr bool operator==(const modint& m) const { return m_val == m.val(); }\n    constexpr bool operator!=(const modint& m) const { return not(*this == m); }\n    friend Istream& operator>>(Istream& is, modint& m)\n    {\n        i64 v;\n        return is >> v, m = v, is;\n    }\n    friend Ostream& operator<<(Ostream& os, const modint& m) { return os << m.val(); }\n    constexpr u32 val() const { return m_val; }\n    template<typename I>\n    constexpr modint pow(I n) const\n    {\n        return powerInt(*this, n);\n    }\n    constexpr modint inv() const { return inverse<i32>(m_val, mod()); }\n    static modint sinv(u32 n)\n    {\n        auto& is = sinvRef();\n        for (u32 i = (u32)is.size(); i <= n; i++) { is.push_back(-is[mod() % i] * (mod() / i)); }\n        return is[n];\n    }\n    static modint fact(u32 n)\n    {\n        auto& fs = factRef();\n        for (u32 i = (u32)fs.size(); i <= n; i++) { fs.push_back(fs.back() * i); }\n        return fs[n];\n    }\n    static modint ifact(u32 n)\n    {\n        auto& ifs = ifactRef();\n        for (u32 i = (u32)ifs.size(); i <= n; i++) { ifs.push_back(ifs.back() * sinv(i)); }\n        return ifs[n];\n    }\n    static modint perm(int n, int k) { return k > n or k < 0 ? modint{0} : fact(n) * ifact(n - k); }\n    static modint comb(int n, int k)\n    {\n        return k > n or k < 0 ? modint{0} : fact(n) * ifact(n - k) * ifact(k);\n    }\n\nprivate:\n    static Vec<modint>& sinvRef()\n    {\n        static Vec<modint> is{1, 1};\n        return is;\n    }\n    static Vec<modint>& factRef()\n    {\n        static Vec<modint> fs{1, 1};\n        return fs;\n    }\n    static Vec<modint>& ifactRef()\n    {\n        static Vec<modint> ifs{1, 1};\n        return ifs;\n    }\n    static constexpr u32 norm(u32 x) { return x < mod() ? x : x - mod(); }\n    static constexpr u32 normll(i64 x) { return norm(u32(x % (i64)mod() + (i64)mod())); }\n    u32 m_val;\n};\nusing modint_1000000007 = modint<1000000007, 5, 1>;\nusing modint_998244353 = modint<998244353, 3, 23>;\ntemplate<int id>\nusing modint_dynamic = modint<0, 0, id>;\n",
    "result": "NOT_TESTED",
    "verified_with": [
        "verifications/data_structure/sliding_window_aggregation/queue.test.cpp",
        "verifications/data_structure/sliding_window_aggregation/deque.test.cpp",
        "verifications/data_structure/segment_tree/segtree.test.cpp",
        "verifications/data_structure/segment_tree/dual_segtree.test.cpp",
        "verifications/data_structure/segment_tree/lazy_segtree.test.cpp",
        "verifications/graph/tree/heavy_light_decomposition.test.cpp",
        "verifications/set_power_series/xor_convolution.test.cpp",
        "verifications/set_power_series/and_convolution.test.cpp",
        "verifications/set_power_series/subset_convolution.test.cpp",
        "verifications/set_power_series/or_convolution.test.cpp",
        "verifications/numerical/convolution.ut.test.cpp",
        "verifications/number/mod_nthroot.yuki.test.cpp",
        "verifications/number/mod_sqrt.test.cpp",
        "verifications/number/discrete_log.test.cpp",
        "verifications/number/prime_factors.test.cpp",
        "verifications/number/multiplicative_prefix_sum.totient.test.cpp",
        "verifications/number/mod_nthroot.test.cpp",
        "verifications/linear_algebra/dynamic_matrix.test.cpp",
        "verifications/linear_algebra/static_matrix.test.cpp",
        "verifications/formal_power_series/berlekamp_massey.test.cpp",
        "verifications/formal_power_series/formal_power_series.exp.test.cpp",
        "verifications/formal_power_series/formal_power_series.log.test.cpp",
        "verifications/formal_power_series/formal_power_series.pow.test.cpp",
        "verifications/formal_power_series/formal_power_series.inv.test.cpp",
        "verifications/formal_power_series/formal_power_series.convolution.test.cpp",
        "verifications/formal_power_series/formal_power_series.convolution1000000007.test.cpp",
        "verifications/formal_power_series/bostan_mori.test.cpp",
        "verifications/formal_dirichlet_series/gcd_convolution.test.cpp",
        "verifications/formal_dirichlet_series/lcm_convolution.test.cpp"
    ]
}