{
    "code": "#pragma once\n#include \"../common.hpp\"\ntemplate<typename T>\nclass Rational\n{\npublic:\n    constexpr Rational() : m_num{0}, m_den{1} {}\n    constexpr Rational(const T& v) : m_num{v}, m_den{1} {}\n    constexpr Rational(const T& num, const T& den) { std::tie(m_num, m_den) = norm(num, den); }\n    constexpr Rational operator-() const\n    {\n        auto ans = *this;\n        ans.m_num = -ans.m_num;\n        return ans;\n    }\n    constexpr Rational& operator+=(const Rational& x2)\n    {\n        const auto& [n, d] = norm(m_num * x2.m_den + x2.m_num * m_den, m_den * x2.m_den);\n        return setRaw(n, d), *this;\n    }\n    constexpr Rational& operator-=(const Rational& x2)\n    {\n        const auto& [n, d] = norm(m_num * x2.m_den - x2.m_num * m_den, m_den * x2.m_den);\n        return setRaw(n, d), *this;\n    }\n    constexpr Rational& operator*=(const Rational& x2)\n    {\n        const T g12 = std::gcd(m_num, x2.m_den), g21 = std::gcd(x2.m_num, m_den);\n        return setRaw((m_num / g12) * (x2.m_num / g21), (m_den / g21) * (x2.m_den / g12)), *this;\n    }\n    constexpr Rational& operator/=(const Rational& x2)\n    {\n        const T g12 = std::gcd(m_num, x2.m_num), g21 = std::gcd(x2.m_den, m_den);\n        return setRaw((m_num / g12) * (x2.m_den / g21), (m_den / g21) * (x2.m_num / g12)), *this;\n    }\n    constexpr Rational operator+(const Rational& x2) const\n    {\n        auto v = *this;\n        return v += x2;\n    }\n    constexpr Rational operator-(const Rational& x2) const\n    {\n        auto v = *this;\n        return v -= x2;\n    }\n    constexpr Rational operator*(const Rational& x2) const\n    {\n        auto v = *this;\n        return v *= x2;\n    }\n    constexpr Rational operator/(const Rational& x2) const\n    {\n        auto v = *this;\n        return v /= x2;\n    }\n    constexpr bool operator==(const Rational& x2) const\n    {\n        return m_num == x2.m_num and m_den == x2.m_den;\n    }\n    constexpr bool operator<(const Rational& x2) const\n    {\n        if (x2.m_den == 0) { return x2.m_num > 0; }\n        if (m_den == 0) { return m_num < 0; }\n        return m_num * x2.m_den < x2.m_num * m_den;\n    }\n    constexpr bool operator>(const Rational& x2) const\n    {\n        if (x2.m_den == 0) { return x2.m_num < 0; }\n        if (m_den == 0) { return m_num > 0; }\n        return m_num * x2.m_den > x2.m_num * m_den;\n    }\n    constexpr bool operator<=(const Rational& x2) const { return not(*this > x2); }\n    constexpr bool operator>=(const Rational& x2) const { return not(*this < x2); }\n    friend Ostream& operator<<(Ostream& os, const Rational& x)\n    {\n        const auto& [den, num] = x;\n        return os << den << \"/\" << num;\n    }\n    constexpr void setRaw(T num, T den) { m_num = num, m_den = den; }\n    constexpr Pair<T, T> val() const { return {m_num, m_den}; }\n    constexpr T num() const { return m_num; }\n    constexpr T den() const { return m_den; }\n\nprivate:\n    static constexpr Pair<T, T> norm(T num, T den)\n    {\n        if (den < 0) { num = -num, den = -den; }\n        const auto g = std::gcd(num, den);\n        return {num / g, den / g};\n    }\n    T m_num, m_den;\n};\n",
    "result": "NOT_TESTED",
    "verified_with": []
}