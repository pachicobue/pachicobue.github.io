{
    "code": "#pragma once\n#include \"../../common.hpp\"\ntemplate<typename SemiGroup>\nclass SwagDeque\n{\n    using T = typename SemiGroup::T;\n\npublic:\n    SwagDeque() {}\n    void pushBack(const T& x)\n    {\n        m_backs.push_back(x);\n        m_Backs.push_back(m_Backs.empty() ? x : m_merge(m_Backs.back(), x));\n    }\n    void pushFront(const T& x)\n    {\n        m_fronts.push_back(x);\n        m_Fronts.push_back(m_Fronts.empty() ? x : m_merge(x, m_Fronts.back()));\n    }\n    void popBack()\n    {\n        if (m_Backs.empty()) {\n            Vec<T> as = m_fronts;\n            m_fronts.clear(), m_Fronts.clear();\n            reverseAll(as);\n            const int f = (int)as.size() / 2;\n            for (int i : per(f)) { m_fronts.push_back(as[i]); }\n            for (int i : irange(f, (int)as.size() - 1)) { m_backs.push_back(as[i]); }\n            calc();\n        } else {\n            m_backs.pop_back(), m_Backs.pop_back();\n        }\n    }\n    void popFront()\n    {\n        if (m_Fronts.empty()) {\n            Vec<T> as = m_backs;\n            m_backs.clear(), m_Backs.clear();\n            const int f = ((int)as.size() + 1) / 2;\n            for (int i : irange(f - 1, 0, -1)) { m_fronts.push_back(as[i]); }\n            for (int i : irange(f, (int)as.size())) { m_backs.push_back(as[i]); }\n            calc();\n        } else {\n            m_fronts.pop_back(), m_Fronts.pop_back();\n        }\n    }\n    T foldAll() const\n    {\n        return m_fronts.empty()\n                   ? m_Backs.back()\n                   : (m_backs.empty() ? m_Fronts.back() : m_merge(m_Fronts.back(), m_Backs.back()));\n    }\n    bool empty() const { return m_backs.empty() and m_fronts.empty(); }\n\nprivate:\n    void calc()\n    {\n        if (not m_fronts.empty()) {\n            m_Fronts.push_back(m_fronts[0]);\n            for (int i : irange(1, m_fronts.size())) {\n                m_Fronts.push_back(m_merge(m_fronts[i], m_Fronts.back()));\n            }\n        }\n        if (not m_backs.empty()) {\n            m_Backs.push_back(m_backs[0]);\n            for (int i : irange(1, m_backs.size())) {\n                m_Backs.push_back(m_merge(m_Backs.back(), m_backs[i]));\n            }\n        }\n    }\n    Vec<T> m_fronts, m_backs;\n    Vec<T> m_Fronts, m_Backs;\n    static inline SemiGroup m_merge;\n};\n",
    "result": "NOT_TESTED",
    "verified_with": [
        "verifications/data_structure/sliding_window_aggregation/deque.test.cpp"
    ]
}