{
    "code": "#pragma once\n#include \"../../common.hpp\"\ntemplate<typename MergeMonoid>\nclass SegTree\n{\n    using T = typename MergeMonoid::T;\n    static constexpr T e() { return MergeMonoid::e(); }\n\npublic:\n    SegTree(const Vec<T>& vs)\n        : m_size(vs.size()), m_half(bitCeil(m_size)), m_vals(m_half << 1, MergeMonoid::e())\n    {\n        std::copy(vs.begin(), vs.end(), m_vals.begin() + m_half);\n        for (int i = m_half - 1; i >= 1; i--) { up(i); }\n    }\n    SegTree(int N, const T& v = MergeMonoid::e()) : SegTree{Vec<T>(N, v)} {}\n    T get(int i) const\n    {\n        assert(0 <= i and i < m_size);\n        return m_vals[i + m_half];\n    }\n    void set(int i, const T& v)\n    {\n        assert(0 <= i and i < m_size);\n        m_vals[i += m_half] = v;\n        while (i >>= 1) { up(i); }\n    }\n    T fold(int l, int r) const\n    {\n        assert(0 <= l and l <= r and r <= m_size);\n        T lv = e(), rv = e();\n        int li = l + m_half, ri = r + m_half;\n        for (; li < ri; li >>= 1, ri >>= 1) {\n            if (li & 1) { lv = merge(lv, m_vals[li++]); }\n            if (ri & 1) { rv = merge(m_vals[--ri], rv); }\n        }\n        return merge(lv, rv);\n    }\n    friend Ostream& operator<<(Ostream& os, const SegTree& seg)\n    {\n        os << \"[\";\n        for (int i : rep(seg.m_size)) { os << (i == 0 ? \"\" : \",\") << seg.m_vals[i + seg.m_half]; }\n        return (os << \"]\");\n    }\n\nprivate:\n    void up(int i) { m_vals[i] = merge(m_vals[i << 1], m_vals[i << 1 | 1]); }\n    int m_size, m_half;\n    Vec<T> m_vals;\n    static inline MergeMonoid merge;\n};\n",
    "result": "NOT_TESTED",
    "verified_with": [
        "verifications/data_structure/segment_tree/segtree.test.cpp",
        "verifications/graph/tree/heavy_light_decomposition.test.cpp"
    ]
}