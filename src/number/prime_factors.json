{
    "code": "#pragma once\n#include \"../common.hpp\"\n#include \"../utility/rng.hpp\"\n#include \"miller_rabin.hpp\"\ntemplate<typename mint>\nu64 pollardRho(u64 n)\n{\n    if (n % 2 == 0) { return 2; }\n    if (isPrime(n)) { return n; }\n    mint c;\n    auto f = [&](const mint& x) { return x * x + c; };\n    while (true) {\n        mint x, y, ys, q = 1;\n        y = rng64.val<u64>(0, n - 2) + 2;\n        c = rng64.val<u64>(0, n - 2) + 2;\n        u64 d = 1;\n        constexpr u32 dk = 128;\n        for (u32 r = 1; d == 1; r <<= 1) {\n            x = y;\n            for (u32 i = 0; i < r; i++) { y = f(y); }\n            for (u32 k = 0; k < r and d == 1; k += dk) {\n                ys = y;\n                for (u32 i = 0; i < dk and i < r - k; i++) { q *= x - (y = f(y)); }\n                d = std::gcd((u64)q.val(), n);\n            }\n        }\n        if (d == n) {\n            do {\n                d = std::gcd(u64((x - (ys = f(ys))).val()), n);\n            } while (d == 1);\n        }\n        if (d != n) { return d; }\n    }\n    return n;\n}\nMap<u64, int> primeFactors(u64 n)\n{\n    using mint = modint_dynamic<287687412>;\n    using mint64 = modint64_dynamic<4832432>;\n    Map<u64, int> ans;\n    Fix([&](auto dfs, u64 x) -> void {\n        while ((x & 1) == 0) { x >>= 1, ans[2]++; }\n        if (x == 1) { return; }\n        u64 p;\n        if (x < (1ULL << 30)) {\n            mint::setMod(x);\n            p = pollardRho<mint>(x);\n        } else {\n            mint64::setMod(x);\n            p = pollardRho<mint64>(x);\n        }\n        if (p == x) {\n            ans[p]++;\n            return;\n        }\n        dfs(p), dfs(x / p);\n    })(n);\n    return ans;\n}\nVec<u64> divisors(const u64 n)\n{\n    const auto fs = primeFactors(n);\n    Vec<u64> ds{1};\n    for (const auto& [p, e] : fs) {\n        u64 pe = p;\n        const u32 dn = ds.size();\n        for (i32 i = 0; i < e; i++, pe *= p) {\n            for (u32 j = 0; j < dn; j++) { ds.push_back(ds[j] * pe); }\n        }\n    }\n    return ds;\n}\n",
    "result": "NOT_TESTED",
    "verified_with": [
        "verifications/number/mod_nthroot.yuki.test.cpp",
        "verifications/number/prime_factors.test.cpp",
        "verifications/number/mod_nthroot.test.cpp"
    ]
}