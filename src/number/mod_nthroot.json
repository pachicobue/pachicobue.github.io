{
    "code": "#pragma once\n#include \"../common.hpp\"\n#include \"../algorithm/ext_gcd.hpp\"\n#include \"prime_factors.hpp\"\ntemplate<typename mint>\nmint modNthRoot(mint A, i64 k)\n{\n    const i64 P = mint::mod();\n    assert(P > 0);\n    if (A == 0) { return 0; }\n    if (k == 0) { return A; }\n    const i64 g = std::gcd(P - 1, k);\n    if (A.pow((P - 1) / g).val() != 1) { return 0; }\n    A = A.pow(inverse(k / g, (P - 1) / g));\n    if (g == 1) { return A; }\n    const auto fs = primeFactors(g);\n    for (const auto& [p, e] : fs) {\n        i64 pe = 1;\n        LOOP (e) { pe *= p; }\n        i64 q = P - 1, Q = 0;\n        while (q % p == 0) { q /= p, Q++; }\n        auto [y, z] = extgcd(-q, pe);\n        if (y <= 0) { y += pe, z += q; }\n        mint X = A.pow(z);\n        if ((int)Q == e) {\n            A = X;\n            continue;\n        }\n        mint Eraser = 1;\n        const i64 h = (P - 1) / p;\n        for (mint Z = 2;; Z += 1) {\n            if (Z.pow(h) != 1) {\n                Eraser = Z.pow(q);\n                break;\n            }\n        }\n        mint Error = A.pow(y * q);\n        mint pEraser = Eraser;\n        LOOP (Q - 1) { pEraser = pEraser.pow(p); }\n        const mint ipEraser = pEraser.inv();\n        UMap<i64, i64> memo;\n        {\n            const i64 M = std::max(1_i64, (i64)(std::sqrt(p) * std::sqrt(Q - e)));\n            const i64 B = std::max(1_i64, ((i64)p - 1) / M);\n            const mint ppEraser = pEraser.pow(B);\n            mint prod = 1;\n            for (i64 i = 0; i < (i64)p; i += B, prod *= ppEraser) { memo[prod.val()] = i; }\n        }\n        while (Error.val() != 1) {\n            i64 l = 0;\n            mint pError = Error;\n            for (i64 i : rep(Q)) {\n                const auto npError = pError.pow(p);\n                if (npError == 1) {\n                    l = Q - (i + 1);\n                    break;\n                }\n                pError = npError;\n            }\n            i64 c = -1;\n            {\n                mint small = pError.inv();\n                for (i64 j = 0;; j++, small *= ipEraser) {\n                    if (memo.count(small.val())) {\n                        const i64 i = memo[small.val()];\n                        c = i + j;\n                        break;\n                    }\n                }\n            }\n            auto pEraser2 = Eraser.pow(c);\n            LOOP (l - e) { pEraser2 = pEraser2.pow(p); }\n            X *= pEraser2, Error *= pEraser2.pow(pe);\n        }\n        A = X;\n    }\n    return A;\n}\n",
    "result": "NOT_TESTED",
    "verified_with": [
        "verifications/number/mod_nthroot.yuki.test.cpp",
        "verifications/number/mod_nthroot.test.cpp"
    ]
}