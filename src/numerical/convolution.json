{
    "code": "#pragma once\n#include \"number_theoritic_transform.hpp\"\n#include \"../number/garner.hpp\"\n#include \"../utility/modint.hpp\"\ntemplate<typename mint>\nVec<mint> convolute_mod(const Vec<mint>& as, const Vec<mint>& bs)\n{\n    constexpr u32 L_MAX = mint::max2p();\n    constexpr int N_MAX = (1 << L_MAX);\n    const int AN = as.size();\n    const int BN = bs.size();\n    if (AN == 0 or BN == 0) { return {}; }\n    if (AN > BN) { return convolute_mod(bs, as); }\n    const int N = AN + BN - 1;\n    if (AN * 2 <= BN) {\n        Vec<mint> cs(N, 0);\n        for (int sj : irange(0, BN, AN)) {\n            const int tj = std::min(BN, sj + AN);\n            const auto bbs = Vec<mint>(std::begin(bs) + sj, std::begin(bs) + tj);\n            const auto bcs = convolute_mod(as, bbs);\n            for (int dj : rep(bcs.size())) { cs[sj + dj] += bcs[dj]; }\n        }\n        return cs;\n    }\n    if (N <= N_MAX) {\n        // mint\u306fNTT Friendly\u306a\u306e\u3067\u305d\u306e\u307e\u307e\u7573\u307f\u8fbc\u307f\n        return NumberTheoriticTransform<mint>::convolute(as, bs);\n    } else {\n        assert(N <= (1 << 24));\n        using submint1 = modint<469762049, 3, 26>;\n        using submint2 = modint<167772161, 3, 25>;\n        using submint3 = modint<754974721, 11, 24>;\n        // mod 3\u3064\u3067Garner\u5fa9\u5143\n        Vec<submint1> as1(AN), bs1(BN);\n        Vec<submint2> as2(AN), bs2(BN);\n        Vec<submint3> as3(AN), bs3(BN);\n        for (int i : rep(AN)) { as1[i] = as[i].val(), as2[i] = as[i].val(), as3[i] = as[i].val(); }\n        for (int i : rep(BN)) { bs1[i] = bs[i].val(), bs2[i] = bs[i].val(), bs3[i] = bs[i].val(); }\n        const auto cs1 = NumberTheoriticTransform<submint1>::convolute(as1, bs1);\n        const auto cs2 = NumberTheoriticTransform<submint2>::convolute(as2, bs2);\n        const auto cs3 = NumberTheoriticTransform<submint3>::convolute(as3, bs3);\n        Vec<mint> cs(N);\n        for (int i : rep(N)) { cs[i] = Garner::restore_mod<mint>(cs1[i], cs2[i], cs3[i]); }\n        return cs;\n    }\n}\ntemplate<typename I>\nVec<i64> convolute_i64(const Vec<I>& as, const Vec<I>& bs)\n{\n    const int AN = as.size();\n    const int BN = bs.size();\n    if (AN == 0 or BN == 0) { return {}; }\n    if (AN > BN) { return convolute_i64<I>(bs, as); }\n    const int N = AN + BN - 1;\n    assert(N <= (1 << 24));\n    if (AN * 2 <= BN) {\n        Vec<i64> cs(N, 0);\n        for (int sj : irange(0, BN, AN)) {\n            const int tj = std::min(BN, sj + AN);\n            const auto bbs = Vec<I>(std::begin(bs) + sj, std::begin(bs) + tj);\n            const auto bcs = convolute_i64<I>(as, bbs);\n            for (int dj : rep(bcs.size())) { cs[sj + dj] += bcs[dj]; }\n        }\n        return cs;\n    }\n    using submint1 = modint<469762049, 3, 26>;\n    using submint2 = modint<167772161, 3, 25>;\n    using submint3 = modint<754974721, 11, 24>;\n    // mod 3\u3064\u3067Garner\u5fa9\u5143\n    Vec<submint1> as1(AN), bs1(BN);\n    Vec<submint2> as2(AN), bs2(BN);\n    Vec<submint3> as3(AN), bs3(BN);\n    for (int i : rep(AN)) { as1[i] = as[i], as2[i] = as[i], as3[i] = as[i]; }\n    for (int i : rep(BN)) { bs1[i] = bs[i], bs2[i] = bs[i], bs3[i] = bs[i]; }\n    const auto cs1 = NumberTheoriticTransform<submint1>::convolute(as1, bs1);\n    const auto cs2 = NumberTheoriticTransform<submint2>::convolute(as2, bs2);\n    const auto cs3 = NumberTheoriticTransform<submint3>::convolute(as3, bs3);\n    Vec<i64> cs(N);\n    for (int i : rep(N)) { cs[i] = Garner::restore_i64(cs1[i], cs2[i], cs3[i]); }\n    return cs;\n}\n",
    "result": "NOT_TESTED",
    "verified_with": [
        "verifications/numerical/convolution.ut.test.cpp",
        "verifications/formal_power_series/formal_power_series.exp.test.cpp",
        "verifications/formal_power_series/formal_power_series.log.test.cpp",
        "verifications/formal_power_series/formal_power_series.pow.test.cpp",
        "verifications/formal_power_series/formal_power_series.inv.test.cpp",
        "verifications/formal_power_series/formal_power_series.convolution.test.cpp",
        "verifications/formal_power_series/formal_power_series.convolution1000000007.test.cpp",
        "verifications/formal_power_series/bostan_mori.test.cpp"
    ]
}