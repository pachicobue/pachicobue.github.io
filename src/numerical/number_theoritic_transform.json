{
    "code": "#pragma once\n#include \"../common.hpp\"\ntemplate<typename mint>\nclass NumberTheoriticTransform\n{\n    // DynamicModint \u975e\u5bfe\u5fdc\n    static_assert(not mint::isDynamic(), \"class NTT: Not support dynamic modint.\");\n\nprivate:\n    static constexpr u32 MOD = mint::mod();\n    static constexpr u32 ROOT = mint::root();\n    static constexpr u32 L_MAX = mint::max2p();\n    static constexpr int N_MAX = (1 << L_MAX);\n\npublic:\n    static Vec<mint> convolute(Vec<mint> as, Vec<mint> bs)\n    {\n        const int AN = as.size();\n        const int BN = bs.size();\n        const int CN = AN + BN - 1;\n        const int N = bitCeil(CN);\n        as.resize(N, 0), bs.resize(N, 0);\n        transform(as, false), transform(bs, false);\n        for (int i : rep(N)) { as[i] *= bs[i]; }\n        transform(as, true);\n        as.resize(CN);\n        return as;\n    }\n    static void transform(Vec<mint>& as, bool rev)\n    {\n        const int N = as.size();\n        assert(hasSingleBit(N));\n        if (N == 1) { return; }\n        const int L = topBit(N);\n        const auto l_range = (rev ? irange(1, L + 1, 1) : irange(L, 0, -1));\n        for (int l : l_range) {\n            const int H = 1 << l;\n            const int B = N / H;\n            for (int b : rep(B)) {\n                const mint W = zeta(l, rev);\n                mint W_h = 1;\n                for (int h : rep(H / 2)) {\n                    const int y1 = H * b + h;\n                    const int y2 = y1 + H / 2;\n                    const mint a1 = as[y1];\n                    const mint a2 = as[y2];\n                    const mint na1 = (rev ? a1 + a2 * W_h : a1 + a2);\n                    const mint na2 = (rev ? a1 - a2 * W_h : (a1 - a2) * W_h);\n                    as[y1] = na1;\n                    as[y2] = na2;\n                    W_h *= W;\n                }\n            }\n        }\n        if (rev) {\n            const mint iN = mint::sinv(N);\n            for (auto& a : as) { a *= iN; }\n        }\n    }\n\nprivate:\n    static mint zeta(int i, bool rev)\n    {\n        static Vec<mint> zs;   // zs[i] = 1\u306e2^i\u4e57\u6839\n        static Vec<mint> izs;  // izs[i] = zs[i]\u306e\u9006\u5143\n        if (zs.empty()) {\n            zs.resize(L_MAX + 1, 1);\n            izs.resize(L_MAX + 1, 1);\n            zs[L_MAX] = mint(ROOT).pow((MOD - 1) / (1 << L_MAX));\n            izs[L_MAX] = zs[L_MAX].inv();\n            for (int l : per(L_MAX)) {\n                zs[l] = zs[l + 1] * zs[l + 1];\n                izs[l] = izs[l + 1] * izs[l + 1];\n            }\n        }\n        return (rev ? izs[i] : zs[i]);\n    }\n};\n",
    "result": "NOT_TESTED",
    "verified_with": [
        "verifications/numerical/convolution.ut.test.cpp",
        "verifications/formal_power_series/formal_power_series.exp.test.cpp",
        "verifications/formal_power_series/formal_power_series.log.test.cpp",
        "verifications/formal_power_series/formal_power_series.pow.test.cpp",
        "verifications/formal_power_series/formal_power_series.inv.test.cpp",
        "verifications/formal_power_series/formal_power_series.convolution.test.cpp",
        "verifications/formal_power_series/formal_power_series.convolution1000000007.test.cpp",
        "verifications/formal_power_series/bostan_mori.test.cpp"
    ]
}