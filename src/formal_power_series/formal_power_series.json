{
    "code": "#pragma once\n#include \"../common.hpp\"\n#include \"../numerical/convolution.hpp\"\ntemplate<typename mint>\nclass FormalPowerSeries : public Vec<mint>\n{\n    using Vec<mint>::resize;\n    using Vec<mint>::push_back;\n    using Vec<mint>::pop_back;\n    using Vec<mint>::back;\n\npublic:\n    using typename Vec<mint>::vector;\n    FormalPowerSeries(const Vec<mint>& vs) : Vec<mint>{vs} { optimize(); }\n    int size() const { return (int)Vec<mint>::size(); }\n    int deg() const { return size() - 1; }\n    template<typename I>\n    void shrink(I n)\n    {\n        if (n >= (I)size()) { return; }\n        Vec<mint>::resize(n);\n        optimize();\n    }\n    template<typename I>\n    FormalPowerSeries low(I n) const\n    {\n        const I sz = std::min(n, (I)size());\n        return FormalPowerSeries{this->begin(), this->begin() + (int)sz};\n    }\n    mint& operator[](const int n)\n    {\n        if (n >= size()) { resize(n + 1, 0); }\n        return Vec<mint>::operator[](n);\n    }\n    template<typename I>\n    mint at(const I n) const\n    {\n        return (n < size() ? (*this)[n] : mint{0});\n    }\n    FormalPowerSeries operator-() const\n    {\n        FormalPowerSeries ans = *this;\n        for (auto& v : ans) { v = -v; }\n        return ans;\n    }\n    FormalPowerSeries& operator+=(const FormalPowerSeries& f)\n    {\n        for (int i : rep(f.size())) { (*this)[i] += f[i]; }\n        return *this;\n    }\n    FormalPowerSeries& operator-=(const FormalPowerSeries& f)\n    {\n        for (int i : rep(f.size())) { (*this)[i] -= f[i]; }\n        return *this;\n    }\n    FormalPowerSeries& operator*=(const FormalPowerSeries& f) { return (*this) = (*this) * f; }\n    FormalPowerSeries& operator<<=(const int s) { return *this = (*this << s); }\n    FormalPowerSeries& operator>>=(const int s) { return *this = (*this >> s); }\n    FormalPowerSeries operator+(const FormalPowerSeries& f) const\n    {\n        return FormalPowerSeries(*this) += f;\n    }\n    FormalPowerSeries operator-(const FormalPowerSeries& f) const\n    {\n        return FormalPowerSeries(*this) -= f;\n    }\n    FormalPowerSeries operator*(const FormalPowerSeries& f) const\n    {\n        return mult(f, size() + f.size() - 1);\n    }\n    FormalPowerSeries operator>>(int shift) const\n    {\n        FormalPowerSeries ans(size() + shift);\n        for (int i : rep(size())) { ans[i + shift] = (*this)[i]; }\n        return ans;\n    }\n    FormalPowerSeries operator<<(int shift) const\n    {\n        FormalPowerSeries ans;\n        for (int i : irange(shift, size())) { ans[i - shift] = (*this)[i]; }\n        return ans;\n    }\n    int lsb() const\n    {\n        for (int i : rep(size())) {\n            if ((*this)[i] != 0) { return i; }\n        }\n        return size();\n    }\n    bool isZero() const { return (size() == 1) and ((*this)[0] == 0); }\n    friend Ostream& operator<<(Ostream& os, const FormalPowerSeries& f)\n    {\n        return os << static_cast<Vec<mint>>(f);\n    }\n    FormalPowerSeries derivative() const\n    {\n        FormalPowerSeries ans;\n        for (int i : irange(1, size())) { ans[i - 1] = (*this)[i] * i; }\n        return ans;\n    }\n    FormalPowerSeries integral() const\n    {\n        FormalPowerSeries ans;\n        for (int i : irange(1, size() + 1)) { ans[i] = (*this)[i - 1] * mint::sinv(i); }\n        return ans;\n    }\n    FormalPowerSeries mult(const FormalPowerSeries& f, int size) const\n    {\n        assert(size > 0);\n        return FormalPowerSeries{convolute_mod(*this, f)}.low(size);\n    }\n    FormalPowerSeries inv(int size) const\n    {\n        assert(size > 0);\n        assert((*this)[0].val() != 0);\n        FormalPowerSeries g{(*this)[0].inv()};\n        for (int m = 1; m < size; m *= 2) {\n            auto f = low(m * 2);\n            g = (FormalPowerSeries{2} - f.mult(g, m * 2)).mult(g, 2 * m);\n        }\n        return g.low(size);\n    }\n    FormalPowerSeries log(int size) const\n    {\n        assert(size > 0);\n        assert((*this)[0] == 1);\n        return derivative().mult(inv(size), size).integral().low(size);\n    }\n    FormalPowerSeries exp(int size) const\n    {\n        assert(size > 0);\n        assert((*this)[0] == 0);\n        FormalPowerSeries g{1};\n        for (int m = 1; m < size; m *= 2) {\n            auto f = low(m * 2);\n            g = g.mult(FormalPowerSeries{1} - g.log(m * 2) + f, 2 * m);\n        }\n        return g.low(size);\n    }\n    template<typename I>\n    FormalPowerSeries pow(I n) const\n    {\n        return pow(n, deg() * n + 1);\n    }\n    template<typename I>\n    FormalPowerSeries pow(I n, int size) const\n    {\n        assert(size > 0);\n        if (n == 0) { return FormalPowerSeries{1}; }\n        if (isZero()) { return FormalPowerSeries{0}; }\n        const int k = lsb();\n        if (k >= ((I)size + n - 1) / n) { return FormalPowerSeries{}; }\n        size -= k * n;\n        auto f = ((*this) << k).low(size);\n        const mint c = f[0];\n        f *= FormalPowerSeries{c.inv()};\n        return ((f.log(size) * FormalPowerSeries{n}).exp(size) * FormalPowerSeries{c.pow(n)})\n               >> (k * n);\n    }\n\nprivate:\n    const mint& operator[](const int n) const\n    {\n        assert(n < size());\n        return Vec<mint>::operator[](n);\n    }\n    void optimize()\n    {\n        while (size() > 0) {\n            if (back() != 0) { return; }\n            pop_back();\n        }\n        if (size() == 0) { push_back(0); }\n    }\n};\n",
    "result": "NOT_TESTED",
    "verified_with": [
        "verifications/formal_power_series/formal_power_series.exp.test.cpp",
        "verifications/formal_power_series/formal_power_series.log.test.cpp",
        "verifications/formal_power_series/formal_power_series.pow.test.cpp",
        "verifications/formal_power_series/formal_power_series.inv.test.cpp",
        "verifications/formal_power_series/formal_power_series.convolution.test.cpp",
        "verifications/formal_power_series/formal_power_series.convolution1000000007.test.cpp",
        "verifications/formal_power_series/bostan_mori.test.cpp"
    ]
}