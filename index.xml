<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>bue.js</title><link>https://pachicobue.github.io/</link><description>Recent content on bue.js</description><generator>Hugo -- gohugo.io</generator><language>ja-jp</language><atom:link href="https://pachicobue.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Bit Vector</title><link>https://pachicobue.github.io/algolib/data_structure/wavelet/bit_vector/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pachicobue.github.io/algolib/data_structure/wavelet/bit_vector/</guid><description>概要 簡潔データ構造の基本となるデータ構造 長さ$N$ の $0/1$ 数列 $A = \lbrace A _ 0, A _ 1, \dots, A _ {N-1} \rbrace$ について、以下の操作を行う。 rank: 先頭から $i$ 項目までの $1$ の</description></item><item><title>Disjoint Sparse Table</title><link>https://pachicobue.github.io/algolib/data_structure/sparse_table/disjoint_sparse_table/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pachicobue.github.io/algolib/data_structure/sparse_table/disjoint_sparse_table/</guid><description>概要 半群 $(T, \ast)$ 上の要素数 $N$ の 数列 $A = \lbrack A _ 0, A _ 1, \dots , A _ {N-1}\rbrack$ について、 以下の操作が $\mathrm{O}(1)$ でできる。 範囲総積取得: $A _ l \ast \dots \ast A _ {r-1}$ 前計算は $\mathrm{O}(N\log N)$ 必要</description></item><item><title>Dual Segment Tree</title><link>https://pachicobue.github.io/algolib/data_structure/segment_tree/dual_segtree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pachicobue.github.io/algolib/data_structure/segment_tree/dual_segtree/</guid><description>概要 作用素モノイド $(F, \circ, \mathrm{id})$ が決まっている。 要素数 $N$ の 作用素列 $G = \lbrack G _ 0, G _ 1, \dots, G _ {N-1}\rbrack$ について、以下の操作が $\mathrm{O}(\log N)$ でできる。 範囲作用: $G _ i \leftarrow f</description></item><item><title>Fenwick Tree</title><link>https://pachicobue.github.io/algolib/data_structure/fenwick_tree/fenwick_tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pachicobue.github.io/algolib/data_structure/fenwick_tree/fenwick_tree/</guid><description>概要 要素数 $N$ の 数列 $A = \lbrack A _ 0, A _ 1, \dots , A _ {N-1} \rbrack$ について、以下の操作が $\mathrm{O}(\log N)$ でできる。 一点加算: $A _ i \leftarrow A _ i + x$ 接頭辞総和取得: $A _ 0 + A _</description></item><item><title>Lazy Segment Tree</title><link>https://pachicobue.github.io/algolib/data_structure/segment_tree/lazy_segtree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pachicobue.github.io/algolib/data_structure/segment_tree/lazy_segtree/</guid><description>概要 値モノイド $(T, \ast, e)$ と モノイド作用 $(F, \circ, \mathrm{id})$ が決まっている。 更に $f(x _ 1 \ast x _ 2) = f(x _ 1) \ast f(x _ 2)\quad (\forall f \in F, x _ 1 x _ 2 \in T)$ が成立しているとする。 要素</description></item><item><title>Li Chao Tree</title><link>https://pachicobue.github.io/algolib/convex_hull_trick/li_chao_tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pachicobue.github.io/algolib/convex_hull_trick/li_chao_tree/</guid><description>概要 線分 $s _ i(x): y = a _ i x + b _ i (l _ i \le x \lt r _ i)$ の集合 $\mathcal{S}$ について以下の操作を $\mathrm{O}(\log N)$ で行う。 線分追加: $\mathcal{S} \leftarrow \mathcal{S} \cup \lbrace s:y=ax+b (l \le x \le r) \rbrace$ 最小値取得: $\mathrm{argmin}_{l</description></item><item><title>Mo's Algorithm</title><link>https://pachicobue.github.io/algolib/algorithm/mo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pachicobue.github.io/algolib/algorithm/mo/</guid><description>概要 $N$ 個の 二次元格子点 $P _ i = (x _ i, y _ i)$ が与えられる。以下これをターミナルという。 また $0 \le x _ i, y _ i \lt L$ であるとする。 $(0,0)$ からスタートして</description></item><item><title>Printer (出力補助クラス)</title><link>https://pachicobue.github.io/algolib/utility/printer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pachicobue.github.io/algolib/utility/printer/</guid><description>概要 出力を行うクラス 「複数の値を空白区切りで出力して末尾改行」みたいのをラップしている。 I/F コンストラクタ Printer printer(Ostream&amp;amp; os = std::cout) 引数には出力先(デフォルト</description></item><item><title>Scanner (入力補助クラス)</title><link>https://pachicobue.github.io/algolib/utility/scanner/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pachicobue.github.io/algolib/utility/scanner/</guid><description>概要 入力を行うクラス 入力した値を返すので const で受け取ったりできるのが利点。 複数の入力を tuple にして返したり、vector配列で返したりできる。 I/F コ</description></item><item><title>Segment Tree</title><link>https://pachicobue.github.io/algolib/data_structure/segment_tree/segtree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pachicobue.github.io/algolib/data_structure/segment_tree/segtree/</guid><description>概要 値モノイド $(T, \ast, e)$ が決まっている。 要素数 $N$ の 数列 $A = \lbrack A _ 0, A _ 1, \dots , A _ {N-1}\rbrack$ について、以下の操作が $\mathrm{O}(\log N)$ でできる。 範囲総積取得: $A _ l \ast \dots \ast</description></item><item><title>Sliding Window Aggregation(Deque)</title><link>https://pachicobue.github.io/algolib/data_structure/sliding_window_aggregation/deque/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pachicobue.github.io/algolib/data_structure/sliding_window_aggregation/deque/</guid><description>概要 半群 $(T, \ast)$ 上の数列 $A = \lbrack A _ 0, A _ 1, \dots , A _ {n-1}\rbrack$ について、 以下の操作が $\mathrm{O}(1)$ でできる。 総積取得: $A _ 0 \ast \dots \ast A _ {n-1}$ 先頭挿入: $A \leftarrow \lbrack v, A _ 0, \dots, A _</description></item><item><title>Union Find Tree</title><link>https://pachicobue.github.io/algolib/data_structure/union_find_tree/union_find_tree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pachicobue.github.io/algolib/data_structure/union_find_tree/union_find_tree/</guid><description>概要 $N$ 頂点の無向グラフ $G$ に対して、以下の操作がならし $\mathrm{O}(\alpha(N))$ でできる。 辺追加 連結性判定 I/F コンストラクタ DSU dsu(int N) グラフ $G$ を $N$ 頂点 $0$ 辺の無向グラフで初期</description></item><item><title>静的数列のRMQ</title><link>https://pachicobue.github.io/algolib/data_structure/sparse_table/static_rmq/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pachicobue.github.io/algolib/data_structure/sparse_table/static_rmq/</guid><description>概要 全順序集合 $(T, &amp;lt;)$ が決まっている。 要素数 $N$ の 数列 $A = \lbrack A _ 0, A _ 1, \dots , A _ {N-1}\rbrack$ について、以下の操作が $\mathrm{O}(1)$ でできる。 範囲min取得: $A _ l \dots A _ {r-1}$</description></item><item><title>単調性のある Convex Hull Trick</title><link>https://pachicobue.github.io/algolib/convex_hull_trick/monotone_cht/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pachicobue.github.io/algolib/convex_hull_trick/monotone_cht/</guid><description>概要 直線 $l _ i(x): y = a _ i x + b _ i$ の集合 $\mathcal{L}$ について以下の操作を ならし$\mathrm{O}(1)$ で行う。 直線追加: $\mathcal{L} \leftarrow \mathcal{L} \cup \lbrace l:y=ax+b \rbrace$ 最小値取得</description></item><item><title>二重辺連結成分分解</title><link>https://pachicobue.github.io/algolib/graph/two_edge_connected_components/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://pachicobue.github.io/algolib/graph/two_edge_connected_components/</guid><description>概要 $V$頂点$E$辺 の無向グラフを $\mathrm{O}(V+E)$ 時間で二重辺連結成分に分解する。 I/F コンストラクタ TwoEdgeConnectedComponent tecc(Graph&amp;lt;T&amp;gt; g) グラフ $g$ を二重辺連結成分分解する。 計算量 $\mathrm{O}(V+E)$ operator[] int tecc[i]</description></item></channel></rss>