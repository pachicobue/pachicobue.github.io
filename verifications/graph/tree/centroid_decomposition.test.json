{
    "code": "// verification-helper: PROBLEM https://yukicoder.me/problems/no/1002\n#include \"graph/tree/centroid_decomposition.hpp\"\n#include \"utility/nd_vec.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\n\nint main()\n{\n    const auto [N, K] = in.tup<int, int>();\n    Graph<int> g(N);\n    LOOP (N - 1) {\n        const auto [u, v, c] = in.tup<int, int, int>(1, 1, 1);\n        g.addEdge(u, v, c, true);\n    }\n    CentroidDecomposition centros(g);\n    const int cr = centros.center();\n    const auto cg = centros.centers();\n    Vec<bool> used(N, false);\n    using P = Pair<int, int>;\n    i64 ans = 0;\n\n    auto f = [&](const Map<int, i64>& dp1,\n                 const Map<P, i64>& dp2,\n                 const Map<int, i64>& dp3,\n                 const i64 one) -> i64 {\n        i64 ans = 0;\n        i64 dbl = 0;\n        for (const auto& [k, n] : dp1) {\n            ans += n * (dp3.at(k) - n);  // 1\u8272x2\u8272\n            dbl += n * (one - n);        // 1\u8272x1\u8272\n        }\n        for (UNUSED const auto& [_, n] : dp2) {\n            ans += n * (n - 1) / 2;  // 2\u8272x2\u8272\n        }\n        return ans + dbl / 2;\n    };\n\n    Fix([&](auto dfs, int c) -> void {\n        used[c] = true;\n        Map<int, i64> dp1;\n        Map<P, i64> dp2;\n        Map<int, i64> dp3;\n        int one = 0;\n        for (const auto& e : g[c]) {\n            if (used[e.to]) { continue; }\n            Map<int, i64> subdp1;\n            Map<P, i64> subdp2;\n            Map<int, i64> subdp3;\n            i64 sone = 0;\n            Fix([&](auto dfs, int u, int p, const P& ks) -> void {\n                if (ks.second == INF<int>) {\n                    dp1[ks.first]++;\n                    dp3[ks.first]++;\n                    subdp1[ks.first]++;\n                    subdp3[ks.first]++;\n                    sone++;\n                    one++;\n                } else {\n                    ans++;\n                    dp2[ks]++;\n                    dp3[ks.first]++;\n                    dp3[ks.second]++;\n                    subdp2[ks]++;\n                    subdp3[ks.first]++;\n                    subdp3[ks.second]++;\n                }\n                for (const auto& e : g[u]) {\n                    const int v = e.to;\n                    if (v == p or used[v]) { continue; }\n                    const int k = e.cost;\n                    auto nks = ks;\n                    if (ks.first == k or ks.second == k) {\n                        ;\n                    } else if (ks.second == INF<int>) {\n                        nks.second = k;\n                    } else {\n                        continue;\n                    }\n                    if (nks.first > nks.second) { std::swap(nks.first, nks.second); }\n                    dfs(v, u, nks);\n                }\n            })(e.to, c, P{e.cost, INF<int>});\n            ans -= f(subdp1, subdp2, subdp3, sone);\n        }\n        ans += f(dp1, dp2, dp3, one);\n        for (int nc : cg[c]) { dfs(nc); }\n    })(cr);\n    out.ln(ans);\n    return 0;\n}\n",
    "result": "AC"
}