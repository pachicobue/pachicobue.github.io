{
    "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/range_chmin_chmax_add_range_sum\n#include \"data_structure/segment_tree/segtree_beats.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\n\nauto secondMin(i64 a1, i64 a2, i64 b1, i64 b2) -> i64\n{\n    return a1 == b1 ? std::min(a2, b2) : a2 < b1 ? a2 : b2 < a1 ? b2 : std::max(a1, b1);\n}\nauto secondMax(i64 a1, i64 a2, i64 b1, i64 b2) -> i64\n{\n    return a1 == b1 ? std::max(a2, b2) : a2 > b1 ? a2 : b2 > a1 ? b2 : std::min(a1, b1);\n}\nauto clamp(i64 x, i64 low, i64 hi) -> i64 { return std::min(hi, std::max(low, x)); }\n\nstruct MergeMonoid\n{\n    struct T\n    {\n        Arr<i64, 2> mins;  // 1st min, 2nd min\n        Arr<i64, 2> maxs;  // 1st max, 2nd max\n        i64 sum;\n        int size;\n        int minnum, maxnum;\n        bool failed;\n    };\n    static T e() { return {{INF<i64>, INF<i64>}, {-INF<i64>, -INF<i64>}, 0_i64, 0, 0, 0, false}; }\n    T operator()(const T& x1, const T& x2) const\n    {\n        const auto& [mins1, maxs1, sum1, size1, minnum1, maxnum1, failed1] = x1;\n        const auto& [mins2, maxs2, sum2, size2, minnum2, maxnum2, failed2] = x2;\n        Arr<i64, 2> nmins{INF<i64>, INF<i64>};\n        Arr<i64, 2> nmaxs{-INF<i64>, -INF<i64>};\n        nmins[0] = std::min(mins1[0], mins2[0]);\n        nmins[1] = secondMin(mins1[0], mins1[1], mins2[0], mins2[1]);\n        nmaxs[0] = std::max(maxs1[0], maxs2[0]);\n        nmaxs[1] = secondMax(maxs1[0], maxs1[1], maxs2[0], maxs2[1]);\n        const int nminnum = minnum1 * (nmins[0] == mins1[0]) + minnum2 * (nmins[0] == mins2[0]);\n        const int nmaxnum = maxnum1 * (nmaxs[0] == maxs1[0]) + maxnum2 * (nmaxs[0] == maxs2[0]);\n        return T{nmins, nmaxs, sum1 + sum2, size1 + size2, nminnum, nmaxnum, failed1 or failed2};\n    }\n};\nstruct OpMonoid\n{\n    struct F  // Clamp[low,hi] \\circ Add[add]\n    {\n        i64 low, hi;\n        i64 add;\n        friend bool operator==(const F& f1, const F& f2)\n        {\n            return f1.low == f2.low and f1.hi == f2.hi and f1.add == f2.add;\n        }\n    };\n    static F id() { return F{-INF<i64>, INF<i64>, 0_i64}; }\n    F operator()(const F& f1, const F& f2) const\n    {\n        const auto& [low1, hi1, add1] = f1;\n        const auto& [low2, hi2, add2] = f2;\n        return F{std::max(low1, low2 + add1), clamp(hi2 + add1, low1, hi1), add1 + add2};\n    }\n};\nstruct Act\n{\n    using T = MergeMonoid::T;\n    using F = OpMonoid::F;\n    T operator()(const F& f, const T& x) const\n    {\n        const auto& [mins, maxs, sum, size, minnum, maxnum, failed] = x;\n        const auto& [low, hi, add] = f;\n        const i64 nmin = clamp(mins[0] + add, low, hi);\n        const i64 nmax = clamp(maxs[0] + add, low, hi);\n        if (nmin == nmax) {  // \u5168\u90e8\u540c\u3058\u5024\u306b\u306a\u308b\n            return T{{nmin, INF<i64>}, {nmax, -INF<i64>}, nmin * size, size, size, size, false};\n        }\n        if (minnum + maxnum == size) {  // mins[1] <= x <= maxs[1] \u306e\u5143\u304c\u5b58\u5728\u3057\u306a\u3044\n            return T{{nmin, nmax},\n                     {nmax, nmin},\n                     nmin * minnum + nmax * maxnum,\n                     size,\n                     minnum,\n                     maxnum,\n                     false};\n        }\n        if (low <= mins[1] + add\n            and maxs[1] + add <= hi) {  // mins[1] <= x <= maxs[1] \u306e\u5143\u304cClamp\u306e\u5f71\u97ff\u3092\u53d7\u3051\u306a\u3044\n            Arr<i64, 2> nmins = {nmin, mins[1] + add};\n            Arr<i64, 2> nmaxs = {nmax, maxs[1] + add};\n            const i64 midsum = (sum - mins[0] * minnum - maxs[0] * maxnum);\n            const int midnum = size - minnum - maxnum;\n            const i64 nsum = nmin * minnum + nmax * maxnum + (midsum + add * midnum);\n            return T{nmins, nmaxs, nsum, size, minnum, maxnum, false};\n        }\n        auto nx = x;\n        nx.failed = true;\n        return nx;\n    }\n    bool failed(const T& x) const { return x.size > 1 and x.failed; }\n};\n\nint main()\n{\n    const auto [N, Q] = in.tup<int, int>();\n    const auto as = in.vec<i64>(N);\n    SegBeats<MergeMonoid, OpMonoid, Act> seg(N);\n    for (int i : rep(N)) {\n        seg.set(i, {{as[i], INF<i64>}, {as[i], -INF<i64>}, as[i], 1, 1, 1, false});\n    }\n    LOOP (Q) {\n        const auto type = in.val<int>();\n        if (type == 0) {\n            const auto [l, r, b] = in.tup<int, int, i64>();\n            seg.act(l, r, {-INF<i64>, b, 0_i64});\n        } else if (type == 1) {\n            const auto [l, r, b] = in.tup<int, int, i64>();\n            seg.act(l, r, {b, INF<i64>, 0_i64});\n        } else if (type == 2) {\n            const auto [l, r, b] = in.tup<int, int, i64>();\n            seg.act(l, r, {-INF<i64>, INF<i64>, b});\n        } else {\n            const auto [l, r] = in.tup<int, int>();\n            out.ln(seg.fold(l, r).sum);\n        }\n    }\n    return 0;\n}\n",
    "result": "AC"
}