{
    "algorithm/linear_floor_sum.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/sum_of_floor_of_linear\n#include \"algorithm/linear_floor_sum.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\nint main()\n{\n    const auto T = in.val<int>();\n    LOOP (T) {\n        const auto [N, M, A, B] = in.tup<i64, i64, i64, i64>();\n        out.ln(linearFloorSum(N, A, B, M));\n    }\n    return 0;\n}\n",
        "result": "AC"
    },
    "algorithm/mo.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/static_range_inversions_query\n#include \"data_structure/fenwick_tree/fenwick_tree.hpp\"\n#include \"algorithm/mo.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\n#include \"utility/zipper.hpp\"\nint main()\n{\n    const auto [N, Q] = in.tup<int, int>();\n    auto as = in.vec<u32>(N);\n    Zipper<u32> zipper(as);\n    for (auto& a : as) { a = zipper.zip(a); }\n    const int L = zipper.size();\n    FenwickTree<int> bit(Vec<int>(L, 0));\n    u64 inv = 0;\n    auto left = [&](int x, int) {  // (x,y)->(x-1,y)\n        const int a = as[x - 1];\n        inv += bit.sum(0, a);\n        bit.add(a, 1);\n    };\n    auto right = [&](int x, int) {  // (x,y)->(x+1,y)\n        const int a = as[x];\n        inv -= bit.sum(0, a);\n        bit.add(a, -1);\n    };\n    auto up = [&](int, int y) {  // (x,y)->(x,y-1)\n        const int a = as[y - 1];\n        inv -= bit.sum(a + 1, L);\n        bit.add(a, -1);\n    };\n    auto down = [&](int, int y) {  // (x,y)->(x,y+1)\n        const int a = as[y];\n        inv += bit.sum(a + 1, L);\n        bit.add(a, 1);\n    };\n\n    Vec<int> ls(Q), rs(Q);\n    for (int q : rep(Q)) { std::tie(ls[q], rs[q]) = in.tup<int, int>(); }\n    Mo mo(ls, rs);\n    Vec<u64> ans(Q);\n    mo.solve(right, left, down, up, [&](int q) { ans[q] = inv; });\n    out.ln(ans);\n\n    return 0;\n}\n",
        "result": "AC"
    },
    "common/bit_op.test.cpp": {
        "code": "// verification-helper: UNITTEST\n#include \"common/bit_op.hpp\"\n\nvoid popCountTest()\n{\n    assert(popCount(0x0123456789ABCDEF) == 32);\n    assert(popCount(0x0) == 0);\n}\n\nvoid topBitTest()\n{\n    assert(topBit(0x0123456789ABCDEF) == 56);\n    assert(topBit(0x8000000000000000) == 63);\n    assert(topBit(0xFFFFFFFFFFFFFFFF) == 63);\n    assert(topBit(0x1) == 0);\n    assert(topBit(0x0) == -1);\n}\n\nvoid lowBitTest()\n{\n    assert(lowBit(0x0123456789ABCDEF) == 0);\n    assert(lowBit(0x8000000000000000) == 63);\n    assert(lowBit(0x0) == 64);\n}\n\nvoid bitWidthTest()\n{\n    assert(bitWidth(0x0123456789ABCDEF) == 57);\n    assert(bitWidth(0x8000000000000000) == 64);\n    assert(bitWidth(0x0) == 0);\n}\n\nvoid bitCeilTest()\n{\n    assert(bitCeil(0x0123456789ABCDEF) == 0x0200000000000000);\n    assert(bitCeil(0x8000000000000000) == 0x8000000000000000);\n    assert(bitCeil(0x0) == 1);\n}\n\nvoid bitFloorTest()\n{\n    assert(bitFloor(0x0123456789ABCDEF) == 0x0100000000000000);\n    assert(bitFloor(0x8000000000000000) == 0x8000000000000000);\n    assert(bitFloor(0x8000000000000001) == 0x8000000000000000);\n    assert(bitFloor(0x1) == 1);\n    assert(bitFloor(0x0) == 0);\n}\n\nvoid hasSingleBitTest()\n{\n    assert(hasSingleBit(0x0123456789ABCDEF) == false);\n    assert(hasSingleBit(0x8000000000000000) == true);\n    assert(hasSingleBit(0x8000000000000001) == false);\n    assert(hasSingleBit(0x1) == true);\n    assert(hasSingleBit(0x0) == false);\n}\n\nvoid isBitOnOffTest()\n{\n    const i64 v = 0x3333333333333333;\n    for (int i = 0; i < 64; i++) {\n        assert(isBitOn(v, i) == ((i % 4) < 2));\n        assert(isBitOff(v, i) == not((i % 4) < 2));\n    }\n}\n\nint main()\n{\n    popCountTest();\n    topBitTest();\n    lowBitTest();\n    bitWidthTest();\n    bitCeilTest();\n    bitFloorTest();\n    hasSingleBitTest();\n    isBitOnOffTest();\n    return 0;\n}\n",
        "result": "AC"
    },
    "common/chminmax.test.cpp": {
        "code": "// verification-helper: UNITTEST\n#include \"common/chminmax.hpp\"\n\nstruct C\n{\n    C() = default;\n    C(int v_) : v{v_} {}\n    friend bool operator<(const C& c1, const C& c2) { return c1.v < c2.v; }\n    friend bool operator>(const C& c1, const C& c2) { return c1.v > c2.v; }\n    int v = 0;\n};\n\nvoid chminTest()\n{\n    int v = 10;\n    for (int i = 100; i >= 0; i--) {\n        assert(chmin(v, i) == (i < 10));\n        assert(v == std::min(i, 10));\n    }\n\n    C cls{10};\n    for (int i = 100; i >= 0; i--) {\n        assert(chmin(cls, C{i}) == (i < 10));\n        assert(cls.v == std::min(i, 10));\n    }\n}\n\nvoid chmaxTest()\n{\n    int v = 10;\n    for (int i = 0; i < 100; i++) {\n        assert(chmax(v, i) == (i > 10));\n        assert(v == std::max(i, 10));\n    }\n\n    C cls{10};\n    for (int i = 0; i < 100; i++) {\n        assert(chmax(cls, C{i}) == (i > 10));\n        assert(cls.v == std::max(i, 10));\n    }\n}\n\nint main()\n{\n    chminTest();\n    chmaxTest();\n    return 0;\n}\n",
        "result": "AC"
    },
    "common/container_op.fillAll.test.cpp": {
        "code": "// verification-helper: UNITTEST\n#include \"common/container_op.hpp\"\n\nvoid PrimitiveArr1DTest()\n{\n    int vs[5] = {1, 3, 5, 2, 4};\n    fillAll(vs, 1);\n    for (int i = 0; i < 5; i++) { assert(vs[i] == 1); }\n}\nvoid PrimitiveArr2DTest()\n{\n    int vs[2][5] = {{1, 3, 5, 2, 4}, {3, 1, 4, 1, 5}};\n    fillAll(vs, 1);\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 5; j++) { assert(vs[i][j] == 1); }\n    }\n}\nvoid Vec1DTest()\n{\n    Vec<int> vs{1, 3, 5, 2, 4};\n    fillAll(vs, 1);\n    for (int i = 0; i < 5; i++) { assert(vs[i] == 1); }\n}\nvoid Vec2DTest()\n{\n    Vec<Vec<int>> vss{{1, 3, 5, 2, 4}, {3, 1, 4, 1, 5}};\n    fillAll(vss, 1);\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 5; j++) { assert(vss[i][j] == 1); }\n    }\n}\nvoid Arr1DTest()\n{\n    Arr<int, 5> vs{1, 3, 5, 2, 4};\n    fillAll(vs, 1);\n    for (int i = 0; i < 5; i++) { assert(vs[i] == 1); }\n}\nvoid Arr2DTest()\n{\n    Arr<Arr<int, 5>, 2> vss{{{1, 3, 5, 2, 4}, {3, 1, 4, 1, 5}}};\n    fillAll(vss, 1);\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 5; j++) { assert(vss[i][j] == 1); }\n    }\n}\nvoid Deq1DTest()\n{\n    Deq<int> vs{1, 3, 5, 2, 4};\n    fillAll(vs, 1);\n    for (int i = 0; i < 5; i++) { assert(vs[i] == 1); }\n}\nvoid Deq2DTest()\n{\n    Deq<Deq<int>> vss{{1, 3, 5, 2, 4}, {3, 1, 4, 1, 5}};\n    fillAll(vss, 1);\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 5; j++) { assert(vss[i][j] == 1); }\n    }\n}\nvoid CastTest()\n{\n    Vec<i64> vs{1, 3, 5, 2, 4};\n    fillAll(vs, (short)1);\n    for (int i = 0; i < 5; i++) { assert(vs[i] == 1); }\n}\n\nint main()\n{\n    PrimitiveArr1DTest();\n    PrimitiveArr2DTest();\n    Vec1DTest();\n    Vec2DTest();\n    Arr1DTest();\n    Arr2DTest();\n    Deq1DTest();\n    Deq2DTest();\n    CastTest();\n    return 0;\n}\n",
        "result": "AC"
    },
    "common/container_op.reverseAll.test.cpp": {
        "code": "// verification-helper: UNITTEST\n#include \"common/container_op.hpp\"\n\nvoid PrimitiveArrTest()\n{\n    int vs[5] = {1, 3, 5, 2, 4};\n    reverseAll(vs);\n    int rvs[5] = {4, 2, 5, 3, 1};\n    for (int i = 0; i < 5; i++) { assert(vs[i] == rvs[i]); }\n}\nvoid VecTest()\n{\n    Vec<int> vs = {1, 3, 5, 2, 4};\n    reverseAll(vs);\n    Vec<int> rvs = {4, 2, 5, 3, 1};\n    for (int i = 0; i < 5; i++) { assert(vs[i] == rvs[i]); }\n}\nvoid ArrTest()\n{\n    Arr<int, 5> vs = {1, 3, 5, 2, 4};\n    reverseAll(vs);\n    Arr<int, 5> rvs = {4, 2, 5, 3, 1};\n    for (int i = 0; i < 5; i++) { assert(vs[i] == rvs[i]); }\n}\nvoid DeqTest()\n{\n    Deq<int> vs = {1, 3, 5, 2, 4};\n    reverseAll(vs);\n    Deq<int> rvs = {4, 2, 5, 3, 1};\n    for (int i = 0; i < 5; i++) { assert(vs[i] == rvs[i]); }\n}\n\nint main()\n{\n    PrimitiveArrTest();\n    VecTest();\n    ArrTest();\n    DeqTest();\n    return 0;\n}\n",
        "result": "AC"
    },
    "common/container_op.sortAll.test.cpp": {
        "code": "// verification-helper: UNITTEST\n#include \"common/container_op.hpp\"\n\nvoid PrimitiveArrTest()\n{\n    int vs[5] = {1, 3, 5, 2, 4};\n    sortAll(vs);\n    assert(std::is_sorted(std::begin(vs), std::end(vs)));\n}\nvoid VecTest()\n{\n    Vec<int> vs{1, 3, 5, 2, 4};\n    sortAll(vs);\n    assert(std::is_sorted(std::begin(vs), std::end(vs)));\n}\nvoid ArrTest()\n{\n    Arr<int, 5> vs{1, 3, 5, 2, 4};\n    sortAll(vs);\n    assert(std::is_sorted(std::begin(vs), std::end(vs)));\n}\nvoid DeqTest()\n{\n    Deq<int> vs{1, 3, 5, 2, 4};\n    sortAll(vs);\n    assert(std::is_sorted(std::begin(vs), std::end(vs)));\n}\n\nint main()\n{\n    PrimitiveArrTest();\n    VecTest();\n    ArrTest();\n    DeqTest();\n    return 0;\n}\n",
        "result": "AC"
    },
    "common/container_op.sumAll.test.cpp": {
        "code": "// verification-helper: UNITTEST\n#include \"common/container_op.hpp\"\n\nvoid Primitive1DArrTest()\n{\n    int vs[6] = {1, 3, 1, 2, 3, 2};\n    const int sum1 = sumAll<int>(vs);\n    int sum2 = 0;\n    for (int i = 0; i < 6; i++) { sum2 += vs[i]; }\n    assert(sum1 == sum2);\n}\nvoid Primitive2DArrTest()\n{\n    int vss[2][6] = {{1, 3, 1, 2, 3, 2}, {3, 1, 4, 1, 5, 9}};\n    const int sum1 = sumAll<int>(vss);\n    int sum2 = 0;\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 6; j++) { sum2 += vss[i][j]; }\n    }\n    assert(sum1 == sum2);\n}\nvoid Vec1DArrTest()\n{\n    Vec<int> vs{1, 3, 1, 2, 3, 2};\n    const int sum1 = sumAll<int>(vs);\n    int sum2 = 0;\n    for (int i = 0; i < 6; i++) { sum2 += vs[i]; }\n    assert(sum1 == sum2);\n}\nvoid Vec2DArrTest()\n{\n    Vec<Vec<int>> vss{{1, 3, 1, 2, 3, 2}, {3, 1, 4, 1, 5, 9}};\n    const int sum1 = sumAll<int>(vss);\n    int sum2 = 0;\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 6; j++) { sum2 += vss[i][j]; }\n    }\n    assert(sum1 == sum2);\n}\nvoid Arr1DArrTest()\n{\n    Arr<int, 6> vs{1, 3, 1, 2, 3, 2};\n    const int sum1 = sumAll<int>(vs);\n    int sum2 = 0;\n    for (int i = 0; i < 6; i++) { sum2 += vs[i]; }\n    assert(sum1 == sum2);\n}\nvoid Arr2DArrTest()\n{\n    Arr<Arr<int, 6>, 2> vss{{{1, 3, 1, 2, 3, 2}, {3, 1, 4, 1, 5, 9}}};\n    const int sum1 = sumAll<int>(vss);\n    int sum2 = 0;\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 6; j++) { sum2 += vss[i][j]; }\n    }\n    assert(sum1 == sum2);\n}\nvoid Deq1DArrTest()\n{\n    Deq<int> vs{1, 3, 1, 2, 3, 2};\n    const int sum1 = sumAll<int>(vs);\n    int sum2 = 0;\n    for (int i = 0; i < 6; i++) { sum2 += vs[i]; }\n    assert(sum1 == sum2);\n}\nvoid Deq2DArrTest()\n{\n    Deq<Deq<int>> vss{{1, 3, 1, 2, 3, 2}, {3, 1, 4, 1, 5, 9}};\n    const int sum1 = sumAll<int>(vss);\n    int sum2 = 0;\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 6; j++) { sum2 += vss[i][j]; }\n    }\n    assert(sum1 == sum2);\n}\nvoid CastTest()\n{\n    Vec<int> vs{1 << 30, 1 << 30, 1 << 30, 1 << 30, 1 << 30, 1 << 30};\n    const int sum1 = sumAll<int>(vs);\n    const i64 sum2 = sumAll<i64>(vs);\n    i64 sum3 = 0;\n    for (int i = 0; i < 6; i++) { sum3 += vs[i]; }\n    assert(sum1 != sum3);\n    assert(sum2 == sum3);\n}\nint main()\n{\n    Primitive1DArrTest();\n    Primitive2DArrTest();\n    Vec1DArrTest();\n    Vec2DArrTest();\n    Arr1DArrTest();\n    Arr2DArrTest();\n    Deq1DArrTest();\n    Deq2DArrTest();\n    CastTest();\n    return 0;\n}\n",
        "result": "AC"
    },
    "common/container_op.test.cpp": {
        "code": "// verification-helper: UNITTEST\n#include \"common/container_op.hpp\"\n\nvoid minIndTest()\n{\n    std::vector<int> vs{2, 1, 1, 3, 3, 2};\n    assert(minInd(vs) == 1);\n}\n\nvoid maxIndTest()\n{\n    std::vector<int> vs{2, 1, 1, 3, 3, 2};\n    assert(maxInd(vs) == 3);\n}\n\nvoid lbIndTest()\n{\n    std::vector<int> vs{1, 1, 3, 3, 3, 5, 5};\n    assert(lbInd(vs, 0) == 0);\n    assert(lbInd(vs, 1) == 0);\n    assert(lbInd(vs, 5) == 5);\n    assert(lbInd(vs, 6) == 7);\n}\n\nvoid ubIndTest()\n{\n    std::vector<int> vs{1, 1, 3, 3, 3, 5, 5};\n    assert(ubInd(vs, 0) == 0);\n    assert(ubInd(vs, 1) == 2);\n    assert(ubInd(vs, 5) == 7);\n    assert(ubInd(vs, 6) == 7);\n}\n\nvoid genVecTest()\n{\n    int x = 1;\n    auto gen = [&]() {\n        const int y = x;\n        x *= 2;\n        return y;\n    };\n    auto vs = genVec<int>(5, gen);\n    assert(vs == std::vector<int>({1, 2, 4, 8, 16}));\n}\n\nvoid iotaVecTest()\n{\n    auto vs = iotaVec(5, 2);\n    assert(vs == std::vector<int>({2, 3, 4, 5, 6}));\n}\n\nint main()\n{\n    minIndTest();\n    maxIndTest();\n    lbIndTest();\n    ubIndTest();\n    genVecTest();\n    iotaVecTest();\n    return 0;\n}\n",
        "result": "AC"
    },
    "common/int_div.test.cpp": {
        "code": "// verification-helper: UNITTEST\n#include \"../../src/common/int_div.hpp\"\nvoid fdivTest()\n{\n    auto f = [&](auto x, auto y) {\n        auto a = (decltype(x))std::floor((f80)x / y);\n        assert(floorDiv(x, y) == a);\n    };\n    for (int x = -100; x <= 100; x++) {\n        for (int y = -100; y <= 100; y++) {\n            if (y == 0) { continue; }\n            f(x, y);\n        }\n    }\n}\n\nvoid cdivTest()\n{\n    auto c = [&](auto x, auto y) {\n        auto a = (decltype(x))std::ceil((f80)x / y);\n        assert(ceilDiv(x, y) == a);\n    };\n    for (int x = -100; x <= 100; x++) {\n        for (int y = -100; y <= 100; y++) {\n            if (y == 0) { continue; }\n            c(x, y);\n        }\n    }\n}\n\nint main()\n{\n    fdivTest();\n    cdivTest();\n    return 0;\n}\n",
        "result": "AC"
    },
    "common/irange.test.cpp": {
        "code": "// verification-helper: UNITTEST\n#include \"common/irange.hpp\"\n\nvoid repTest()\n{\n    std::vector<int> is;\n    for (int i : rep(5)) { is.push_back(i); }\n    assert(is == std::vector<int>({0, 1, 2, 3, 4}));\n}\n\nvoid perTest()\n{\n    std::vector<int> is;\n    for (int i : per(5)) { is.push_back(i); }\n    assert(is == std::vector<int>({4, 3, 2, 1, 0}));\n}\n\nvoid irangeTest1()\n{\n    std::vector<int> is1;\n    for (int i : irange(2, 5)) { is1.push_back(i); }\n    assert(is1 == std::vector<int>({2, 3, 4}));\n\n    std::vector<int> is2;\n    for (int i : irange(2, 10, 3)) { is2.push_back(i); }\n    assert(is2 == std::vector<int>({2, 5, 8}));\n\n    std::vector<int> is3;\n    for (int i : irange(2, 11, 3)) { is3.push_back(i); }\n    assert(is3 == std::vector<int>({2, 5, 8}));\n\n    std::vector<int> is4;\n    for (int i : irange(2, 1, 3)) { is4.push_back(i); }\n    assert(is4.empty());\n}\n\nvoid irangeTest2()\n{\n    std::vector<int> is2;\n    for (int i : irange(10, 2, -3)) { is2.push_back(i); }\n    assert(is2 == std::vector<int>({10, 7, 4}));\n\n    std::vector<int> is3;\n    for (int i : irange(11, 2, -3)) { is3.push_back(i); }\n    assert(is3 == std::vector<int>({11, 8, 5}));\n\n    std::vector<int> is4;\n    for (int i : irange(1, 2, -3)) { is4.push_back(i); }\n    assert(is4.empty());\n}\nvoid irangeTest3()\n{\n    long long min = 10000000000LL;\n    long long sup = 10000000000LL + 3;\n    std::vector<i64> is;\n    for (i64 i : irange(min, sup)) { is.push_back(i); }\n    assert(is == std::vector<long long>({min, min + 1, min + 2}));\n}\n\nvoid loopTest()\n{\n    int cnt = 0;\n    LOOP (100) { cnt++; };\n    assert(cnt == 100);\n}\n\nint main()\n{\n    repTest();\n    perTest();\n    irangeTest1();\n    irangeTest2();\n    irangeTest3();\n    loopTest();\n    return 0;\n}\n",
        "result": "AC"
    },
    "common/powerInt.test.cpp": {
        "code": "// verification-helper: PROBLEM http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=NTL_1_B\n#include \"common/power.hpp\"\n\nconstexpr i64 mod = 1000000007;\nstruct mint\n{\n    mint() = default;\n    mint(i64 v_) : v{v_} {}\n    friend mint operator+(const mint& m1, const mint& m2) { return mint(m1.v + m2.v); }\n    friend mint operator*(const mint& m1, const mint& m2) { return mint(m1.v * m2.v % mod); }\n    friend mint& operator+=(mint& m1, const mint& m2)\n    {\n        m1 = m1 + m2;\n        return m1;\n    }\n    friend mint& operator*=(mint& m1, const mint& m2)\n    {\n        m1 = m1 * m2;\n        return m1;\n    }\n    i64 v = 0;\n};\n\nint main()\n{\n    i64 m, n;\n    std::cin >> m >> n;\n    mint M{m};\n    const mint ans = powerInt(M, n);\n    std::cout << ans.v << \"\\n\";\n    return 0;\n}\n",
        "result": "AC"
    },
    "common/powerMonoid.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=ALDS1_10_A\n#include \"common/power.hpp\"\n\nstruct M\n{\n    friend M operator*(const M& m1, const M& m2)\n    {\n        M m;\n        m.vss[0][0] = m.vss[0][1] = m.vss[1][0] = m.vss[1][1] = 0;\n        for (int i = 0; i < 2; i++) {\n            for (int j = 0; j < 2; j++) {\n                for (int k = 0; k < 2; k++) { m.vss[i][j] += m1.vss[i][k] * m2.vss[k][j]; }\n            }\n        }\n        return m;\n    }\n    friend M& operator*=(M& m1, const M& m2) { return m1 = (m1 * m2); }\n    static M I()\n    {\n        M m;\n        m.vss[0][0] = m.vss[1][1] = 1;\n        m.vss[0][1] = m.vss[1][0] = 0;\n        return m;\n    }\n    Arr<Arr<i64, 2>, 2> vss;\n};\n\nint main()\n{\n    int N;\n    std::cin >> N;\n    M mat;\n    mat.vss[0][0] = mat.vss[0][1] = mat.vss[1][0] = 1;\n    mat.vss[1][1] = 0;\n    const M ans = powerMonoid(mat, N, M::I());\n    std::cout << ans.vss[1][0] + ans.vss[1][1] << \"\\n\";\n    return 0;\n}\n",
        "result": "AC"
    },
    "convex_hull_trick/li_chao_tree.line.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/line_add_get_min\n#include \"convex_hull_trick/li_chao_tree.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\nint main()\n{\n    const auto [N, Q] = in.tup<int, int>();\n    auto cht = LiChaoTree<i64>(-TEN<i64>(9), TEN<i64>(9));\n    LOOP (N) {\n        const auto [a, b] = in.tup<i64, i64>();\n        cht.addLine({a, b});\n    }\n    LOOP (Q) {\n        const auto t = in.val<int>();\n        if (t == 0) {\n            const auto [a, b] = in.tup<i64, i64>();\n            cht.addLine({a, b});\n        } else {\n            const auto p = in.val<i64>();\n            const auto [ok, l] = cht.minLine(p);\n            out.ln(l.first * p + l.second);\n        }\n    }\n}\n",
        "result": "AC"
    },
    "convex_hull_trick/li_chao_tree.segment.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/segment_add_get_min\n#include \"convex_hull_trick/li_chao_tree.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\nint main()\n{\n    const auto [N, Q] = in.tup<int, int>();\n    auto cht = LiChaoTree<i64>(-TEN<i64>(9), TEN<i64>(9));\n    LOOP (N) {\n        const auto [l, r, a, b] = in.tup<i64, i64, i64, i64>();\n        cht.addSeg({a, b}, l, r);\n    }\n    LOOP (Q) {\n        const auto t = in.val<int>();\n        if (t == 0) {\n            const auto [l, r, a, b] = in.tup<i64, i64, i64, i64>();\n            cht.addSeg({a, b}, l, r);\n        } else {\n            const auto p = in.val<i64>();\n            const auto [ok, l] = cht.minLine(p);\n            if (ok) {\n                out.ln(l.first * p + l.second);\n            } else {\n                out.ln(\"INFINITY\");\n            }\n        }\n    }\n}\n",
        "result": "AC"
    },
    "convex_hull_trick/monotone_cht.test.cpp": {
        "code": "// verification-helper: PROBLEM https://yukicoder.me/problems/no/409\n#include \"convex_hull_trick/monotone_cht.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\nint main()\n{\n    const auto [N, A, B, W] = in.tup<int, i64, i64, i64>();\n    auto ds = Vec<i64>{0};\n    concat(ds, in.vec<i64>(N));\n    ds.push_back(0);\n    Vec<i64> dp(N + 2, INF<i64>);\n    dp[0] = 0;\n    MonotoneCHT<i64> cht;\n    for (int i : rep(N + 2)) {\n        if (i != 0) {\n            const auto [a, b] = cht.minLine(i);\n            dp[i] = ds[i] * 2 - A * (i - 1) * 2 + B * i * i + (a * i + b);\n        }\n        cht.addLine(-B * (2 * i + 1), dp[i] + A * 2 * i + B * (i + 1) * i);\n    }\n    out.ln(W + dp.back() / 2);\n\n    return 0;\n}\n",
        "result": "AC"
    },
    "data_structure/fenwick_tree/fenwick.max_right.test.cpp": {
        "code": "// verification-helper: UNITTEST\n#include \"data_structure/fenwick_tree/fenwick_tree.hpp\"\n\nvoid Test()\n{\n    FenwickTree<int> fenwick({1, 2, 3, 4, 5, 6, 7});\n    assert(fenwick.maxRight([](int s) { return s <= 0; }) == 0);\n    assert(fenwick.maxRight([](int s) { return s <= 1; }) == 1);\n    assert(fenwick.maxRight([](int s) { return s <= 3; }) == 2);\n    assert(fenwick.maxRight([](int s) { return s <= 21; }) == 6);\n    assert(fenwick.maxRight([](int s) { return s <= 30; }) == 7);\n    std::cerr << fenwick << std::endl;\n}\n\nint main()\n{\n    Test();\n    return 0;\n}\n",
        "result": "AC"
    },
    "data_structure/fenwick_tree/fenwick.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/point_add_range_sum\n#include \"data_structure/fenwick_tree/fenwick_tree.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\nint main()\n{\n    const auto [N, Q] = in.tup<int, int>();\n    const auto as = in.vec<u64>(N);\n    auto fenwick = FenwickTree(as);\n    LOOP (Q) {\n        const auto t = in.val<int>();\n        if (t == 0) {\n            const auto [p, x] = in.tup<int, u64>();\n            fenwick.add(p, x);\n        } else {\n            const auto [l, r] = in.tup<int, int>();\n            out.ln(fenwick.sum(l, r));\n        }\n    }\n    return 0;\n}\n",
        "result": "AC"
    },
    "data_structure/segment_tree/dual_segtree.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/range_affine_point_get\n#include \"data_structure/segment_tree/dual_segtree.hpp\"\n#include \"utility/modint.hpp\"\n#include \"utility/scanner.hpp\"\n#include \"utility/printer.hpp\"\n\nusing mint = modint_998244353;\nstruct OpMonoid\n{\n    using F = Pair<mint, mint>;\n    static F id() { return {1, 0}; }\n    F operator()(const F& f1, const F& f2) const\n    {\n        const auto& [a1, b1] = f1;\n        const auto& [a2, b2] = f2;\n        return {a1 * a2, a1 * b2 + b1};\n    }\n};\n\nint main()\n{\n    const auto [N, Q] = in.tup<int, int>();\n    const auto as = in.vec<mint>(N);\n    DualSegTree<OpMonoid> seg(N);\n    LOOP (Q) {\n        const auto t = in.val<int>();\n        if (t == 0) {\n            const auto [l, r, b, c] = in.tup<int, int, mint, mint>();\n            seg.act(l, r, {b, c});\n        } else {\n            const auto i = in.val<int>();\n            const auto& [a, b] = seg.get(i);\n            out.ln(a * as[i] + b);\n        }\n    }\n    return 0;\n}\n",
        "result": "AC"
    },
    "data_structure/segment_tree/lazy_segtree.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/range_affine_range_sum\n#include \"data_structure/segment_tree/lazy_segtree.hpp\"\n#include \"utility/modint.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\n\nint main()\n{\n    using mint = modint_998244353;\n    using Func = Pair<mint, mint>;\n    struct MergeMonoid\n    {\n        using T = Pair<mint, int>;\n        static T e() { return {0, 0}; }\n        T operator()(const T& x1, const T& x2) const\n        {\n            return {x1.first + x2.first, x1.second + x2.second};\n        }\n    };\n    struct OpMonoid\n    {\n        using F = Func;\n        static F id() { return F{1, 0}; }\n        F operator()(const F& f1, const F& f2) const\n        {\n            return F{f1.first * f2.first, f1.first * f2.second + f1.second};\n        }\n    };\n    struct Act\n    {\n        using T = MergeMonoid::T;\n        using F = OpMonoid::F;\n        T operator()(const F& f, const T& x) const\n        {\n            return {f.first * x.first + f.second * x.second, x.second};\n        }\n    };\n\n    const auto [N, Q] = in.tup<int, int>();\n    Vec<Pair<mint, int>> as(N, {0, 1});\n    for (int i : rep(N)) { as[i].first = in.val<mint>(); }\n    auto seg = LazySeg<MergeMonoid, OpMonoid, Act>(as);\n    LOOP (Q) {\n        const auto t = in.val<int>();\n        if (t == 0) {\n            const auto [l, r, b, c] = in.tup<int, int, mint, mint>();\n            seg.act(l, r, Func{b, c});\n        } else {\n            const auto [l, r] = in.tup<int, int>();\n            out.ln(seg.fold(l, r).first.val());\n        }\n    }\n    return 0;\n}\n",
        "result": "AC"
    },
    "data_structure/segment_tree/segtree.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/point_set_range_composite\n#include \"data_structure/segment_tree/segtree.hpp\"\n#include \"utility/modint.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\nint main()\n{\n    using mint = modint_998244353;\n    using Func = Pair<mint, mint>;\n    struct Monoid\n    {\n        using T = Func;\n        static const T e() { return T{1, 0}; }\n        T operator()(const T& f2, const T& f1) const\n        {\n            return T{f1.first * f2.first, f1.first * f2.second + f1.second};\n        }\n    };\n\n    const auto [N, Q] = in.tup<int, int>();\n    Vec<Func> fs(N);\n    for (int i : rep(N)) { std::tie(fs[i].first, fs[i].second) = in.tup<mint, mint>(); }\n    auto seg = SegTree<Monoid>(fs);\n    LOOP (Q) {\n        const auto t = in.val<int>();\n        if (t == 0) {\n            const auto [p, c, d] = in.tup<int, mint, mint>();\n            seg.set(p, Func{c, d});\n        } else {\n            const auto [l, r, x] = in.tup<int, int, mint>();\n            const auto [a, b] = seg.fold(l, r);\n            out.ln((a * x + b).val());\n        }\n    }\n    return 0;\n}\n",
        "result": "AC"
    },
    "data_structure/segment_tree/segtree_beats.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/range_chmin_chmax_add_range_sum\n#include \"data_structure/segment_tree/segtree_beats.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\n\nauto secondMin(i64 a1, i64 a2, i64 b1, i64 b2) -> i64\n{\n    return a1 == b1 ? std::min(a2, b2) : a2 < b1 ? a2 : b2 < a1 ? b2 : std::max(a1, b1);\n}\nauto secondMax(i64 a1, i64 a2, i64 b1, i64 b2) -> i64\n{\n    return a1 == b1 ? std::max(a2, b2) : a2 > b1 ? a2 : b2 > a1 ? b2 : std::min(a1, b1);\n}\nauto clamp(i64 x, i64 low, i64 hi) -> i64 { return std::min(hi, std::max(low, x)); }\n\nstruct MergeMonoid\n{\n    struct T\n    {\n        Arr<i64, 2> mins;  // 1st min, 2nd min\n        Arr<i64, 2> maxs;  // 1st max, 2nd max\n        i64 sum;\n        int size;\n        int minnum, maxnum;\n        bool failed;\n    };\n    static T e() { return {{INF<i64>, INF<i64>}, {-INF<i64>, -INF<i64>}, 0_i64, 0, 0, 0, false}; }\n    T operator()(const T& x1, const T& x2) const\n    {\n        const auto& [mins1, maxs1, sum1, size1, minnum1, maxnum1, failed1] = x1;\n        const auto& [mins2, maxs2, sum2, size2, minnum2, maxnum2, failed2] = x2;\n        Arr<i64, 2> nmins{INF<i64>, INF<i64>};\n        Arr<i64, 2> nmaxs{-INF<i64>, -INF<i64>};\n        nmins[0] = std::min(mins1[0], mins2[0]);\n        nmins[1] = secondMin(mins1[0], mins1[1], mins2[0], mins2[1]);\n        nmaxs[0] = std::max(maxs1[0], maxs2[0]);\n        nmaxs[1] = secondMax(maxs1[0], maxs1[1], maxs2[0], maxs2[1]);\n        const int nminnum = minnum1 * (nmins[0] == mins1[0]) + minnum2 * (nmins[0] == mins2[0]);\n        const int nmaxnum = maxnum1 * (nmaxs[0] == maxs1[0]) + maxnum2 * (nmaxs[0] == maxs2[0]);\n        return T{nmins, nmaxs, sum1 + sum2, size1 + size2, nminnum, nmaxnum, failed1 or failed2};\n    }\n};\nstruct OpMonoid\n{\n    struct F  // Clamp[low,hi] \\circ Add[add]\n    {\n        i64 low, hi;\n        i64 add;\n        friend bool operator==(const F& f1, const F& f2)\n        {\n            return f1.low == f2.low and f1.hi == f2.hi and f1.add == f2.add;\n        }\n    };\n    static F id() { return F{-INF<i64>, INF<i64>, 0_i64}; }\n    F operator()(const F& f1, const F& f2) const\n    {\n        const auto& [low1, hi1, add1] = f1;\n        const auto& [low2, hi2, add2] = f2;\n        return F{std::max(low1, low2 + add1), clamp(hi2 + add1, low1, hi1), add1 + add2};\n    }\n};\nstruct Act\n{\n    using T = MergeMonoid::T;\n    using F = OpMonoid::F;\n    T operator()(const F& f, const T& x) const\n    {\n        const auto& [mins, maxs, sum, size, minnum, maxnum, failed] = x;\n        const auto& [low, hi, add] = f;\n        const i64 nmin = clamp(mins[0] + add, low, hi);\n        const i64 nmax = clamp(maxs[0] + add, low, hi);\n        if (nmin == nmax) {  // \u5168\u90e8\u540c\u3058\u5024\u306b\u306a\u308b\n            return T{{nmin, INF<i64>}, {nmax, -INF<i64>}, nmin * size, size, size, size, false};\n        }\n        if (minnum + maxnum == size) {  // mins[1] <= x <= maxs[1] \u306e\u5143\u304c\u5b58\u5728\u3057\u306a\u3044\n            return T{{nmin, nmax},\n                     {nmax, nmin},\n                     nmin * minnum + nmax * maxnum,\n                     size,\n                     minnum,\n                     maxnum,\n                     false};\n        }\n        if (low <= mins[1] + add\n            and maxs[1] + add <= hi) {  // mins[1] <= x <= maxs[1] \u306e\u5143\u304cClamp\u306e\u5f71\u97ff\u3092\u53d7\u3051\u306a\u3044\n            Arr<i64, 2> nmins = {nmin, mins[1] + add};\n            Arr<i64, 2> nmaxs = {nmax, maxs[1] + add};\n            const i64 midsum = (sum - mins[0] * minnum - maxs[0] * maxnum);\n            const int midnum = size - minnum - maxnum;\n            const i64 nsum = nmin * minnum + nmax * maxnum + (midsum + add * midnum);\n            return T{nmins, nmaxs, nsum, size, minnum, maxnum, false};\n        }\n        auto nx = x;\n        nx.failed = true;\n        return nx;\n    }\n    bool failed(const T& x) const { return x.size > 1 and x.failed; }\n};\n\nint main()\n{\n    const auto [N, Q] = in.tup<int, int>();\n    const auto as = in.vec<i64>(N);\n    SegBeats<MergeMonoid, OpMonoid, Act> seg(N);\n    for (int i : rep(N)) {\n        seg.set(i, {{as[i], INF<i64>}, {as[i], -INF<i64>}, as[i], 1, 1, 1, false});\n    }\n    LOOP (Q) {\n        const auto type = in.val<int>();\n        if (type == 0) {\n            const auto [l, r, b] = in.tup<int, int, i64>();\n            seg.act(l, r, {-INF<i64>, b, 0_i64});\n        } else if (type == 1) {\n            const auto [l, r, b] = in.tup<int, int, i64>();\n            seg.act(l, r, {b, INF<i64>, 0_i64});\n        } else if (type == 2) {\n            const auto [l, r, b] = in.tup<int, int, i64>();\n            seg.act(l, r, {-INF<i64>, INF<i64>, b});\n        } else {\n            const auto [l, r] = in.tup<int, int>();\n            out.ln(seg.fold(l, r).sum);\n        }\n    }\n    return 0;\n}\n",
        "result": "AC"
    },
    "data_structure/sliding_window_aggregation/deque.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/queue_operate_all_composite\n#include \"data_structure/sliding_window_aggregation/deque.hpp\"\n#include \"utility/modint.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\nint main()\n{\n    using mint = modint_998244353;\n    using Func = std::pair<mint, mint>;\n    const auto Q = in.val<int>();\n    struct SemiGroup\n    {\n        using T = Func;\n        // f2 \\circ f1 \u306a\u306e\u3067\u6ce8\u610f\n        T operator()(const T& f1, const T& f2) const\n        {\n            return T{f2.first * f1.first, f2.first * f1.second + f2.second};\n        }\n    };\n\n    auto deque = SwagDeque<SemiGroup>{};\n    LOOP (Q) {\n        const auto t = in.val<int>();\n        if (t == 0) {\n            const auto [a, b] = in.tup<mint, mint>();\n            deque.pushBack(Func{a, b});\n        } else if (t == 1) {\n            deque.popFront();\n        } else {\n            const auto x = in.val<mint>();\n            if (deque.empty()) {\n                out.ln(x.val());\n            } else {\n                const auto [a, b] = deque.foldAll();\n                out.ln((a * x + b).val());\n            }\n        }\n    }\n    return 0;\n}\n",
        "result": "AC"
    },
    "data_structure/sliding_window_aggregation/queue.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/queue_operate_all_composite\n#include \"data_structure/sliding_window_aggregation/queue.hpp\"\n#include \"utility/modint.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\nint main()\n{\n    using mint = modint_998244353;\n    using Func = std::pair<mint, mint>;\n    const auto Q = in.val<int>();\n    struct SemiGroup\n    {\n        using T = Func;\n        // f2 \\circ f1 \u306a\u306e\u3067\u6ce8\u610f\n        T operator()(const T& f1, const T& f2) const\n        {\n            return T{f2.first * f1.first, f2.first * f1.second + f2.second};\n        }\n    };\n\n    auto queue = SwagQueue<SemiGroup>{};\n    LOOP (Q) {\n        const auto t = in.val<int>();\n        if (t == 0) {\n            const auto [a, b] = in.tup<mint, mint>();\n            queue.pushBack(Func{a, b});\n        } else if (t == 1) {\n            queue.popFront();\n        } else {\n            const auto x = in.val<mint>();\n            if (queue.empty()) {\n                out.ln(x.val());\n            } else {\n                const auto [a, b] = queue.foldAll();\n                out.ln((a * x + b).val());\n            }\n        }\n    }\n    return 0;\n}\n",
        "result": "AC"
    },
    "data_structure/sparse_table/disjoint_sparse_table.rmq.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/staticrmq\n#include \"data_structure/sparse_table/disjoint_sparse_table.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\nint main()\n{\n    const auto [N, Q] = in.tup<int, int>();\n    const auto as = in.vec<u64>(N);\n    struct SemiGroup\n    {\n        using T = u64;\n        T operator()(T x1, T x2) const { return std::min(x1, x2); }\n    };\n    const auto rmq = DisjointSparseTable<SemiGroup>(as);\n    LOOP (Q) {\n        const auto [l, r] = in.tup<int, int>();\n        out.ln(rmq.fold(l, r));\n    }\n}\n",
        "result": "AC"
    },
    "data_structure/sparse_table/static_rmq.rMq.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/staticrmq\n#include \"data_structure/sparse_table/static_rmq.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\nstruct Max\n{\n    using T = i32;\n    bool operator()(const T& x1, const T& x2) const { return x1 > x2; }\n};\nint main()\n{\n    const auto [N, Q] = in.tup<int, int>();\n    auto as = in.vec<i32>(N);\n    for (auto& a : as) { a = -a; }\n    const auto rMq = StaticRMQ<Max>(as);\n    LOOP (Q) {\n        const auto [l, r] = in.tup<int, int>();\n        out.ln(-rMq.fold(l, r));\n    }\n}\n",
        "result": "AC"
    },
    "data_structure/sparse_table/static_rmq.rmq.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/staticrmq\n#include \"data_structure/sparse_table/static_rmq.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\nint main()\n{\n    const auto [N, Q] = in.tup<int, int>();\n    const auto as = in.vec<u32>(N);\n    struct Ord\n    {\n        using T = u32;\n        bool operator()(const T& x1, const T& x2) const { return x1 < x2; }\n    };\n    const auto rmq = StaticRMQ<Ord>(as);\n    LOOP (Q) {\n        const auto [l, r] = in.tup<int, int>();\n        out.ln(rmq.fold(l, r));\n    }\n}\n",
        "result": "AC"
    },
    "data_structure/union_find_tree/union_find_tree.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/unionfind\n#include \"data_structure/union_find_tree/union_find_tree.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\nint main()\n{\n    const auto [N, Q] = in.tup<int, int>();\n    auto uf = UnionFindTree(N);\n    LOOP (Q) {\n        const auto [t, u, v] = in.tup<int, int, int>();\n        if (t == 0) {\n            uf.unite(u, v);\n        } else {\n            out.ln(uf.same(u, v));\n        }\n    }\n}\n",
        "result": "AC"
    },
    "data_structure/wavelet/wavelet_matrix.quantile.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/range_kth_smallest\n#include \"data_structure/wavelet/wavelet_matrix.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\nint main()\n{\n    const auto [N, Q] = in.tup<int, int>();\n    const auto as = in.vec<u32>(N);\n    auto wm = WaveletMatrix(as);\n    LOOP (Q) {\n        const auto [l, r, k] = in.tup<int, int, int>();\n        out.ln(wm.quantile(l, r, k));\n    }\n    return 0;\n}\n",
        "result": "AC"
    },
    "data_structure/wavelet/wavelet_matrix.rangefreq.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/range_kth_smallest\n#include \"data_structure/wavelet/wavelet_matrix.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\n#include \"utility/bin_search.hpp\"\nint main()\n{\n    const auto [N, Q] = in.tup<int, int>();\n    const auto as = in.vec<i64>(N);\n    auto wm = WaveletMatrix(as);\n    LOOP (Q) {\n        const auto [l, r, k] = in.tup<int, int, int>();\n        const i64 ans = binSearch(TEN<i64>(9) + 1, 0_i64, [&, l = l, r = r, k = k](u32 x) {\n            return wm.rangeFreq(l, r, 0, x) <= k;\n        });\n        out.ln(ans);\n    }\n    return 0;\n}\n",
        "result": "AC"
    },
    "formal_dirichlet_series/gcd_convolution.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/gcd_convolution\n#include \"formal_dirichlet_series/gcd_convolution.hpp\"\n#include \"utility/modint.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\nint main()\n{\n    using mint = modint_998244353;\n    const auto N = in.val<int>();\n    auto as = Vec<mint>{0};\n    concat(as, in.vec<mint>(N));\n    auto bs = Vec<mint>{0};\n    concat(bs, in.vec<mint>(N));\n    const auto cs = gcdConvolute(as, bs);\n    Vec<int> Cs(N);\n    for (int i : rep(N)) { Cs[i] = cs[i + 1].val(); }\n    out.ln(Cs);\n    return 0;\n}\n",
        "result": "AC"
    },
    "formal_dirichlet_series/lcm_convolution.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/lcm_convolution\n#include \"formal_dirichlet_series/lcm_convolution.hpp\"\n#include \"utility/modint.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\nint main()\n{\n    using mint = modint_998244353;\n    const auto N = in.val<int>();\n    auto as = Vec<mint>{0};\n    concat(as, in.vec<mint>(N));\n    auto bs = Vec<mint>{0};\n    concat(bs, in.vec<mint>(N));\n    const auto cs = lcmConvolute(as, bs);\n    Vec<int> Cs(N);\n    for (int i : rep(N)) { Cs[i] = cs[i + 1].val(); }\n    out.ln(Cs);\n    return 0;\n}\n",
        "result": "AC"
    },
    "formal_power_series/berlekamp_massey.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/find_linear_recurrence\n#include \"formal_power_series/berlekamp_massey.hpp\"\n#include \"utility/modint.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\nint main()\n{\n    using mint = modint_998244353;\n    const auto N = in.val<int>();\n    Vec<mint> as(N);\n    for (auto& a : as) { a = in.val<int>(); }\n    const auto cs = berlekampMassey(as);\n    const int d = cs.size();\n    Vec<int> ans(d - 1);\n    for (int i : irange(1, d)) { ans[i - 1] = (-cs[i]).val(); }\n    out.ln(d - 1);\n    out.ln(ans);\n    return 0;\n}\n",
        "result": "AC"
    },
    "formal_power_series/bostan_mori.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/kth_term_of_linearly_recurrent_sequence\n#include \"formal_power_series/bostan_mori.hpp\"\n#include \"utility/modint.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\nint main()\n{\n    using mint = modint_998244353;\n    const auto [D, K] = in.tup<int, i64>();\n    const auto as = in.vec<mint>(D);\n    auto cs = Vec<mint>{1};\n    concat(cs, in.vec<mint>(D));\n    FormalPowerSeries<mint> f{as};\n    FormalPowerSeries<mint> g{cs};\n    for (int i : irange(1, D + 1)) { g[i] *= (-1); }\n    f = f.mult(g, D);\n    const auto ans = bostanMori(f, g, K);\n    out.ln(ans.val());\n    return 0;\n}\n",
        "result": "AC"
    },
    "formal_power_series/formal_power_series.convolution.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/convolution_mod\n#include \"formal_power_series/formal_power_series.hpp\"\n#include \"utility/modint.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\nint main()\n{\n    using mint = modint_998244353;\n    const auto [N, M] = in.tup<int, int>();\n    FormalPowerSeries<mint> as = in.vec<mint>(N);\n    FormalPowerSeries<mint> bs = in.vec<mint>(M);\n    auto cs = as * bs;\n    Vec<mint> ans(N + M - 1);\n    for (int i : rep(N + M - 1)) { ans[i] = cs.at(i); }\n    out.ln(ans);\n    return 0;\n}\n",
        "result": "AC"
    },
    "formal_power_series/formal_power_series.convolution1000000007.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/convolution_mod_1000000007\n#include \"formal_power_series/formal_power_series.hpp\"\n#include \"utility/modint.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\nint main()\n{\n    using mint = modint_1000000007;\n    const auto [N, M] = in.tup<int, int>();\n    FormalPowerSeries<mint> as = in.vec<mint>(N);\n    FormalPowerSeries<mint> bs = in.vec<mint>(M);\n    const auto cs = as * bs;\n    Vec<mint> ans(N + M - 1);\n    for (int i : rep(N + M - 1)) { ans[i] = cs.at(i); }\n    out.ln(ans);\n    return 0;\n}\n",
        "result": "AC"
    },
    "formal_power_series/formal_power_series.exp.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/exp_of_formal_power_series\n#include \"formal_power_series/formal_power_series.hpp\"\n#include \"utility/modint.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\nint main()\n{\n    using mint = modint_998244353;\n    const auto N = in.val<int>();\n    FormalPowerSeries<mint> as = in.vec<mint>(N);\n    const auto bs = as.exp(N);\n    std::vector<mint> ans(N);\n    for (int i : rep(N)) { ans[i] = bs.at(i); }\n    out.ln(ans);\n    return 0;\n}\n",
        "result": "AC"
    },
    "formal_power_series/formal_power_series.inv.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/inv_of_formal_power_series\n#include \"formal_power_series/formal_power_series.hpp\"\n#include \"utility/modint.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\nint main()\n{\n    using mint = modint_998244353;\n    const auto N = in.val<int>();\n    FormalPowerSeries<mint> as = in.vec<mint>(N);\n    const auto bs = as.inv(N);\n    Vec<mint> ans(N);\n    for (int i : rep(N)) { ans[i] = bs.at(i); }\n    out.ln(ans);\n    return 0;\n}\n",
        "result": "AC"
    },
    "formal_power_series/formal_power_series.log.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/log_of_formal_power_series\n#include \"formal_power_series/formal_power_series.hpp\"\n#include \"utility/modint.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\nint main()\n{\n    using mint = modint_998244353;\n    const auto N = in.val<int>();\n    FormalPowerSeries<mint> as = in.vec<mint>(N);\n    const auto bs = as.log(N);\n    Vec<mint> ans(N);\n    for (int i : rep(N)) { ans[i] = bs.at(i); }\n    out.ln(ans);\n    return 0;\n}\n",
        "result": "AC"
    },
    "formal_power_series/formal_power_series.pow.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/pow_of_formal_power_series\n#include \"formal_power_series/formal_power_series.hpp\"\n#include \"utility/modint.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\n\nint main()\n{\n    using mint = modint_998244353;\n    const auto [N, M] = in.tup<int, i64>();\n    FormalPowerSeries<mint> as = in.vec<mint>(N);\n    const auto bs = as.pow(M, N);\n    Vec<mint> ans(N);\n    for (int i : rep(N)) { ans[i] = bs.at(i); }\n    out.ln(ans);\n    return 0;\n}\n",
        "result": "AC"
    },
    "graph/bellman_ford.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_1_B\n#include \"graph/bellman_ford.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\n\nint main()\n{\n    const auto [V, E, r] = in.tup<int, int, int>();\n    Graph<int> g(V);\n    LOOP (E) {\n        const auto [u, v, c] = in.tup<int, int, int>();\n        g.addEdge(u, v, c);\n    }\n    const auto ds = bellmanFord(g, r);\n    for (int i : rep(V)) {\n        if (ds[i] <= -INF<int>) { return out.ln(\"NEGATIVE CYCLE\"); }\n    }\n    for (int i : rep(V)) {\n        if (ds[i] >= INF<int>) {\n            out.ln(\"INF\");\n        } else {\n            out.ln(ds[i]);\n        }\n    }\n    return 0;\n}\n",
        "result": "AC"
    },
    "graph/dijkstra.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/shortest_path\n#include \"graph/dijkstra.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\nint main()\n{\n    const auto [N, M, S, T] = in.tup<int, int, int, int>();\n    Graph<i64> g(N), rg(N);\n    LOOP (M) {\n        const auto [u, v, c] = in.tup<int, int, i64>();\n        g.addEdge(u, v, c), rg.addEdge(v, u, c);\n    }\n    const auto ds = dijkstra(g, S);\n    if (ds[T] >= INF<i64>) { return out.ln(-1); }\n    using pii = Pair<int, int>;\n    Vec<bool> used(N, false);\n    Vec<pii> ans;\n    int p = T;\n    while (p != S) {\n        used[p] = true;\n        for (UNUSED const auto& [_, pp, cost] : rg[p]) {\n            if (not used[pp] and ds[pp] + cost == ds[p]) {\n                ans.push_back({pp, p});\n                p = pp;\n                break;\n            }\n        }\n    }\n    reverseAll(ans);\n    out.ln(ds[T], ans.size());\n    for (const auto& [u, v] : ans) { out.ln(u, v); }\n    return 0;\n}\n",
        "result": "AC"
    },
    "graph/floyd_warshall.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_1_C\n#include \"graph/floyd_warshall.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\n\nint main()\n{\n    const auto [V, E] = in.tup<int, int>();\n    Graph<i64> g(V);\n    LOOP (E) {\n        const auto [u, v, c] = in.tup<int, int, i64>();\n        g.addEdge(u, v, c);\n    }\n    const auto dss = floydWarshall(g);\n    for (int i : rep(V)) {\n        if (dss[i][i] < 0) { return out.ln(\"NEGATIVE CYCLE\"); }\n    }\n    for (int i : rep(V)) {\n        for (int j : rep(V)) {\n            out(j == 0 ? \"\" : \" \");\n            if (dss[i][j] >= INF<i64>) {\n                out(\"INF\");\n            } else {\n                out(dss[i][j]);\n            }\n        }\n        out(\"\\n\");\n    }\n\n    return 0;\n}\n",
        "result": "AC"
    },
    "graph/strongly_connected_components.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/scc\n#include \"graph/strongly_connected_components.hpp\"\n#include \"graph/topological_sort.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\nint main()\n{\n    const auto [N, M] = in.tup<int, int>();\n    Graph g(N);\n    LOOP (M) {\n        const auto [a, b] = in.tup<int, int>();\n        g.addEdge(a, b);\n    }\n    const auto scc = StronglyConnectedComponents(g);\n    const int C = scc.cnum();\n    Graph dag(C);\n    for (int u : rep(N)) {\n        const int uc = scc[u];\n        for (const int v : g[u]) {\n            const int vc = scc[v];\n            if (uc == vc) { continue; }\n            dag.addEdge(uc, vc);\n        }\n    }\n    Vec<Vec<int>> cvs(C);\n    for (int i : rep(N)) { cvs[scc[i]].push_back(i); }\n    const auto [flag, cs] = topologicalSort(dag);\n    assert(flag);\n    out.ln(C);\n    for (int c : cs) { out.ln(cvs[c].size(), cvs[c]); }\n    return 0;\n}\n",
        "result": "AC"
    },
    "graph/tree/centroid_decomposition.test.cpp": {
        "code": "// verification-helper: PROBLEM https://yukicoder.me/problems/no/1002\n#include \"graph/tree/centroid_decomposition.hpp\"\n#include \"utility/nd_vec.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\n\nint main()\n{\n    const auto [N, K] = in.tup<int, int>();\n    Graph<int> g(N);\n    LOOP (N - 1) {\n        const auto [u, v, c] = in.tup<int, int, int>(1, 1, 1);\n        g.addEdge(u, v, c, true);\n    }\n    CentroidDecomposition centros(g);\n    const int cr = centros.center();\n    const auto cg = centros.centers();\n    Vec<bool> used(N, false);\n    using P = Pair<int, int>;\n    i64 ans = 0;\n\n    auto f = [&](const Map<int, i64>& dp1,\n                 const Map<P, i64>& dp2,\n                 const Map<int, i64>& dp3,\n                 const i64 one) -> i64 {\n        i64 ans = 0;\n        i64 dbl = 0;\n        for (const auto& [k, n] : dp1) {\n            ans += n * (dp3.at(k) - n);  // 1\u8272x2\u8272\n            dbl += n * (one - n);        // 1\u8272x1\u8272\n        }\n        for (UNUSED const auto& [_, n] : dp2) {\n            ans += n * (n - 1) / 2;  // 2\u8272x2\u8272\n        }\n        return ans + dbl / 2;\n    };\n\n    Fix([&](auto dfs, int c) -> void {\n        used[c] = true;\n        Map<int, i64> dp1;\n        Map<P, i64> dp2;\n        Map<int, i64> dp3;\n        int one = 0;\n        for (const auto& e : g[c]) {\n            if (used[e.to]) { continue; }\n            Map<int, i64> subdp1;\n            Map<P, i64> subdp2;\n            Map<int, i64> subdp3;\n            i64 sone = 0;\n            Fix([&](auto dfs, int u, int p, const P& ks) -> void {\n                if (ks.second == INF<int>) {\n                    dp1[ks.first]++;\n                    dp3[ks.first]++;\n                    subdp1[ks.first]++;\n                    subdp3[ks.first]++;\n                    sone++;\n                    one++;\n                } else {\n                    ans++;\n                    dp2[ks]++;\n                    dp3[ks.first]++;\n                    dp3[ks.second]++;\n                    subdp2[ks]++;\n                    subdp3[ks.first]++;\n                    subdp3[ks.second]++;\n                }\n                for (const auto& e : g[u]) {\n                    const int v = e.to;\n                    if (v == p or used[v]) { continue; }\n                    const int k = e.cost;\n                    auto nks = ks;\n                    if (ks.first == k or ks.second == k) {\n                        ;\n                    } else if (ks.second == INF<int>) {\n                        nks.second = k;\n                    } else {\n                        continue;\n                    }\n                    if (nks.first > nks.second) { std::swap(nks.first, nks.second); }\n                    dfs(v, u, nks);\n                }\n            })(e.to, c, P{e.cost, INF<int>});\n            ans -= f(subdp1, subdp2, subdp3, sone);\n        }\n        ans += f(dp1, dp2, dp3, one);\n        for (int nc : cg[c]) { dfs(nc); }\n    })(cr);\n    out.ln(ans);\n    return 0;\n}\n",
        "result": "AC"
    },
    "graph/tree/diameter.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/tree_diameter\n#include \"graph/tree/diameter.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\nint main()\n{\n    const auto N = in.val<int>();\n    Graph<i64> g(N);\n    LOOP (N - 1) {\n        const auto [u, v, c] = in.tup<int, int, i64>();\n        g.addEdge(u, v, c, true);\n    }\n    auto es = diameter(g);\n    i64 X = 0;\n    Vec<int> vs{es[0].from};\n    for (const auto& e : es) {\n        X += e.cost;\n        vs.push_back(e.to);\n    }\n    out.ln(X, vs.size());\n    out.ln(vs);\n    return 0;\n}\n",
        "result": "AC"
    },
    "graph/tree/heavy_light_decomposition.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/vertex_set_path_composite\n#include \"graph/tree/heavy_light_decomposition.hpp\"\n#include \"data_structure/segment_tree/segtree.hpp\"\n#include \"utility/modint.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\nint main()\n{\n    using mint = modint_998244353;\n    const auto [N, Q] = in.tup<int, int>();\n    Graph g(N);\n    using Func = Pair<mint, mint>;\n    struct Monoid\n    {\n        using T = Func;\n        static const T e() { return T{1, 0}; }\n        T operator()(const T& f2, const T& f1) const\n        {\n            return T{f1.first * f2.first, f1.first * f2.second + f1.second};\n        }\n    };\n    struct RMonoid\n    {\n        using T = Func;\n        static const T e() { return T{1, 0}; }\n        T operator()(const T& f1, const T& f2) const\n        {\n            return T{f1.first * f2.first, f1.first * f2.second + f1.second};\n        }\n    };\n\n    Vec<mint> as(N), bs(N);\n    for (int i : rep(N)) { std::tie(as[i], bs[i]) = in.tup<mint, mint>(); }\n    LOOP (N - 1) {\n        const auto [u, v] = in.tup<int, int>();\n        g.addEdge(u, v, true);\n    }\n    const HeavyLightDecomposition hld{g};\n    Vec<Func> vs(N);\n    for (int i : rep(N)) { vs[hld.pos(i)] = Func{as[i], bs[i]}; }\n    auto seg = SegTree<Monoid>(vs);\n    auto rseg = SegTree<RMonoid>(vs);\n    LOOP (Q) {\n        const auto t = in.val<int>();\n        if (t == 0) {\n            const auto [p, c, d] = in.tup<int, mint, mint>();\n            seg.set(hld.pos(p), {c, d}), rseg.set(hld.pos(p), {c, d});\n        } else {\n            const auto [u, v, x] = in.tup<int, int, mint>();\n            const auto ps = hld.path(u, v);\n            Func f{1, 0};\n            for (const auto& [a, b] : ps) {\n                f = Monoid{}(f, a <= b ? seg.fold(a, b + 1) : rseg.fold(b, a + 1));\n            }\n            out.ln((f.first * x + f.second).val());\n        }\n    }\n    return 0;\n}\n",
        "result": "AC"
    },
    "graph/tree/least_common_ancestor.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/lca\n#include \"graph/tree/least_common_ancestor.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\nint main()\n{\n    const auto [N, Q] = in.tup<int, int>();\n    Graph g(N);\n    for (int i : irange(1, N)) {\n        const int p = in.val<int>();\n        g.addEdge(p, i, true);\n    }\n    const auto lca = LowestCommonAncestor(g, 0);\n    LOOP (Q) {\n        const auto [u, v] = in.tup<int, int>();\n        const int l = lca(u, v);\n        out.ln(l);\n    }\n    return 0;\n}\n",
        "result": "AC"
    },
    "graph/tree/level_ancestor.lca.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/lca\n#include \"graph/tree/level_ancestor.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\n\nint main()\n{\n    const auto [N, Q] = in.tup<int, int>();\n    Graph g(N);\n    for (int i : irange(1, N, 1)) {\n        const int p = in.val<int>();\n        g.addEdge(p, i, true);\n    }\n    LevelAncestor la(g);\n    LOOP (Q) {\n        const auto [u, v] = in.tup<int, int>();\n        out.ln(la.lca(u, v));\n    }\n\n    return 0;\n}\n",
        "result": "AC"
    },
    "graph/tree/level_ancestor.ut.test.cpp": {
        "code": "// verification-helper: UNITTEST\n#include \"graph/tree/level_ancestor.hpp\"\n\nvoid Test()\n{\n    Graph g(10);\n    g.addEdge(1, 2, true);\n    g.addEdge(2, 0, true);\n    g.addEdge(2, 3, true);\n    g.addEdge(1, 9, true);\n    g.addEdge(1, 4, true);\n    g.addEdge(4, 5, true);\n    g.addEdge(4, 8, true);\n    g.addEdge(5, 6, true);\n    g.addEdge(5, 7, true);\n    LevelAncestor la(g, 1);\n    assert(la(0, 0) == 0);\n    assert(la(0, 1) == 2);\n    assert(la(0, 2) == 1);\n\n    assert(la(1, 0) == 1);\n\n    assert(la(2, 0) == 2);\n    assert(la(2, 1) == 1);\n\n    assert(la(3, 0) == 3);\n    assert(la(3, 1) == 2);\n    assert(la(3, 2) == 1);\n\n    assert(la(4, 0) == 4);\n    assert(la(4, 1) == 1);\n\n    assert(la(5, 0) == 5);\n    assert(la(5, 1) == 4);\n    assert(la(5, 2) == 1);\n\n    assert(la(6, 0) == 6);\n    assert(la(6, 1) == 5);\n    assert(la(6, 2) == 4);\n    assert(la(6, 3) == 1);\n\n    assert(la(7, 0) == 7);\n    assert(la(7, 1) == 5);\n    assert(la(7, 2) == 4);\n    assert(la(7, 3) == 1);\n\n    assert(la(8, 0) == 8);\n    assert(la(8, 1) == 4);\n    assert(la(8, 2) == 1);\n\n    assert(la(9, 0) == 9);\n    assert(la(9, 1) == 1);\n}\nint main()\n{\n    Test();\n    return 0;\n}\n",
        "result": "AC"
    },
    "linear_algebra/bit_bases.test.cpp": {
        "code": "// verification-helper: PROBLEM https://yukicoder.me/problems/no/184\n#include \"linear_algebra/bit_bases.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\n\nint main()\n{\n    const auto N = in.val<int>();\n    BitBases<64> bases;\n    LOOP (N) {\n        const auto a = in.val<u64>();\n        bases.add(a);\n    }\n    out.ln(1_u64 << bases.rank());\n    return 0;\n}\n",
        "result": "AC"
    },
    "linear_algebra/bit_bases.ut.test.cpp": {
        "code": "// verification-helper: UNITTEST\n#include \"linear_algebra/bit_bases.hpp\"\n\nvoid Test()\n{\n    constexpr int D = 3;\n    Vec<BSet<D>> vs{3, 1, 2, 5};\n    BitBases<D> bases;\n    for (const auto& v : vs) { bases.add(v); }\n    assert(bases.rank() == 3);  //011,101,001\n    const auto origBases = bases.origBases();\n    assert(origBases == (Vec<BSet<D>>{3, 1, 5}));\n    assert(bases.decomp(2).first);\n    assert(bases.decomp(2).second == 3);\n}\n\nint main()\n{\n    Test();\n    return 0;\n}\n",
        "result": "AC"
    },
    "linear_algebra/dynamic_matrix.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/matrix_product\n#include \"linear_algebra/dynamic_matrix.hpp\"\n#include \"utility/nd_vec.hpp\"\n#include \"utility/modint.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\n\nint main()\n{\n    using mint = modint_998244353;\n    const auto [N, M, K] = in.tup<int, int, int>();\n    DynamicMatrix<mint> A(N, M);\n    for (int i : rep(N)) {\n        for (int j : rep(M)) { A[i][j] = in.val<mint>(); }\n    }\n    DynamicMatrix<mint> B(M, K);\n    for (int i : rep(M)) {\n        for (int j : rep(K)) { B[i][j] = in.val<mint>(); }\n    }\n    const auto C = A * B;\n    auto ans = ndVec<mint>({N, K});\n    for (int i : rep(N)) {\n        for (int k : rep(K)) { ans[i][k] = C[i][k]; }\n    }\n    out.ln(ans);\n    return 0;\n}\n",
        "result": "AC"
    },
    "linear_algebra/int_bases.test.cpp": {
        "code": "// verification-helper: PROBLEM https://yukicoder.me/problems/no/184\n#include \"linear_algebra/int_bases.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\n\nint main()\n{\n    const auto N = in.val<int>();\n    IntBases bases;\n    LOOP (N) {\n        const auto a = in.val<u64>();\n        bases.add(a);\n    }\n    out.ln(1_u64 << bases.rank());\n    return 0;\n}\n",
        "result": "AC"
    },
    "linear_algebra/int_bases.ut.test.cpp": {
        "code": "// verification-helper: UNITTEST\n#include \"linear_algebra/int_bases.hpp\"\n\nvoid Test()\n{\n    Vec<u64> vs{3, 1, 2, 5};\n    IntBases bases;\n    for (u64 v : vs) { bases.add(v); }\n    assert(bases.rank() == 3);  //011,101,001\n    const auto origBases = bases.origBases();\n    assert(origBases == (Vec<u64>{3, 1, 5}));\n    assert(bases.decomp(2).first);\n    assert(bases.decomp(2).second == 3);\n}\n\nint main()\n{\n    Test();\n    return 0;\n}\n",
        "result": "AC"
    },
    "linear_algebra/static_matrix.test.cpp": {
        "code": "// verification-helper: PROBLEM https://yukicoder.me/problems/no/541\n#include \"linear_algebra/static_matrix.hpp\"\n#include \"utility/modint.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\n\nint main()\n{\n    using mint = modint_1000000007;\n    const auto N = in.val<i64>();\n    StaticMatrix<mint, 10, 10> mat{{{1, 0, 1, 1, 1, 1, 1, 1, 1, 0},\n                                    {0, 1, 0, 1, 0, 1, 0, 0, 0, 1},\n                                    {0, 0, 1, 0, 0, 0, 0, 0, 1, 0},\n                                    {0, 0, 1, 1, 0, 0, 1, 0, 1, 1},\n                                    {0, 0, 0, 0, 1, 0, 1, 1, 1, 1},\n                                    {0, 0, 1, 0, 0, 1, 0, 1, 1, 1},\n                                    {0, 0, 0, 1, 1, 0, 1, 1, 1, 1},\n                                    {0, 0, 0, 0, 1, 1, 1, 1, 1, 1},\n                                    {0, 1, 0, 1, 1, 1, 1, 1, 1, 1},\n                                    {0, 0, 0, 0, 0, 0, 0, 0, 0, 1}}};\n    out.ln(mat.pow(N + 1)[0][9]);\n    return 0;\n}\n",
        "result": "AC"
    },
    "number/discrete_log.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/discrete_logarithm_mod\n#include \"number/discrete_log.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\n#include \"utility/modint.hpp\"\n\nint main()\n{\n    const auto T = in.val<int>();\n    using mint = modint_dynamic<0>;\n    LOOP (T) {\n        const auto [x, y, M] = in.tup<u32, u32, u32>();\n        mint::setMod(M);\n        const mint X = x, Y = y;\n        const i64 K = discreteLog(X, Y);\n        out.ln(K);\n    }\n    return 0;\n}\n",
        "result": "AC"
    },
    "number/divisors.test.cpp": {
        "code": "// verification-helper: PROBLEM https://yukicoder.me/problems/no/888\n#include \"number/divisors.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\n\nint main()\n{\n    const auto N = in.val<i64>();\n    const auto ds = divisors(N);\n    out.ln(sumAll<i64>(ds));\n    return 0;\n}\n",
        "result": "AC"
    },
    "number/mod_nthroot.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/kth_root_mod\n#include \"number/mod_nthroot.hpp\"\n#include \"utility/modint.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\nusing mint = modint_dynamic<0>;\nint main()\n{\n    const int T = in.val<int>();\n    LOOP (T) {\n        const auto [K, Y, P] = in.tup<uint, uint, uint>();\n        if (P == 2) {\n            out.ln(Y == 1 ? 1 : K == 0 ? -1 : 0);\n            continue;\n        }\n        mint::setMod(P);\n        const mint ans = modNthRoot<mint>(mint{Y}, K);\n        if (ans.pow(K) == Y) {\n            out.ln(ans.val());\n        } else {\n            out.ln(-1);\n        }\n    }\n    return 0;\n}\n",
        "result": "AC"
    },
    "number/mod_nthroot.yuki.test.cpp": {
        "code": "// verification-helper: IGNORE\n// verification-helper: PROBLEM https://yukicoder.me/problems/no/981\n#include \"number/mod_nthroot.hpp\"\n#include \"utility/modint64.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\nusing mint = modint64_dynamic<0>;\nint main()\n{\n    const int T = in.val<int>();\n    LOOP (T) {\n        const auto [P, K, Y] = in.tup<u64, u64, u64>();\n        if (P == 2) {\n            out.ln(Y == 1 ? 1 : K == 0 ? -1 : 0);\n            continue;\n        }\n        mint::setMod(P);\n        const mint ans = modNthRoot(mint(Y), K);\n        if (ans.pow(K) == Y) {\n            out.ln(ans.val());\n        } else {\n            out.ln(-1);\n        }\n    }\n    return 0;\n}\n",
        "result": "SKIPPED"
    },
    "number/mod_sqrt.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/sqrt_mod\n#include \"number/mod_sqrt.hpp\"\n#include \"utility/modint.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\nusing mint = modint_dynamic<0>;\nint main()\n{\n    const int T = in.val<int>();\n    LOOP (T) {\n        const auto [Y, P] = in.tup<uint, uint>();\n        mint::setMod(P);\n        const mint ans = modsqrt(mint{Y});\n        if (ans * ans == Y) {\n            out.ln(ans.val());\n        } else {\n            out.ln(-1);\n        }\n    }\n    return 0;\n}\n",
        "result": "AC"
    },
    "number/multiplicative_prefix_sum.totient.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/sum_of_totient_function\n#include \"number/multiplicative_prefix_sum.hpp\"\n#include \"utility/modint.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\nint main()\n{\n    using mint = modint_998244353;\n    const auto N = in.val<u64>();\n    if (N <= 2) { return out.ln(N); }\n    auto f = [&](const u64 v, const u64 p, u32) { return v / p * (p - 1); };\n    const auto ms = MultiplicativePrefixSum<mint, decltype(f)>(N, f, {mint(-1), mint(1), mint(0)});\n    out.ln(ms.get(N).val());\n    return 0;\n}\n",
        "result": "AC"
    },
    "number/prime_factors.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/factorize\n#include \"number/prime_factors.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\nint main()\n{\n    const auto Q = in.val<int>();\n    LOOP (Q) {\n        const auto a = in.val<u64>();\n        const auto fs = primeFactors(a);\n        std::vector<u64> ans;\n        for (const auto& [p, e] : fs) {\n            LOOP (e) { ans.push_back(p); }\n        }\n        out.ln(ans.size(), ans);\n    }\n    return 0;\n}\n",
        "result": "AC"
    },
    "number/prime_powersum.primecount.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/counting_primes\n#include \"number/prime_power_sum.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\nint main()\n{\n    const auto N = in.val<u64>();\n    if (N <= 2) { return out.ln(N == 2 ? 1 : 0); }\n    const auto powsum = PrimePowerSum<u64>(N);\n    out.ln(powsum.get(0, N));\n    return 0;\n}\n",
        "result": "AC"
    },
    "numerical/convolution.ut.test.cpp": {
        "code": "// verification-helper: UNITTEST\n#include \"numerical/convolution.hpp\"\n#include \"utility/rng.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\nint main()\n{\n    const auto AN = rng.val<int>(1, 1000);\n    const auto BN = rng.val<int>(1, 1000);\n    const auto as = rng.vec<i64>(AN, -100000000, 100000000);\n    const auto bs = rng.vec<i64>(BN, -100000000, 100000000);\n\n    const auto cs = convolute_i64(as, bs);\n    Vec<i64> ds(AN + BN - 1, 0);\n    for (int i : rep(AN)) {\n        for (int j : rep(BN)) { ds[i + j] += (i64)as[i] * bs[j]; }\n    }\n    assert(cs == ds);\n    return 0;\n}\n",
        "result": "AC"
    },
    "set_power_series/and_convolution.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/bitwise_and_convolution\n#include \"set_power_series/and_convolution.hpp\"\n#include \"utility/modint.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\nint main()\n{\n    using mint = modint_998244353;\n    const auto n = in.val<int>();\n    const int N = 1 << n;\n    const auto as = in.vec<mint>(N);\n    const auto bs = in.vec<mint>(N);\n    const auto cs = andConvolute(as, bs);\n    Vec<int> ans(cs.size());\n    for (int i : rep(N)) { ans[i] = cs[i].val(); }\n    out.ln(ans);\n    return 0;\n}\n",
        "result": "AC"
    },
    "set_power_series/or_convolution.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/bitwise_and_convolution\n#include \"set_power_series/or_convolution.hpp\"\n#include \"utility/modint.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\nint main()\n{\n    using mint = modint_998244353;\n    const auto n = in.val<int>();\n    const int N = 1 << n;\n    const auto as = in.vec<mint>(N);\n    const auto bs = in.vec<mint>(N);\n    Vec<mint> As(N, 0), Bs(N, 0);\n    for (int i : rep(N)) {\n        As[i] = as[N - i - 1];\n        Bs[i] = bs[N - i - 1];\n    }\n    const auto Cs = orConvolute(As, Bs);\n    Vec<int> ans(Cs.size());\n    for (int i : rep(N)) { ans[i] = Cs[N - i - 1].val(); }\n    out.ln(ans);\n    return 0;\n}\n",
        "result": "AC"
    },
    "set_power_series/subset_convolution.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/subset_convolution\n#include \"set_power_series/subset_convolution.hpp\"\n#include \"utility/modint.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\nint main()\n{\n    using mint = modint_998244353;\n    const auto N = in.val<int>();\n    const auto as = in.vec<mint>(1 << N);\n    const auto bs = in.vec<mint>(1 << N);\n    const auto cs = subsetConvolute(as, bs);\n    Vec<int> ans(cs.size());\n    for (int i : rep(1 << N)) { ans[i] = cs[i].val(); }\n    out.ln(ans);\n    return 0;\n}\n",
        "result": "AC"
    },
    "set_power_series/xor_convolution.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/bitwise_xor_convolution\n#include \"set_power_series/xor_convolution.hpp\"\n#include \"utility/modint.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\nint main()\n{\n    using mint = modint_998244353;\n    const auto n = in.val<int>();\n    const int N = 1 << n;\n    const auto as = in.vec<mint>(N);\n    const auto bs = in.vec<mint>(N);\n    const auto cs = xorConvolute(as, bs);\n    std::vector<int> ans(cs.size());\n    for (int i : rep(N)) { ans[i] = cs[i].val(); }\n    out.ln(ans);\n    return 0;\n}\n",
        "result": "AC"
    },
    "string/manacher.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/enumerate_palindromes\n#include \"string/manacher.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\n\nint main()\n{\n    auto S = in.val<Str>();\n    const int N = S.size();\n    Str T;\n    for (int i : rep(N)) {\n        T.push_back('$');\n        T.push_back(S[i]);\n    }\n    T.push_back('$');\n    auto rs = manacher(T);\n    Vec<int> ans;\n    for (int i : irange(1, 2 * N)) { ans.push_back(rs[i] - 1); }\n    out.ln(ans);\n    return 0;\n}\n",
        "result": "AC"
    },
    "string/morris_pratt.ut.test.cpp": {
        "code": "// verification-helper: UNITTEST\n#include \"string/morris_pratt.hpp\"\n\nvoid Test()\n{\n    Str s = \"aabaabaaa\";\n    const auto rs = morrisPratt(s);\n    assert(rs == (Vec<int>{-1, 0, 1, 0, 1, 2, 3, 4, 5, 2}));\n}\n\nint main()\n{\n    Test();\n    return 0;\n}\n",
        "result": "AC"
    },
    "string/suffix_array.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/suffixarray\n#include \"string/suffix_array.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\n\nint main()\n{\n    const auto S = in.val<Str>();\n    const auto SA = suffixArray(S);\n    out.ln(SA);\n    return 0;\n}\n",
        "result": "AC"
    },
    "string/z_algorithm.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/zalgorithm\n#include \"string/z_algorithm.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\n\nint main()\n{\n    auto S = in.val<Str>();\n    out.ln(z_algorithm(S));\n    return 0;\n}\n",
        "result": "AC"
    },
    "utility/int_nthroot.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/kth_root_integer\n#include \"utility/int_nthroot.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\n\nint main()\n{\n    const auto T = in.val<int>();\n    LOOP (T) {\n        const auto [A, K] = in.tup<u64, int>();\n        out.ln(intNthRoot(A, K));\n    }\n}\n",
        "result": "AC"
    },
    "utility/io.test.cpp": {
        "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/many_aplusb\n#include \"common.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\n\nint main()\n{\n    const auto T = in.val<int>();\n    LOOP (T) {\n        const auto [A, B] = in.tup<i64, i64>();\n        out.ln(A + B);\n    }\n\n    return 0;\n}\n",
        "result": "AC"
    },
    "utility/nd_rep.ut.test.cpp": {
        "code": "// verification-helper: UNITTEST\n#include \"utility/nd_rep.hpp\"\n\nvoid Test()\n{\n    std::vector<std::vector<int>> iss;\n    for (auto is : ndRep({2, 3, 4})) {\n        assert(0 <= is[0] and is[0] < 2);\n        assert(0 <= is[1] and is[1] < 3);\n        assert(0 <= is[2] and is[2] < 4);\n        iss.push_back(is);\n    }\n    assert(iss.size() == 2 * 3 * 4);\n    assert(std::is_sorted(iss.begin(), iss.end()));\n}\n\nint main()\n{\n    Test();\n    return 0;\n}\n",
        "result": "AC"
    },
    "utility/nd_vec.ut.test.cpp": {
        "code": "// verification-helper: UNITTEST\n#include \"utility/nd_vec.hpp\"\n\nvoid Test()\n{\n    using V = std::vector<int>;\n    using VV = std::vector<V>;\n    using VVV = std::vector<VV>;\n    using VVVV = std::vector<VVV>;\n    const auto vss = ndVec<int>({3, 4});\n    assert(vss == VV({{0, 0, 0, 0}, {0, 0, 0, 0}, {0, 0, 0, 0}}));\n    const auto vssss = ndVec({4, 3, 2, 1}, 1);\n    assert(vssss\n           == VVVV({{{{1}, {1}}, {{1}, {1}}, {{1}, {1}}},\n                    {{{1}, {1}}, {{1}, {1}}, {{1}, {1}}},\n                    {{{1}, {1}}, {{1}, {1}}, {{1}, {1}}},\n                    {{{1}, {1}}, {{1}, {1}}, {{1}, {1}}}}));\n}\n\nint main()\n{\n    Test();\n    return 0;\n}\n",
        "result": "AC"
    },
    "utility/printer.ut.test.cpp": {
        "code": "// verification-helper: UNITTEST\n#include \"common.hpp\"\n#include \"utility/printer.hpp\"\n\nstd::stringstream ss;\nPrinter printer{ss};\n\nclass C\n{\npublic:\n    C(int s_) : s{s_} {}\n    friend Ostream& operator<<(Ostream& os, const C& cls) { return os << \"{\" << cls.s << \"}\"; }\n\nprivate:\n    int s;\n};\n\nvoid valTest()\n{\n    {\n        const int v = 100;\n        printer(v);\n        assert(ss.str() == \"100\");\n        ss.str(\"\");\n\n        printer.ln(v);\n        assert(ss.str() == \"100\\n\");\n        ss.str(\"\");\n\n        printer.el(v);\n        assert(ss.str() == \"100\\n\");\n        ss.str(\"\");\n    }\n\n    {\n        const char c = 'a';\n        printer(c);\n        assert(ss.str() == \"a\");\n        ss.str(\"\");\n\n        printer.ln(c);\n        assert(ss.str() == \"a\\n\");\n        ss.str(\"\");\n\n        printer.el(c);\n        assert(ss.str() == \"a\\n\");\n        ss.str(\"\");\n    }\n\n    {\n        const Str s = \"abcABC012\";\n        printer(s);\n        assert(ss.str() == \"abcABC012\");\n        ss.str(\"\");\n\n        printer.ln(s);\n        assert(ss.str() == \"abcABC012\\n\");\n        ss.str(\"\");\n\n        printer.el(s);\n        assert(ss.str() == \"abcABC012\\n\");\n        ss.str(\"\");\n    }\n\n    {\n        const C cls{100};\n        printer(cls);\n        assert(ss.str() == \"{100}\");\n        ss.str(\"\");\n\n        printer.ln(cls);\n        assert(ss.str() == \"{100}\\n\");\n        ss.str(\"\");\n\n        printer.el(cls);\n        assert(ss.str() == \"{100}\\n\");\n        ss.str(\"\");\n    }\n}\n\nvoid valsTest()\n{\n    const int v = 100;\n    const char c = 'a';\n    const Str s = \"abcABC012\";\n    const C cls{100};\n\n    printer(v, c, s, cls);\n    assert(ss.str() == \"100 a abcABC012 {100}\");\n    ss.str(\"\");\n\n    printer.ln(v, c, s, cls);\n    assert(ss.str() == \"100 a abcABC012 {100}\\n\");\n    ss.str(\"\");\n\n    printer.el(v, c, s, cls);\n    assert(ss.str() == \"100 a abcABC012 {100}\\n\");\n    ss.str(\"\");\n}\n\nint main()\n{\n    valTest();\n    valsTest();\n    return 0;\n}\n",
        "result": "AC"
    },
    "utility/rng.ut.test.cpp": {
        "code": "// verification-helper: UNITTEST\n#include \"utility/rng.hpp\"\n\nvoid Test()\n{\n    const u64 v32_1 = rng();\n    const u64 v64_1 = rng64();\n    assert(0_u64 <= v32_1 and v32_1 <= 0xFFFFFFFF_u64);\n    assert(0_u64 <= v64_1 and v64_1 <= 0xFFFFFFFFFFFFFFFF_u64);\n}\n\nvoid valTest()\n{\n    int min = 10, max = 20;\n    const int v32_1 = rng.val(min, max);\n    const int v64_1 = rng64.val(min, max);\n    assert(min <= v32_1 and v32_1 <= max);\n    assert(min <= v64_1 and v64_1 <= max);\n}\n\nvoid vecTest()\n{\n    int n = 10;\n    int min = 10, max = 20;\n    const auto vs32_1 = rng.vec(n, min, max);\n    const auto vs64_1 = rng64.vec(n, min, max);\n    for (const auto v : vs32_1) { assert(min <= v and v <= max); }\n    for (const auto v : vs64_1) { assert(min <= v and v <= max); }\n}\n\nvoid vvecTest()\n{\n    int m = 3, n = 4;\n    int min = 10, max = 20;\n    const auto vss32_1 = rng.vvec(m, n, min, max);\n    const auto vss64_1 = rng64.vvec(m, n, min, max);\n    for (const auto& vs : vss32_1) {\n        for (auto v : vs) { assert(min <= v and v <= max); }\n    }\n    for (const auto& vs : vss64_1) {\n        for (auto v : vs) { assert(min <= v and v <= max); }\n    }\n}\n\nint main()\n{\n    Test();\n    valTest();\n    vecTest();\n    vvecTest();\n    return 0;\n}\n",
        "result": "AC"
    },
    "utility/scanner.ut.test.cpp": {
        "code": "// verification-helper: UNITTEST\n#include \"common.hpp\"\n#include \"utility/scanner.hpp\"\n\nstd::stringstream ss;\nScanner scanner{ss};\n\nclass C\n{\npublic:\n    C() = default;\n    C(int s_) : s{s_} {}\n    friend Istream& operator>>(Istream& is, C& cls)\n    {\n        char c;\n        is >> c;\n        assert(c == '{');\n        is >> cls.s;\n        is >> c;\n        assert(c == '}');\n        return is;\n    }\n    friend bool operator==(const C& c1, const C& c2) { return c1.s == c2.s; }\n\nprivate:\n    int s;\n};\n\nvoid valTest()\n{\n    {\n        const int v = 100;\n        ss << \"100\";\n        const auto rv = scanner.val<int>();\n        assert(v == rv);\n        ss.clear();\n    }\n    {\n        const char c = 'a';\n        ss << \"a\";\n        const auto rc = scanner.val<char>();\n        assert(c == rc);\n        ss.clear();\n    }\n    {\n        const Str s = \"ABCabc012\";\n        ss << \"ABCabc012\";\n        const auto rs = scanner.val<Str>();\n        assert(s == rs);\n        ss.clear();\n    }\n    {\n        const C cls{100};\n        ss << \"{100}\";\n        const auto rcls = scanner.val<C>();\n        assert(cls == rcls);\n        ss.clear();\n    }\n}\n\nvoid valOffsetTest()\n{\n    {\n        const int v = 100;\n        const int offset = 10;\n        ss << \"100\";\n        const auto rv = scanner.val<int>(offset);\n        assert(v - offset == rv);\n        ss.clear();\n    }\n}\n\nvoid vecTest()\n{\n    const int n = 5;\n    Vec<int> vs = {1, 2, 3, 4, 5};\n    ss << \"1 2 3 4 5\";\n    const auto rvs = scanner.vec<int>(n);\n    for (int i : rep(n)) { assert(vs[i] == rvs[i]); }\n    ss.clear();\n}\n\nvoid vecOffsetTest()\n{\n    const int n = 5;\n    const int offset = 1;\n    Vec<int> vs = {1, 2, 3, 4, 5};\n    ss << \"1 2 3 4 5\";\n    const auto rvs = scanner.vec<int>(n, offset);\n    for (int i : rep(n)) { assert(vs[i] - offset == rvs[i]); }\n    ss.clear();\n}\n\nvoid vvecTest()\n{\n    const int m = 2;\n    const int n = 3;\n    Vec<Vec<int>> vss = {{1, 2, 3}, {4, 5, 6}};\n    ss << \"1 2 3\\n\"\n          \"4 5 6\";\n    const auto rvss = scanner.vvec<int>(m, n);\n    for (int i : rep(m)) {\n        for (int j : rep(n)) { assert(vss[i][j] == rvss[i][j]); }\n    }\n    ss.clear();\n}\n\nvoid vvecOffsetTest()\n{\n    const int m = 2;\n    const int n = 3;\n    const int offset = 1;\n    Vec<Vec<int>> vss = {{1, 2, 3}, {4, 5, 6}};\n    ss << \"1 2 3\\n\"\n          \"4 5 6\";\n    const auto rvss = scanner.vvec<int>(m, n, offset);\n    for (int i : rep(m)) {\n        for (int j : rep(n)) { assert(vss[i][j] - offset == rvss[i][j]); }\n    }\n    ss.clear();\n}\n\nvoid tupTest()\n{\n    const int v = 100;\n    const char c = 'a';\n    const Str s = \"abcABC012\";\n    const C cls{100};\n    ss << \"100 a abcABC012 {100}\";\n    const auto [rv, rc, rs, rcls] = scanner.tup<int, char, Str, C>();\n    assert(v == rv);\n    assert(c == rc);\n    assert(s == rs);\n    assert(cls == rcls);\n    ss.clear();\n}\n\nvoid tupOffsetTest()\n{\n    const int v1 = 100;\n    const int v2 = 1000;\n    const int offset1 = 10;\n    const int offset2 = 100;\n    ss << \"100 1000\";\n    const auto [rv1, rv2] = scanner.tup<int, int>(offset1, offset2);\n    assert(v1 - offset1 == rv1);\n    assert(v2 - offset2 == rv2);\n    ss.clear();\n}\n\nint main()\n{\n    valTest();\n    valOffsetTest();\n    vecTest();\n    vecOffsetTest();\n    vvecTest();\n    vvecOffsetTest();\n    tupTest();\n    tupOffsetTest();\n    return 0;\n}\n",
        "result": "AC"
    },
    "utility/zipper.ut.test.cpp": {
        "code": "// verification-helper: UNITTEST\n#include \"utility/zipper.hpp\"\n\nvoid ConstructorTest()\n{\n    Zipper<int> zipper({2, 4, 2, 6, 6, 2});  // {2,4,6}\n    assert(zipper.unzip(0) == 2);\n    assert(zipper.unzip(1) == 4);\n    assert(zipper.unzip(2) == 6);\n    assert(zipper.zip(2) == 0);\n    assert(zipper.zip(4) == 1);\n    assert(zipper.zip(6) == 2);\n    assert(zipper.size() == 3);\n}\n\nvoid AddTest1()\n{\n    Zipper<int> zipper({2, 4, 2, 6, 6, 2});  // {2,4,6}\n    zipper.add(3);                           // {2,3,4,6}\n    assert(zipper.unzip(0) == 2);\n    assert(zipper.unzip(1) == 3);\n    assert(zipper.unzip(2) == 4);\n    assert(zipper.unzip(3) == 6);\n    assert(zipper.zip(2) == 0);\n    assert(zipper.zip(3) == 1);\n    assert(zipper.zip(4) == 2);\n    assert(zipper.zip(6) == 3);\n    assert(zipper.size() == 4);\n}\n\nvoid AddTest2()\n{\n    Zipper<int> zipper;\n    zipper.add({2, 4, 2, 6, 6, 2});  // {2,4,6}\n    assert(zipper.unzip(0) == 2);\n    assert(zipper.unzip(1) == 4);\n    assert(zipper.unzip(2) == 6);\n    assert(zipper.zip(2) == 0);\n    assert(zipper.zip(4) == 1);\n    assert(zipper.zip(6) == 2);\n    assert(zipper.size() == 3);\n}\n\nint main()\n{\n    ConstructorTest();\n    AddTest1();\n    AddTest2();\n    return 0;\n}\n",
        "result": "AC"
    }
}