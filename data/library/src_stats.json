{
    "algorithm/babystep_giantstep.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\n#include \"../utility/int_nthroot.hpp\"\n\n// f^n(x) = y \u3068\u306a\u308b\u6700\u5c0f\u306en\ntemplate<typename T, typename FW, typename FINV>\ni64 babyStepGiantStep(FW f_wtimes, FINV f_inv, const T& x, const T& y, i64 N, i64 W)\n{\n    const i64 M = ceilDiv(N, W);\n    UMap<T, i64> memo;\n    memo[x] = 1;\n    T gx = 1;\n    for (i64 i : irange(1, M + 1)) {\n        gx = f_wtimes(gx);\n        if (memo.count(gx) == 0) { memo[gx] = i * W; }\n    }\n\n    i64 ans = INF<i64>;\n    T sy = y;\n    for (i64 w : rep(W)) {\n        if (memo.count(sy)) { chmin(ans, memo[sy] + w); }\n        sy = f_inv(sy);\n    }\n    return (ans == INF<i64> ? -1_i64 : ans);\n}\n",
        "result": "ALL_AC"
    },
    "algorithm/ext_gcd.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\ntemplate<typename T>\nconstexpr Pair<T, T> extgcd(const T a, const T b)  // [x,y] -> ax+by=gcd(a,b)\n{\n    static_assert(std::is_signed_v<T>, \"Signed integer is allowed.\");\n    assert(a != 0 or b != 0);\n    if (a >= 0 and b >= 0) {\n        if (a < b) {\n            const auto [y, x] = extgcd(b, a);\n            return {x, y};\n        }\n        if (b == 0) { return {1, 0}; }\n        const auto [x, y] = extgcd(b, a % b);\n        return {y, x - (a / b) * y};\n    } else {\n        auto [x, y] = extgcd(std::abs(a), std::abs(b));\n        if (a < 0) { x = -x; }\n        if (b < 0) { y = -y; }\n        return {x, y};\n    }\n}\ntemplate<typename T>\nconstexpr T inverse(const T a, const T mod)  // ax=gcd(a,M) (mod M)\n{\n    assert(a > 0 and mod > 0);\n    auto [x, y] = extgcd(a, mod);\n    if (x <= 0) { x += mod; }\n    return x;\n}\n",
        "result": "ALL_AC"
    },
    "algorithm/linear_floor_sum.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\n\ntemplate<typename T = i64>\nT linearFloorSum(i64 N, i64 A, i64 B, i64 C)\n{\n    assert(C != 0);\n    if (C < 0) { return linearFloorSum<T>(N, -A, -B, -C); }\n    if (A == 0) { return T{N} * floorDiv(B, C); }\n    if (0 <= A and A < C and 0 <= B and B < C) {\n        const i64 M = ((i128)A * (N - 1) + B) / C;\n        return T{N - 1} * M - linearFloorSum<T>(M, C, C - B - 1, A);\n    } else {\n        const i64 a = floorDiv(A, C);\n        const i64 b = floorDiv(B, C);\n        return T{N} * (N - 1) / 2 * a + T{N} * b + linearFloorSum<T>(N, A - a * C, B - b * C, C);\n    }\n}\n",
        "result": "ALL_AC"
    },
    "algorithm/mo.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\nclass Mo\n{\npublic:\n    Mo(const Vec<int>& xs, const Vec<int>& ys) : m_xs{xs}, m_ys{ys}, m_is{iotaVec(m_xs.size())}\n    {\n        sortAll(m_is, [&](int i, int j) {\n            return hilbert(m_xs[i], m_ys[i]) < hilbert(m_xs[j], m_ys[j]);\n        });\n    }\n    template<typename R, typename L, typename D, typename U, typename S>\n    void solve(R right, L left, D down, U up, S sol)\n    {\n        int x = 0, y = 0;\n        for (int ii : rep(m_xs.size())) {\n            const int i = m_is[ii];\n            const int nx = m_xs[i], ny = m_ys[i];\n            for (; x < nx; x++) { right(x, y); }\n            for (; x > nx; x--) { left(x, y); }\n            for (; y < ny; y++) { down(x, y); }\n            for (; y > ny; y--) { up(x, y); }\n            sol(i);\n        }\n    }\n\nprivate:\n    static constexpr i64 hilbert(int x, int y)\n    {\n        i64 ans = 0;\n        constexpr i64 OFFs[] = {0, 3, 1, 2};\n        for (int i : per(30)) {\n            const int S = (isBitOn(x, i) << 1) | (isBitOn(y, i));\n            ans += OFFs[S] * (1_i64 << (2 * i));\n            if (S <= 1) { std::swap(x, y); }\n            if (S == 1) { x = ~x, y = ~y; }\n        }\n        return ans;\n    }\n    Vec<int> m_xs, m_ys;\n    Vec<int> m_is;\n};\n",
        "result": "ALL_AC"
    },
    "common.hpp": {
        "code": "#pragma once\n#include \"common/type.hpp\"\n#include \"common/environment.hpp\"\n#include \"common/macro.hpp\"\n#include \"common/constant.hpp\"\n#include \"common/chminmax.hpp\"\n#include \"common/int_div.hpp\"\n#include \"common/power.hpp\"\n#include \"common/container_op.hpp\"\n#include \"common/show.hpp\"\n#include \"common/bit_op.hpp\"\n#include \"common/fixpoint.hpp\"\n#include \"common/irange.hpp\"\n",
        "result": "ALL_AC"
    },
    "common/bit_op.hpp": {
        "code": "#pragma once\n#include \"type.hpp\"\nconstexpr int popCount(u64 v) { return v ? __builtin_popcountll(v) : 0; }\nconstexpr int topBit(u64 v) { return v == 0 ? -1 : 63 - __builtin_clzll(v); }\nconstexpr int lowBit(u64 v) { return v == 0 ? 64 : __builtin_ctzll(v); }\nconstexpr int bitWidth(u64 v) { return topBit(v) + 1; }\nconstexpr u64 bitCeil(u64 v) { return v ? (1_u64 << bitWidth(v - 1)) : 1_u64; }\nconstexpr u64 bitFloor(u64 v) { return v ? (1_u64 << topBit(v)) : 0_u64; }\nconstexpr bool hasSingleBit(u64 v) { return (v > 0) and ((v & (v - 1)) == 0); }\nconstexpr bool isBitOn(u64 mask, int ind) { return (mask >> ind) & 1_u64; }\nconstexpr bool isBitOff(u64 mask, int ind) { return not isBitOn(mask, ind); }\nconstexpr u64 bitMask(int bitWidth) { return (bitWidth == 64 ? ~0_u64 : (1_u64 << bitWidth) - 1); }\nconstexpr u64 bitMask(int start, int end) { return bitMask(end - start) << start; }\n",
        "result": "ALL_AC"
    },
    "common/chminmax.hpp": {
        "code": "#pragma once\n#include \"type.hpp\"\ntemplate<typename T>\nconstexpr bool chmin(T& a, const T& b)\n{\n    return (a > b ? (a = b, true) : false);\n}\ntemplate<typename T>\nconstexpr bool chmax(T& a, const T& b)\n{\n    return (a < b ? (a = b, true) : false);\n}\n",
        "result": "ALL_AC"
    },
    "common/constant.hpp": {
        "code": "#pragma once\n#include \"type.hpp\"\ntemplate<typename T>\nconstexpr T LIMMIN = std::numeric_limits<T>::min();\ntemplate<typename T>\nconstexpr T LIMMAX = std::numeric_limits<T>::max();\ntemplate<typename T>\nconstexpr T INF = (LIMMAX<T> - 1) / 2;\ntemplate<typename T>\nconstexpr T PI = T{3.141592653589793238462643383279502884};\ntemplate<typename T = u64>\nconstexpr T TEN(int n)\n{\n    return n == 0 ? T{1} : TEN<T>(n - 1) * T{10};\n}\n",
        "result": "ALL_AC"
    },
    "common/container_op.hpp": {
        "code": "#pragma once\n#include \"type.hpp\"\n#include \"macro.hpp\"\ntemplate<typename Vs, typename V>\nconstexpr void fillAll(Vs& arr, const V& v)\n{\n    if constexpr (std::is_convertible<V, Vs>::value) {\n        arr = v;\n    } else {\n        for (auto& subarr : arr) { fillAll(subarr, v); }\n    }\n}\ntemplate<typename Vs>\nconstexpr void sortAll(Vs& vs)\n{\n    std::sort(ALL(vs));\n}\ntemplate<typename Vs, typename C>\nconstexpr void sortAll(Vs& vs, C comp)\n{\n    std::sort(ALL(vs), comp);\n}\ntemplate<typename Vs>\nconstexpr void reverseAll(Vs& vs)\n{\n    std::reverse(ALL(vs));\n}\ntemplate<typename Vs>\nconstexpr Vs reversed(const Vs& vs)\n{\n    auto rvs = vs;\n    reverseAll(rvs);\n    return rvs;\n}\ntemplate<typename V, typename Vs>\nconstexpr V sumAll(const Vs& vs)\n{\n    if constexpr (std::is_convertible<Vs, V>::value) {\n        return static_cast<V>(vs);\n    } else {\n        V ans = 0;\n        for (const auto& v : vs) { ans += sumAll<V>(v); }\n        return ans;\n    }\n}\ntemplate<typename Vs>\nconstexpr int minInd(const Vs& vs)\n{\n    return std::min_element(ALL(vs)) - std::begin(vs);\n}\ntemplate<typename Vs>\nconstexpr int maxInd(const Vs& vs)\n{\n    return std::max_element(ALL(vs)) - std::begin(vs);\n}\ntemplate<typename Vs, typename V>\nconstexpr int lbInd(const Vs& vs, const V& v)\n{\n    return std::lower_bound(ALL(vs), v) - std::begin(vs);\n}\ntemplate<typename Vs, typename V>\nconstexpr int ubInd(const Vs& vs, const V& v)\n{\n    return std::upper_bound(ALL(vs), v) - std::begin(vs);\n}\ntemplate<typename Vs, typename V>\nconstexpr void plusAll(Vs& vs, const V& v)\n{\n    for (auto& v_ : vs) { v_ += v; }\n}\ntemplate<typename Vs>\nconstexpr void concat(Vs& vs1, const Vs& vs2)\n{\n    std::copy(ALL(vs2), std::back_inserter(vs1));\n}\ntemplate<typename Vs>\nconstexpr void concatted(const Vs& vs1, const Vs& vs2)\n{\n    auto vs = vs1;\n    concat(vs, vs2);\n    return vs;\n}\ntemplate<typename T, typename F>\nconstexpr Vec<T> genVec(int n, F gen)\n{\n    Vec<T> ans;\n    std::generate_n(std::back_inserter(ans), n, gen);\n    return ans;\n}\ntemplate<typename T = int>\nconstexpr Vec<T> iotaVec(int n, T offset = 0)\n{\n    Vec<T> ans(n);\n    std::iota(ALL(ans), offset);\n    return ans;\n}\ntemplate<typename Vs>\nconstexpr void rearrange(Vs& vs, const Vec<int>& is)\n{\n    auto vs_ = vs;\n    for (int i = 0; i < is.size(); i++) { vs[i] = vs_[is[i]]; }\n}\n",
        "result": "ALL_AC"
    },
    "common/environment.hpp": {
        "code": "#pragma once\n#ifdef HOGEPACHI\nconstexpr bool LOCAL = true;\n#else\nconstexpr bool LOCAL = false;\n#endif\nconstexpr bool OJ = not LOCAL;\n\ntemplate<typename T>\nstatic constexpr T OjLocal(T oj, T local)\n{\n    return LOCAL ? local : oj;\n}\n",
        "result": "ALL_AC"
    },
    "common/fixpoint.hpp": {
        "code": "#pragma once\n#include \"type.hpp\"\ntemplate<typename F>\nstruct Fix : F\n{\n    constexpr Fix(F&& f) : F{std::forward<F>(f)} {}\n    template<typename... Args>\n    constexpr auto operator()(Args&&... args) const\n    {\n        return F::operator()(*this, std::forward<Args>(args)...);\n    }\n};\n",
        "result": "ALL_AC"
    },
    "common/int_div.hpp": {
        "code": "#pragma once\n#include \"type.hpp\"\ntemplate<typename T>\nconstexpr T floorDiv(T x, T y)\n{\n    assert(y != 0);\n    if (y < 0) { x = -x, y = -y; }\n    return x >= 0 ? x / y : (x - y + 1) / y;\n}\ntemplate<typename T>\nconstexpr T ceilDiv(T x, T y)\n{\n    assert(y != 0);\n    if (y < 0) { x = -x, y = -y; }\n    return x >= 0 ? (x + y - 1) / y : x / y;\n}\n",
        "result": "ALL_AC"
    },
    "common/irange.hpp": {
        "code": "#pragma once\n#include \"type.hpp\"\n#include \"macro.hpp\"\nclass irange\n{\nprivate:\n    struct itr\n    {\n        constexpr itr(i64 start = 0, i64 step = 1) : m_cnt{start}, m_step{step} {}\n        constexpr bool operator!=(const itr& it) const { return m_cnt != it.m_cnt; }\n        constexpr i64 operator*() { return m_cnt; }\n        constexpr itr& operator++() { return m_cnt += m_step, *this; }\n        i64 m_cnt, m_step;\n    };\n    i64 m_start, m_end, m_step;\n\npublic:\n    static constexpr i64 cnt(i64 start, i64 end, i64 step)\n    {\n        if (step == 0) { return -1; }\n        const i64 d = (step > 0 ? step : -step);\n        const i64 l = (step > 0 ? start : end);\n        const i64 r = (step > 0 ? end : start);\n        i64 n = (r - l) / d + ((r - l) % d ? 1 : 0);\n        if (l >= r) { n = 0; }\n        return n;\n    }\n    constexpr irange(i64 start, i64 end, i64 step = 1)\n        : m_start{start}, m_end{m_start + step * cnt(start, end, step)}, m_step{step}\n    {\n        assert(step != 0);\n    }\n    constexpr itr begin() const { return itr{m_start, m_step}; }\n    constexpr itr end() const { return itr{m_end, m_step}; }\n};\nconstexpr irange rep(i64 end) { return irange(0, end, 1); }\nconstexpr irange per(i64 rend) { return irange(rend - 1, -1, -1); }\n#define LOOP(n) for (auto _ UNUSED : rep(n))\n",
        "result": "ALL_AC"
    },
    "common/macro.hpp": {
        "code": "#pragma once\n#define CAT(x, y) x##y\n#define CAT2(x, y) CAT(x, y)\n\n#define UNUSED [[maybe_unused]]\n#define _ CAT2(_temp_name_, __COUNTER__)\n#define ALL(vs) std::begin(vs), std::end(vs)\n",
        "result": "ALL_AC"
    },
    "common/power.hpp": {
        "code": "#pragma once\n#include \"type.hpp\"\ntemplate<typename T, typename I>\nconstexpr T powerMonoid(T v, I n, const T& e)\n{\n    assert(n >= 0);\n    if (n == 0) { return e; }\n    return (n % 2 == 1 ? v * powerMonoid(v, n - 1, e) : powerMonoid(v * v, n / 2, e));\n}\ntemplate<typename T, typename I>\nconstexpr T powerInt(T v, I n)\n{\n    return powerMonoid(v, n, T{1});\n}\n",
        "result": "ALL_AC"
    },
    "common/print/int128_t.hpp": {
        "code": "#pragma once\n#include \"../type.hpp\"\ninline Ostream& operator<<(Ostream& os, i128 v)\n{\n    bool minus = false;\n    if (v < 0) { minus = true, v = -v; }\n    Str ans;\n    if (v == 0) { ans = \"0\"; }\n    while (v) { ans.push_back('0' + v % 10), v /= 10; }\n    std::reverse(ans.begin(), ans.end());\n    return os << (minus ? \"-\" : \"\") << ans;\n}\ninline Ostream& operator<<(Ostream& os, u128 v)\n{\n    Str ans;\n    if (v == 0) { ans = \"0\"; }\n    while (v) { ans.push_back('0' + v % 10), v /= 10; }\n    std::reverse(ans.begin(), ans.end());\n    return os << ans;\n}\n",
        "result": "ALL_AC"
    },
    "common/print/print_stl.hpp": {
        "code": "#pragma once\n#include \"prototype/array.hpp\"\n#include \"prototype/deque.hpp\"\n#include \"prototype/map.hpp\"\n#include \"prototype/multimap.hpp\"\n#include \"prototype/multiset.hpp\"\n#include \"prototype/pair.hpp\"\n#include \"prototype/priority_queue.hpp\"\n#include \"prototype/queue.hpp\"\n#include \"prototype/set.hpp\"\n#include \"prototype/stack.hpp\"\n#include \"prototype/tuple.hpp\"\n#include \"prototype/unordered_map.hpp\"\n#include \"prototype/unordered_multimap.hpp\"\n#include \"prototype/unordered_multiset.hpp\"\n#include \"prototype/unordered_set.hpp\"\n#include \"prototype/vector.hpp\"\n#include \"impl/array.hpp\"\n#include \"impl/deque.hpp\"\n#include \"impl/map.hpp\"\n#include \"impl/multimap.hpp\"\n#include \"impl/multiset.hpp\"\n#include \"impl/pair.hpp\"\n#include \"impl/priority_queue.hpp\"\n#include \"impl/queue.hpp\"\n#include \"impl/set.hpp\"\n#include \"impl/stack.hpp\"\n#include \"impl/tuple.hpp\"\n#include \"impl/unordered_map.hpp\"\n#include \"impl/unordered_multimap.hpp\"\n#include \"impl/unordered_multiset.hpp\"\n#include \"impl/unordered_set.hpp\"\n#include \"impl/vector.hpp\"\n",
        "result": "NOT_TESTED"
    },
    "common/show.hpp": {
        "code": "#pragma once\n#include \"print/int128_t.hpp\"\n#ifdef HOGEPACHI\n#    include \"print/print_stl.hpp\"\nnamespace show_impl {\ntemplate<typename T>\nvoid dump(T x)\n{\n    std::cerr << x;\n}\ntemplate<typename T, typename... Args>\nvoid dump(T x, Args... args)\n{\n    std::cerr << x << \",\", dump(args...);\n}\n}  // namespace show_impl\n#    define SHOW(...)                                  \\\n        (std::cerr << \"LINE \" << __LINE__ << \": \"      \\\n                   << \"(\" << #__VA_ARGS__ << \") = (\"), \\\n            show_impl::dump(__VA_ARGS__), std::cerr << \")\" << std::endl\n#else\n#    define SHOW(...) void(0)\n#endif\n",
        "result": "ALL_AC"
    },
    "common/type.hpp": {
        "code": "#pragma once\n#include <bits/stdc++.h>\nusing i32 = int;\nusing u32 = unsigned int;\nusing i64 = long long;\nusing u64 = unsigned long long;\nusing i128 = __int128_t;\nusing u128 = __uint128_t;\nusing f64 = double;\nusing f80 = long double;\nusing f128 = __float128;\nconstexpr i32 operator\"\" _i32(u64 v) { return v; }\nconstexpr u32 operator\"\" _u32(u64 v) { return v; }\nconstexpr i64 operator\"\" _i64(u64 v) { return v; }\nconstexpr u64 operator\"\" _u64(u64 v) { return v; }\nconstexpr f64 operator\"\" _f64(f80 v) { return v; }\nconstexpr f80 operator\"\" _f80(f80 v) { return v; }\nusing Istream = std::istream;\nusing Ostream = std::ostream;\nusing Str = std::string;\ntemplate<typename T>\nusing Lt = std::less<T>;\ntemplate<typename T>\nusing Gt = std::greater<T>;\ntemplate<int n>\nusing BSet = std::bitset<n>;\ntemplate<typename T1, typename T2>\nusing Pair = std::pair<T1, T2>;\ntemplate<typename... Ts>\nusing Tup = std::tuple<Ts...>;\ntemplate<typename T, int N>\nusing Arr = std::array<T, N>;\ntemplate<typename... Ts>\nusing Deq = std::deque<Ts...>;\ntemplate<typename... Ts>\nusing Set = std::set<Ts...>;\ntemplate<typename... Ts>\nusing MSet = std::multiset<Ts...>;\ntemplate<typename... Ts>\nusing USet = std::unordered_set<Ts...>;\ntemplate<typename... Ts>\nusing UMSet = std::unordered_multiset<Ts...>;\ntemplate<typename... Ts>\nusing Map = std::map<Ts...>;\ntemplate<typename... Ts>\nusing MMap = std::multimap<Ts...>;\ntemplate<typename... Ts>\nusing UMap = std::unordered_map<Ts...>;\ntemplate<typename... Ts>\nusing UMMap = std::unordered_multimap<Ts...>;\ntemplate<typename... Ts>\nusing Vec = std::vector<Ts...>;\ntemplate<typename... Ts>\nusing Stack = std::stack<Ts...>;\ntemplate<typename... Ts>\nusing Queue = std::queue<Ts...>;\ntemplate<typename T>\nusing MaxHeap = std::priority_queue<T>;\ntemplate<typename T>\nusing MinHeap = std::priority_queue<T, Vec<T>, Gt<T>>;\n",
        "result": "ALL_AC"
    },
    "convex_hull_trick/li_chao_tree.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\ntemplate<typename T>\nclass LiChaoTree\n{\n    using L = Pair<T, T>;\n    static constexpr L NIL = {0, INF<T>};\n    struct Node\n    {\n        L line = NIL;\n        Arr<int, 2> sons{-1, -1};\n    };\n    static bool comp(const L& l1, const L& l2, T x)\n    {\n        if (l1 == NIL or l2 == NIL) { return l2 == NIL; }\n        const auto& [a1, b1] = l1;\n        const auto& [a2, b2] = l2;\n        if (a1 == a2) {\n            return b1 <= b2;\n        } else if (a1 > a2) {\n            return x <= floorDiv(b2 - b1, a1 - a2);\n        } else {\n            return floorDiv(b1 - b2, a2 - a1) < x;\n        }\n    }\n\npublic:\n    LiChaoTree(T xmin, T xsup) : m_xmin{xmin}, m_xsup{xsup}, m_nodes{Node{}}\n    {\n        assert(m_xmin < m_xsup);\n    }\n    void addLine(const L& line) { add(line, 0, m_xmin, m_xsup); }\n    void addSeg(const L& line, T x_left, T x_right)\n    {\n        if (x_left >= x_right) { return; }\n        assert(m_xmin <= x_left and x_right <= m_xsup);\n        Fix([&](auto dfs, int i, T lx, T rx) -> void {\n            if (x_left <= lx and rx <= x_right) {\n                add(line, i, lx, rx);\n            } else {\n                if (rx - lx == 1) { return; }\n                auto [li, ri] = m_nodes[i].sons;\n                const T mx = (lx + rx) / 2;\n                if (lx < x_right and x_left < mx) {\n                    if (li == -1) { li = m_nodes[i].sons[0] = alloc(); }\n                    dfs(li, lx, mx);\n                }\n                if (mx < x_right and x_left < rx) {\n                    if (ri == -1) { ri = m_nodes[i].sons[1] = alloc(); }\n                    dfs(ri, mx, rx);\n                }\n            }\n        })(0, m_xmin, m_xsup);\n    }\n    Pair<bool, L> minLine(const T x) const\n    {\n        T lx = m_xmin, rx = m_xsup;\n        L ans = NIL;\n        for (int i = 0; i != -1;) {\n            const auto& pl = m_nodes[i].line;\n            if (pl != NIL) {\n                if (comp(pl, ans, x)) { ans = pl; }\n            }\n            const auto& [li, ri] = m_nodes[i].sons;\n            const T mx = (lx + rx) / 2;\n            if (x < mx) {\n                i = li;\n                rx = mx;\n            } else {\n                i = ri;\n                lx = mx;\n            }\n        }\n        return {ans != NIL, ans};\n    }\n\nprivate:\n    void add(L l, int i, T lx, T rx)\n    {\n        for (;;) {\n            const auto& pl = m_nodes[i].line;\n            const T mx = (lx + rx) / 2;\n            const bool lunder = comp(l, pl, lx);\n            const bool runder = comp(l, pl, rx - 1);\n            const bool munder = comp(l, pl, mx);\n            if (munder) { std::swap(l, m_nodes[i].line); }\n            if (lunder == runder) { break; }\n            int dir = (lunder == munder ? 1 : 0);\n            int nind = m_nodes[i].sons[dir];\n            if (nind == -1) { nind = m_nodes[i].sons[dir] = alloc(); }\n            i = nind;\n            if (rx - lx == 1) { break; }\n            if (lunder == munder) {\n                lx = mx;\n            } else {\n                rx = mx;\n            }\n        }\n    }\n    int alloc()\n    {\n        m_nodes.push_back(Node{});\n        return (int)m_nodes.size() - 1;\n    }\n    T m_xmin, m_xsup;\n    Vec<Node> m_nodes;\n};\n",
        "result": "ALL_AC"
    },
    "convex_hull_trick/monotone_cht.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\ntemplate<typename T>\nclass MonotoneCHT\n{\n    using L = Pair<T, T>;\n    static constexpr L NIL = {0, INF<T>};\n    static bool needLess(const L& l1, const L& l2, const L& l3)\n    {\n        const auto [a1, b1] = l1;\n        const auto [a2, b2] = l2;\n        const auto [a3, b3] = l3;\n        const T x12 = floorDiv(b2 - b1, a1 - a2), x23 = floorDiv(b3 - b2, a2 - a3);\n        return x12 >= x23;\n    }\n    static bool comp(const L& l1, const L& l2, T x)\n    {\n        const auto [a1, b1] = l1;\n        const auto [a2, b2] = l2;\n        if (a1 == a2) {\n            return b1 <= b2;\n        } else if (a1 > a2) {\n            return x <= floorDiv(b2 - b1, a1 - a2);\n        } else {\n            return floorDiv(b1 - b2, a2 - a1) < x;\n        }\n    }\n\npublic:\n    MonotoneCHT() : m_prev_x{-INF<T>} {}\n    void addLine(T a, T b)\n    {\n        const L l{a, b};\n        if (m_lines.empty()) {\n            m_lines.push_back(l);\n            return;\n        }\n        auto& [ma, mb] = m_lines.back();\n        assert(ma >= a);\n        if (a == ma) {\n            chmin(mb, b);\n        } else {\n            while (m_lines.size() >= 2) {\n                const int n = m_lines.size();\n                const auto& l0 = m_lines[n - 2];\n                const auto& l1 = m_lines[n - 1];\n                if (not needLess(l0, l1, l)) { break; }\n                m_lines.pop_back();\n            }\n            m_lines.push_back(l);\n        }\n    }\n    L minLine(const T x)\n    {\n        if (m_lines.empty()) { return NIL; }\n        assert(m_prev_x <= x);\n        m_prev_x = x;\n        while (m_lines.size() >= 2) {\n            const auto& l0 = m_lines[0];\n            const auto& l1 = m_lines[1];\n            if (comp(l0, l1, x)) { break; }\n            m_lines.pop_front();\n        }\n        return m_lines.front();\n    }\n\nprivate:\n    T m_prev_x;\n    Deq<L> m_lines;\n};\n",
        "result": "ALL_AC"
    },
    "data_structure/fenwick_tree/fenwick_tree.hpp": {
        "code": "#pragma once\n#include \"../../common.hpp\"\ntemplate<typename T>\nclass FenwickTree\n{\npublic:\n    FenwickTree(const Vec<T>& vs) : m_size(vs.size()), m_cap(bitCeil(m_size)), m_vs(m_cap + 1, T{})\n    {\n        std::copy(vs.begin(), vs.end(), m_vs.begin() + 1);\n        for (int x : irange(1, m_cap)) { m_vs[x + (x & -x)] += m_vs[x]; }\n    }\n    FenwickTree(int N, const T& v = T{}) : FenwickTree{Vec<T>(N, v)} {}\n    void add(int i, const T& v)\n    {\n        assert(0 <= i and i < m_size);\n        for (int ind = i + 1; ind <= m_cap; ind += ind & (-ind)) { m_vs[ind] += v; }\n    }\n    T sum(int i) const\n    {\n        assert(0 <= i and i <= m_size);\n        T sum{};\n        for (int ind = i; ind != 0; ind &= ind - 1) { sum += m_vs[ind]; }\n        return sum;\n    }\n    T sum(int l, int r) const\n    {\n        assert(0 <= l and l <= r and r <= m_size);\n        return sum(r) - sum(l);\n    }\n    template<typename F>\n    int maxRight(F f)\n    {\n        assert(f(T{}));\n        T sum = T{};\n        int x = 0;\n        for (int k = (m_cap >> 1); k >= 1; k >>= 1) {\n            if (x + k <= m_size and f(sum + m_vs[x + k])) { sum += m_vs[x + k], x += k; }\n        }\n        return x;\n    }\n    friend Ostream& operator<<(Ostream& os, const FenwickTree& fw)\n    {\n        os << \"[\";\n        for (int i : rep(fw.m_size)) { os << (i == 0 ? \"\" : \",\") << fw.sum(i, i + 1); }\n        return (os << \"]\\n\");\n    }\n\nprivate:\n    int m_size, m_cap;\n    Vec<T> m_vs;\n};\n",
        "result": "ALL_AC"
    },
    "data_structure/fenwick_tree/fenwick_tree_2d.hpp": {
        "code": "#pragma once\n#include \"../../common.hpp\"\ntemplate<typename T>\nclass FenwickTree2D\n{\npublic:\n    FenwickTree2D(const Vec<Vec<T>>& vss)\n        : m_hsize(vss.size()),\n          m_wsize(vss.front().size()),\n          m_hcap(bitCeil(m_hsize)),\n          m_wcap(bitCeil(m_wsize)),\n          m_vss(m_hcap + 1, Vec<T>(m_wcap + 1, T{}))\n    {\n        for (int i : rep(m_hsize)) {\n            for (int j : rep(m_wsize)) { add(i, j, vss[i][j]); }\n        }\n    }\n    FenwickTree2D(int N, int M, const T& v = T{}) : FenwickTree2D{Vec<Vec<T>>(N, Vec<T>(M, v))} {}\n    void add(int i, int j, const T& v)\n    {\n        assert(0 <= i and i < m_hsize);\n        assert(0 <= j and j < m_wsize);\n        for (int iind = i + 1; iind <= m_hcap; iind += iind & (-iind)) {\n            for (int jind = j + 1; jind <= m_wcap; jind += jind & (-jind)) {\n                m_vss[iind][jind] += v;\n            }\n        }\n    }\n    T sum(int i, int j) const\n    {\n        assert(0 <= i and i <= m_hsize);\n        assert(0 <= j and j <= m_wsize);\n        T sum{};\n        for (int iind = i; iind != 0; iind &= iind - 1) {\n            for (int jind = j; jind != 0; jind &= jind - 1) { sum += m_vss[iind][jind]; }\n        }\n        return sum;\n    }\n    T sum(int imin, int imax, int jmin, int jmax) const\n    {\n        assert(0 <= imin and imin <= imax and imax <= m_hsize);\n        assert(0 <= jmin and jmin <= jmax and jmax <= m_wsize);\n        return sum(imax, jmax) - sum(imax, jmin) - sum(imin, jmax) + sum(imin, jmin);\n    }\n    friend Ostream& operator<<(Ostream& os, const FenwickTree2D& fw)\n    {\n        os << \"[\";\n        for (int i : rep(fw.m_hsize)) {\n            os << \"[\";\n            for (int j : rep(fw.m_wsize)) {\n                os << (i == 0 ? \"\" : \",\") << fw.sum(i, i + 1, j, j + 1);\n            }\n            os << \"]\\n\";\n        }\n        return os;\n    }\n\nprivate:\n    int m_hsize, m_wsize;\n    int m_hcap, m_wcap;\n    Vec<Vec<T>> m_vss;\n};\n",
        "result": "NOT_TESTED"
    },
    "data_structure/segment_tree/dual_segtree.hpp": {
        "code": "#pragma once\n#include \"../../common.hpp\"\ntemplate<typename OpMonoid>\nclass DualSegTree\n{\n    using F = typename OpMonoid::F;\n    static constexpr F id() { return OpMonoid::id(); }\n\npublic:\n    DualSegTree(const Vec<F>& vs)\n        : m_size(vs.size()),\n          m_half(bitCeil(m_size)),\n          m_depth(bitWidth(m_half)),\n          m_ops(m_half << 1, id())\n    {\n        std::copy(vs.begin(), vs.end(), m_ops.begin() + m_half);\n    }\n    DualSegTree(int N, const F& f = OpMonoid::id()) : DualSegTree{Vec<F>(N, f)} {}\n    F get(int i) const\n    {\n        assert(0 <= i and i < m_size);\n        F ans = id();\n        i += m_half;\n        for (int h : per(m_depth)) { ans = compose(ans, m_ops[i >> h]); }\n        return ans;\n    }\n    void set(int i, const F& f)\n    {\n        assert(0 <= i and i < m_size);\n        i += m_half;\n        clean(i), clean(i + 1);\n        m_ops[i] = f;\n    }\n    void act(int l, int r, const F& f)\n    {\n        assert(0 <= l and r <= m_size);\n        if (l >= r) { return; }\n        int li = l + m_half, ri = r + m_half;\n        clean(li), clean(ri);\n        for (; li < ri; li >>= 1, ri >>= 1) {\n            if (li & 1) { update(li++, f); }\n            if (ri & 1) { update(--ri, f); }\n        }\n    }\n    friend Ostream& operator<<(Ostream& os, const DualSegTree& seg)\n    {\n        os << \"[\";\n        for (int i : rep(seg.m_size)) { os << (i == 0 ? \"\" : \",\") << seg.get(i); }\n        return (os << \"]\\n\");\n    }\n\nprivate:\n    void down(int i)\n    {\n        update(i << 1, m_ops[i]), update(i << 1 | 1, m_ops[i]);\n        m_ops[i] = id();\n    }\n    void clean(int i)\n    {\n        const int b = (i / (i & -i)) >> 1;\n        for (const int h : per(m_depth)) {\n            const int v = i >> h;\n            if (v > b) { break; }\n            down(v);\n        }\n    }\n    void update(int i, const F& f) { m_ops[i] = compose(f, m_ops[i]); }\n    int m_size, m_half, m_depth;\n    Vec<F> m_ops;\n    static inline OpMonoid compose;\n};\n",
        "result": "ALL_AC"
    },
    "data_structure/segment_tree/lazy_segtree.hpp": {
        "code": "#pragma once\n#include \"../../common.hpp\"\ntemplate<typename MergeMonoid, typename OpMonoid, typename Act>\nclass LazySeg\n{\n    using T = typename MergeMonoid::T;\n    using F = typename OpMonoid::F;\n    static constexpr T e() { return MergeMonoid::e(); }\n    static constexpr F id() { return OpMonoid::id(); }\n\npublic:\n    LazySeg(const Vec<T>& vs)\n        : m_size(vs.size()),\n          m_half(bitCeil(m_size)),\n          m_depth(bitWidth(m_half)),\n          m_vs(m_half << 1, e()),\n          m_ops(m_half << 1, id())\n    {\n        std::copy(vs.begin(), vs.end(), m_vs.begin() + m_half);\n        for (int i : irange(m_half - 1, 0, -1)) { up(i); }\n    }\n    LazySeg(int N, const T& v = MergeMonoid::e()) : LazySeg{Vec<T>(N, v)} {}\n    T get(const int a)\n    {\n        assert(a < m_size);\n        return fold(a, a + 1);\n    }\n    void set(int i, const T& v)\n    {\n        assert(0 <= i and i < m_size);\n        i += m_half;\n        topDown(i), topDown(i + 1);\n        m_ops[i] = id();\n        m_vs[i] = v;\n        while (i >>= 1) { up(i); }\n    }\n    T fold(int l, int r)\n    {\n        assert(0 <= l and l <= r and r <= m_size);\n        if (l >= r) { return e(); }\n        l += m_half, r += m_half;\n        topDown(l), topDown(r);\n        T accl = e(), accr = e();\n        for (; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) { accl = merge(accl, m_vs[l++]); }\n            if (r & 1) { accr = merge(m_vs[--r], accr); }\n        }\n        return merge(accl, accr);\n    }\n    void act(int l, int r, const F& f)\n    {\n        assert(0 <= l and l <= r and r <= m_size);\n        int li = l + m_half, ri = r + m_half;\n        topDown(li), topDown(ri);\n        for (; li < ri; li >>= 1, ri >>= 1) {\n            if (li & 1) { update(li++, f); }\n            if (ri & 1) { update(--ri, f); }\n        }\n        bottomUp(l + m_half), bottomUp(r + m_half);\n    }\n    friend Ostream& operator<<(Ostream& os, const LazySeg& lseg)\n    {\n        auto lseg2 = lseg;\n        os << \"[\";\n        for (int i : rep(lseg.m_size)) { os << (i == 0 ? \"\" : \",\") << lseg2.get(i); }\n        return (os << \"]\\n\");\n    }\n\nprivate:\n    void up(int i) { m_vs[i] = merge(m_vs[i << 1], m_vs[i << 1 | 1]); }\n    void update(int i, const F& f)\n    {\n        m_ops[i] = compose(f, m_ops[i]);\n        m_vs[i] = apply(f, m_vs[i]);\n    }\n    void down(int i)\n    {\n        update(i << 1, m_ops[i]), update(i << 1 | 1, m_ops[i]);\n        m_ops[i] = id();\n    }\n    void topDown(int i)\n    {\n        const int j = (i / (i & -i)) >> 1;\n        for (const int h : per(m_depth)) {\n            const int v = i >> h;\n            if (v > j) { break; }\n            down(v);\n        }\n    }\n    void bottomUp(int i)\n    {\n        i = (i / (i & -i)) >> 1;\n        for (; i >= 1; i >>= 1) { up(i); }\n    }\n    int m_size, m_half, m_depth;\n    Vec<T> m_vs;\n    Vec<F> m_ops;\n    static inline MergeMonoid merge;\n    static inline OpMonoid compose;\n    static inline Act apply;\n};\n",
        "result": "ALL_AC"
    },
    "data_structure/segment_tree/segtree.hpp": {
        "code": "#pragma once\n#include \"../../common.hpp\"\ntemplate<typename MergeMonoid>\nclass SegTree\n{\n    using T = typename MergeMonoid::T;\n    static constexpr T e() { return MergeMonoid::e(); }\n\npublic:\n    SegTree(const Vec<T>& vs)\n        : m_size(vs.size()), m_half(bitCeil(m_size)), m_vals(m_half << 1, MergeMonoid::e())\n    {\n        std::copy(vs.begin(), vs.end(), m_vals.begin() + m_half);\n        for (int i = m_half - 1; i >= 1; i--) { up(i); }\n    }\n    SegTree(int N, const T& v = MergeMonoid::e()) : SegTree{Vec<T>(N, v)} {}\n    T get(int i) const\n    {\n        assert(0 <= i and i < m_size);\n        return m_vals[i + m_half];\n    }\n    void set(int i, const T& v)\n    {\n        assert(0 <= i and i < m_size);\n        m_vals[i += m_half] = v;\n        while (i >>= 1) { up(i); }\n    }\n    T fold(int l, int r) const\n    {\n        assert(0 <= l and l <= r and r <= m_size);\n        T lv = e(), rv = e();\n        int li = l + m_half, ri = r + m_half;\n        for (; li < ri; li >>= 1, ri >>= 1) {\n            if (li & 1) { lv = merge(lv, m_vals[li++]); }\n            if (ri & 1) { rv = merge(m_vals[--ri], rv); }\n        }\n        return merge(lv, rv);\n    }\n    friend Ostream& operator<<(Ostream& os, const SegTree& seg)\n    {\n        os << \"[\";\n        for (int i : rep(seg.m_size)) { os << (i == 0 ? \"\" : \",\") << seg.m_vals[i + seg.m_half]; }\n        return (os << \"]\");\n    }\n\nprivate:\n    void up(int i) { m_vals[i] = merge(m_vals[i << 1], m_vals[i << 1 | 1]); }\n    int m_size, m_half;\n    Vec<T> m_vals;\n    static inline MergeMonoid merge;\n};\n",
        "result": "ALL_AC"
    },
    "data_structure/segment_tree/segtree_beats.hpp": {
        "code": "#pragma once\n#include \"../../common.hpp\"\ntemplate<typename MergeMonoid, typename OpMonoid, typename Act>\nclass SegBeats\n{\n    using T = typename MergeMonoid::T;\n    using F = typename OpMonoid::F;\n    static constexpr T e() { return MergeMonoid::e(); }\n    static constexpr F id() { return OpMonoid::id(); }\n\npublic:\n    SegBeats(const Vec<T>& vs)\n        : m_size(vs.size()),\n          m_half(bitCeil(m_size)),\n          m_depth(bitWidth(m_half)),\n          m_vs(m_half << 1, e()),\n          m_ops(m_half << 1, id())\n    {\n        std::copy(vs.begin(), vs.end(), m_vs.begin() + m_half);\n        for (int i : irange(m_half - 1, 0, -1)) { up(i); }\n    }\n    SegBeats(int N, const T& v = MergeMonoid::e()) : SegBeats{Vec<T>(N, v)} {}\n    T get(const int a)\n    {\n        assert(a < m_size);\n        return fold(a, a + 1);\n    }\n    void set(int i, const T& v)\n    {\n        assert(0 <= i and i < m_size);\n        i += m_half;\n        topDown(i), topDown(i + 1);\n        m_ops[i] = id();\n        m_vs[i] = v;\n        while (i >>= 1) { up(i); }\n    }\n    T fold(int l, int r)\n    {\n        assert(0 <= l and l <= r and r <= m_size);\n        if (l >= r) { return e(); }\n        l += m_half, r += m_half;\n        topDown(l), topDown(r);\n        T accl = e(), accr = e();\n        for (; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) { accl = merge(accl, m_vs[l++]); }\n            if (r & 1) { accr = merge(m_vs[--r], accr); }\n        }\n        return merge(accl, accr);\n    }\n    void act(int l, int r, const F& f)\n    {\n        assert(0 <= l and l <= r and r <= m_size);\n        int li = l + m_half, ri = r + m_half;\n        topDown(li), topDown(ri);\n        for (; li < ri; li >>= 1, ri >>= 1) {\n            if (li & 1) { update(li++, f); }\n            if (ri & 1) { update(--ri, f); }\n        }\n        bottomUp(l + m_half), bottomUp(r + m_half);\n    }\n    friend Ostream& operator<<(Ostream& os, const SegBeats& lseg)\n    {\n        auto lseg2 = lseg;\n        os << \"[\";\n        for (int i : rep(lseg.m_size)) { os << (i == 0 ? \"\" : \",\") << lseg2.get(i); }\n        return (os << \"]\\n\");\n    }\n\nprivate:\n    void up(int i) { m_vs[i] = merge(m_vs[i << 1], m_vs[i << 1 | 1]); }\n    void update(int i, const F& f)\n    {\n        if (f == OpMonoid::id()) { return; }\n        m_ops[i] = compose(f, m_ops[i]);\n        m_vs[i] = apply(f, m_vs[i]);\n        if (apply.failed(m_vs[i])) {\n            down(i);\n            up(i);\n        }\n    }\n    void down(int i)\n    {\n        update(i << 1, m_ops[i]), update(i << 1 | 1, m_ops[i]);\n        m_ops[i] = id();\n    }\n    void topDown(int i)\n    {\n        const int j = (i / (i & -i)) >> 1;\n        for (const int h : per(m_depth)) {\n            const int v = i >> h;\n            if (v > j) { break; }\n            down(v);\n        }\n    }\n    void bottomUp(int i)\n    {\n        i = (i / (i & -i)) >> 1;\n        for (; i >= 1; i >>= 1) { up(i); }\n    }\n    int m_size, m_half, m_depth;\n    Vec<T> m_vs;\n    Vec<F> m_ops;\n    static inline MergeMonoid merge;\n    static inline OpMonoid compose;\n    static inline Act apply;\n};\n",
        "result": "ALL_AC"
    },
    "data_structure/segment_tree/skeleton.hpp": {
        "code": "#pragma once\n#include \"../../common.hpp\"\nclass SegSkeleton\n{\npublic:\n    SegSkeleton(int size) : m_size(size), m_half(bitCeil(m_size)), m_segs(m_half * 2, {0, 0})\n    {\n        for (int i = 1; i <= m_half; i <<= 1) {\n            const int l = m_half / i;\n            for (int j : rep(i)) { m_segs[i + j] = {l * j, l * (j + 1)}; }\n        }\n    }\n    template<typename F>\n    void act(int l, int r, F f) const\n    {\n        assert(0 <= l and l <= r and r <= m_size);\n        int li = l + m_half, ri = r + m_half;\n        for (; li < ri; li >>= 1, ri >>= 1) {\n            if (li & 1) {\n                const auto& [xl, xr] = m_segs[li];\n                f(li++, xl, xr);\n            }\n            if (ri & 1) {\n                const auto& [xl, xr] = m_segs[--ri];\n                f(ri, xl, xr);\n            }\n        }\n    }\n\nprivate:\n    int m_size, m_half;\n    Vec<Pair<int, int>> m_segs;\n};\n",
        "result": "NOT_TESTED"
    },
    "data_structure/sliding_window_aggregation/deque.hpp": {
        "code": "#pragma once\n#include \"../../common.hpp\"\ntemplate<typename SemiGroup>\nclass SwagDeque\n{\n    using T = typename SemiGroup::T;\n\npublic:\n    SwagDeque() {}\n    void pushBack(const T& x)\n    {\n        m_backs.push_back(x);\n        m_Backs.push_back(m_Backs.empty() ? x : m_merge(m_Backs.back(), x));\n    }\n    void pushFront(const T& x)\n    {\n        m_fronts.push_back(x);\n        m_Fronts.push_back(m_Fronts.empty() ? x : m_merge(x, m_Fronts.back()));\n    }\n    void popBack()\n    {\n        if (m_Backs.empty()) {\n            Vec<T> as = m_fronts;\n            m_fronts.clear(), m_Fronts.clear();\n            reverseAll(as);\n            const int f = (int)as.size() / 2;\n            for (int i : per(f)) { m_fronts.push_back(as[i]); }\n            for (int i : irange(f, (int)as.size() - 1)) { m_backs.push_back(as[i]); }\n            calc();\n        } else {\n            m_backs.pop_back(), m_Backs.pop_back();\n        }\n    }\n    void popFront()\n    {\n        if (m_Fronts.empty()) {\n            Vec<T> as = m_backs;\n            m_backs.clear(), m_Backs.clear();\n            const int f = ((int)as.size() + 1) / 2;\n            for (int i : irange(f - 1, 0, -1)) { m_fronts.push_back(as[i]); }\n            for (int i : irange(f, (int)as.size())) { m_backs.push_back(as[i]); }\n            calc();\n        } else {\n            m_fronts.pop_back(), m_Fronts.pop_back();\n        }\n    }\n    T foldAll() const\n    {\n        return m_fronts.empty()\n                   ? m_Backs.back()\n                   : (m_backs.empty() ? m_Fronts.back() : m_merge(m_Fronts.back(), m_Backs.back()));\n    }\n    bool empty() const { return m_backs.empty() and m_fronts.empty(); }\n\nprivate:\n    void calc()\n    {\n        if (not m_fronts.empty()) {\n            m_Fronts.push_back(m_fronts[0]);\n            for (int i : irange(1, m_fronts.size())) {\n                m_Fronts.push_back(m_merge(m_fronts[i], m_Fronts.back()));\n            }\n        }\n        if (not m_backs.empty()) {\n            m_Backs.push_back(m_backs[0]);\n            for (int i : irange(1, m_backs.size())) {\n                m_Backs.push_back(m_merge(m_Backs.back(), m_backs[i]));\n            }\n        }\n    }\n    Vec<T> m_fronts, m_backs;\n    Vec<T> m_Fronts, m_Backs;\n    static inline SemiGroup m_merge;\n};\n",
        "result": "ALL_AC"
    },
    "data_structure/sliding_window_aggregation/queue.hpp": {
        "code": "#pragma once\n#include \"../../common.hpp\"\ntemplate<typename SemiGroup>\nclass SwagQueue\n{\n    using T = typename SemiGroup::T;\n\npublic:\n    SwagQueue() {}\n    void pushBack(const T& x)\n    {\n        m_backs.push_back(x);\n        m_Backs.push_back(m_Backs.empty() ? x : m_merge(m_Backs.back(), x));\n    }\n    void popFront()\n    {\n        if (m_Fronts.empty()) {\n            std::swap(m_fronts, m_backs), reverseAll(m_fronts), m_fronts.pop_back();\n            m_backs.clear(), m_Backs.clear();\n            calc();\n        } else {\n            m_fronts.pop_back(), m_Fronts.pop_back();\n        }\n    }\n    T foldAll() const\n    {\n        return m_fronts.empty()\n                   ? m_Backs.back()\n                   : (m_backs.empty() ? m_Fronts.back() : m_merge(m_Fronts.back(), m_Backs.back()));\n    }\n    bool empty() const { return m_backs.empty() and m_fronts.empty(); }\n\nprivate:\n    void calc()\n    {\n        if (not m_fronts.empty()) {\n            m_Fronts.push_back(m_fronts[0]);\n            for (int i : irange(1, m_fronts.size())) {\n                m_Fronts.push_back(m_merge(m_fronts[i], m_Fronts.back()));\n            }\n        }\n        if (not m_backs.empty()) {\n            m_Backs.push_back(m_backs[0]);\n            for (int i : irange(1, m_backs.size())) {\n                m_Backs.push_back(m_merge(m_Backs.back(), m_backs[i]));\n            }\n        }\n    }\n    Vec<T> m_fronts, m_backs;\n    Vec<T> m_Fronts, m_Backs;\n    static inline SemiGroup m_merge;\n};\n",
        "result": "ALL_AC"
    },
    "data_structure/sparse_table/disjoint_sparse_table.hpp": {
        "code": "#pragma once\n#include \"../../common.hpp\"\ntemplate<typename SemiGroup>\nclass DisjointSparseTable\n{\n    using T = typename SemiGroup::T;\n\npublic:\n    DisjointSparseTable(const Vec<T>& vs)\n        : m_size(vs.size()), m_depth(bitWidth(m_size)), m_vss(m_depth, vs)\n    {\n        for (int d : rep(m_depth)) {\n            const int w = 1 << (m_depth - d - 1);\n            for (int i = 1; i * w < m_size; i += 2) {\n                int l = i * w - 1, r = i * w;\n                for (int j : irange(1, w)) {\n                    m_vss[d][l - j] = merge(vs[l - j], m_vss[d][l - j + 1]);\n                    if (r + j < m_size) { m_vss[d][r + j] = merge(vs[r + j], m_vss[d][r + j - 1]); }\n                }\n            }\n        }\n    }\n    T fold(int l, int r) const\n    {\n        assert(0 <= l and l < r and r <= m_size);\n        if (r - l == 1) { return m_vss.back()[l]; }\n        const int d = m_depth - bitWidth(l ^ (r - 1));\n        return merge(m_vss[d][l], m_vss[d][r - 1]);\n    }\n\nprivate:\n    int m_size, m_depth;\n    Vec<Vec<T>> m_vss;\n    static inline SemiGroup merge;\n};\n",
        "result": "ALL_AC"
    },
    "data_structure/sparse_table/static_rmq.hpp": {
        "code": "#pragma once\n#include \"../../common.hpp\"\n#include \"disjoint_sparse_table.hpp\"\ntemplate<typename TotalOrd>\nclass StaticRMQ\n{\n    using T = typename TotalOrd::T;\n    using B = u64;\n    static constexpr int bs = sizeof(B) * 8;\n    static constexpr int bslog = bitWidth(bs) - 1;\n    static constexpr int wind(int n) { return n >> (bslog); }\n    static constexpr int bind(int n) { return n ^ (wind(n) << bslog); }\n    static constexpr int ind(int w, int b) { return (w << bslog) | b; }\n\npublic:\n    StaticRMQ(const Vec<T>& vs)\n        : m_size{(int)vs.size()},\n          m_bn{wind(m_size + bs - 1)},\n          m_vals{vs},\n          m_masks(m_size, 0),\n          m_st{[&]() {\n              Vec<T> ans(m_bn);\n              for (int i : rep(m_size)) {\n                  ans[wind(i)]\n                      = (i % bs == 0 ? m_vals[i] : std::min(ans[wind(i)], m_vals[i], comp));\n              }\n              return ans;\n          }()}\n    {\n        for (int i : rep(m_bn)) {\n            Vec<int> g(bs, m_size), stack;\n            for (const int j : rep(bs)) {\n                if (ind(i, j) >= m_size) { break; }\n                for (; not stack.empty() and not comp(m_vals[stack.back()], m_vals[ind(i, j)]);\n                     stack.pop_back()) {}\n                g[j] = stack.empty() ? m_size : stack.back(), stack.push_back(ind(i, j));\n            }\n            for (int j : rep(bs)) {\n                if (ind(i, j) >= m_size) { break; }\n                m_masks[ind(i, j)] = g[j] == m_size\n                                         ? static_cast<B>(0)\n                                         : (m_masks[g[j]] | static_cast<B>(1) << (g[j] - i * bs));\n            }\n        }\n    }\n    T fold(int l, int r) const\n    {\n        assert(0 <= l and l < r and r <= m_size);\n        const int lb = (l + bs - 1) / bs, rb = r / bs;\n        if (lb > rb) {\n            return brmq(l, r);\n        } else {\n            return lb < rb\n                       ? (l < bs * lb\n                              ? (bs * rb < r ? std::min(\n                                     {m_st.fold(lb, rb), brmq(l, bs * lb), brmq(bs * rb, r)}, comp)\n                                             : std::min(m_st.fold(lb, rb), brmq(l, bs * lb), comp))\n                              : (bs * rb < r ? std::min(m_st.fold(lb, rb), brmq(bs * rb, r), comp)\n                                             : m_st.fold(lb, rb)))\n                       : (l < bs * lb\n                              ? (bs * rb < r ? std::min(brmq(l, bs * lb), brmq(bs * rb, r), comp)\n                                             : brmq(l, bs * lb))\n                              : (bs * rb < r ? brmq(bs * rb, r) : T{}));\n        }\n    }\n\nprivate:\n    T brmq(int l, int r) const\n    {\n        const B w = m_masks[r - 1] >> (l % bs);\n        return w == 0 ? m_vals[r - 1] : m_vals[l + lowBit(w)];\n    }\n    struct SemiGroup\n    {\n        using T = typename TotalOrd::T;\n        T operator()(const T& x1, const T& x2) const { return std::min(x1, x2, comp); }\n    };\n    int m_size, m_bn;\n    Vec<T> m_vals, m_bucket_vals;\n    Vec<B> m_masks;\n    DisjointSparseTable<SemiGroup> m_st;\n    static inline TotalOrd comp;\n};\n",
        "result": "ALL_AC"
    },
    "data_structure/union_find_tree/union_find_tree.hpp": {
        "code": "#pragma once\n#include \"../../common.hpp\"\nclass UnionFindTree\n{\npublic:\n    UnionFindTree(int n) : m_v{n}, m_roots{iotaVec(n)}, m_sizes(m_v, 1) {}\n    int find(int i)\n    {\n        if (m_roots[i] == i) {\n            return i;\n        } else {\n            return m_roots[i] = find(m_roots[i]);\n        }\n    }\n    bool unite(int i, int j)\n    {\n        i = find(i), j = find(j);\n        if (i == j) { return false; }\n        if (size(i) > size(j)) { std::swap(i, j); }\n        m_roots[i] = j;\n        m_sizes[j] += m_sizes[i];\n        return true;\n    }\n    bool same(int i, int j) { return find(i) == find(j); }\n    int size(int i) { return m_sizes[find(i)]; }\n    Vec<Vec<int>> groups()\n    {\n        Vec<Vec<int>> iss(m_v);\n        for (const int i : rep(m_v)) { iss[find(i)].push_back(i); }\n        return iss;\n    }\n\nprivate:\n    int m_v;\n    Vec<int> m_roots;\n    Vec<int> m_sizes;\n};\n",
        "result": "ALL_AC"
    },
    "data_structure/wavelet/bit_vector.hpp": {
        "code": "#pragma once\n#include \"../../common.hpp\"\nclass BitVector\n{\n    static constexpr int B = 64;\n    static int rank(u64 v, int i)\n    {\n        if (i == 0) { return 0; }\n        return popCount(v << (B - i));\n    }\n    struct Block\n    {\n        u64 bits = 0;\n        int rank = 0;  // \u30d6\u30ed\u30c3\u30af\u5148\u982d\u307e\u3067\u306b1\u304c\u4f55\u500b\u3042\u308b\u304b\n    };\n\npublic:\n    BitVector(int n) : m_size{n}, m_bn{n / B + 1}, m_blocks(m_bn) {}\n    void set(int i)\n    {\n        assert(0 <= i and i < m_size);\n        m_blocks[i / B].bits |= (1_u64 << (i % B));\n        m_calced = false;\n    }\n    int rank0(int i) { return i - rank1(i); }\n    int rank1(int i)\n    {\n        assert(0 <= i and i <= m_size);\n        calc();\n        return m_blocks[i / B].rank + rank(m_blocks[i / B].bits, i % B);\n    }\n    int zero()\n    {\n        calc();\n        return m_zero;\n    }\n    int one() { return m_size - zero(); }\n\nprivate:\n    void calc()\n    {\n        if (not m_calced) {\n            m_zero = m_size;\n            for (int i : irange(1, m_bn)) {\n                const int p = popCount(m_blocks[i - 1].bits);\n                m_blocks[i].rank += m_blocks[i - 1].rank + p;\n                m_zero -= p;\n            }\n            m_zero -= popCount(m_blocks[m_bn - 1].bits);\n            m_calced = true;\n        }\n    }\n    int m_size;\n    int m_bn;\n    Vec<Block> m_blocks;\n    bool m_calced = false;\n    int m_zero = 0;\n};\n",
        "result": "ALL_AC"
    },
    "data_structure/wavelet/wavelet_matrix.hpp": {
        "code": "#pragma once\n#include \"../../common.hpp\"\n#include \"bit_vector.hpp\"\ntemplate<typename T>\nclass WaveletMatrix\n{\npublic:\n    WaveletMatrix(Vec<T> vs)\n        : m_n(vs.size()),\n          m_min{vs[minInd(vs)]},\n          m_max{vs[maxInd(vs)]},\n          m_lg{bitWidth(m_max + 1)},\n          m_bvs(m_lg, BitVector(m_n))\n    {\n        assert(m_min >= 0);\n        Vec<T> nvs(m_n);\n        for (int bi : per(m_lg)) {\n            for (int i : rep(m_n)) {\n                if (isBitOn(vs[i], bi)) { m_bvs[bi].set(i); }\n            }\n            int is[2] = {0, m_bvs[bi].zero()};\n            for (int i : rep(m_n)) { nvs[is[isBitOn(vs[i], bi)]++] = vs[i]; }\n            std::swap(vs, nvs);\n        }\n    }\n    int rangeFreq(int l, int r, T vmin, T vsup)\n    {\n        assert(0 <= l and l <= r and r <= m_n);\n        assert(vmin <= vsup);\n        return lessFreq(l, r, vsup) - lessFreq(l, r, vmin);\n    }\n    T quantile(int l, int r, int k)\n    {\n        assert(0 <= l and l <= r and r <= m_n);\n        assert(0 <= k and k < r - l);\n        T ans = 0;\n        for (int bi : per(m_lg)) {\n            const int lz = m_bvs[bi].rank0(l), rz = m_bvs[bi].rank0(r);\n            if (rz - lz <= k) {\n                const int z = m_bvs[bi].zero();\n                ans |= (T{1} << bi);\n                k -= (rz - lz);\n                l += z - lz, r += z - rz;\n            } else {\n                l = lz, r = rz;\n            }\n        }\n        return ans;\n    }\n\nprivate:\n    int lessFreq(int l, int r, T v)\n    {\n        assert(0 <= l and l <= r and r <= m_n);\n        if (v <= m_min) { return 0; }\n        if (v - 1 >= m_max) { return r - l; }\n        int ans = 0;\n        for (int bi : per(m_lg)) {\n            const int lz = m_bvs[bi].rank0(l), rz = m_bvs[bi].rank0(r);\n            if (isBitOn(v, bi)) {\n                const int z = m_bvs[bi].zero();\n                ans += rz - lz;\n                l += z - lz, r += z - rz;\n            } else {\n                l = lz, r = rz;\n            }\n        }\n        return ans;\n    }\n    int m_n;\n    T m_min, m_max;\n    int m_lg;\n    Vec<BitVector> m_bvs;\n};\n",
        "result": "ALL_AC"
    },
    "formal_dirichlet_series/divisors_moebius.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\n#include \"../number/eratosthenes_sieve.hpp\"\ntemplate<typename T>\nVec<T> divisorsMoebius(const Vec<T>& xs, bool subset)\n{\n    const int N = (int)xs.size();\n    auto ys = xs;\n    for (const int p : EratosthenesSieve{N}.primes()) {\n        if (subset) {\n            for (int i = (N - 1) / p; i >= 1; i--) { ys[i * p] -= ys[i]; }\n        } else {\n            for (int i = 1; i * p < N; i++) { ys[i] -= ys[i * p]; }\n        }\n    }\n    return ys;\n}\n",
        "result": "ALL_AC"
    },
    "formal_dirichlet_series/divisors_zeta.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\n#include \"../number/eratosthenes_sieve.hpp\"\ntemplate<typename T>\nVec<T> divisorsZeta(const Vec<T>& xs, bool subset)\n{\n    const int N = (int)xs.size();\n    auto ys = xs;\n    for (const int p : EratosthenesSieve{N}.primes()) {\n        if (subset) {\n            for (int i = 1; i * p < N; i++) { ys[i * p] += ys[i]; }\n        } else {\n            for (int i = (N - 1) / p; i >= 1; i--) { ys[i] += ys[i * p]; }\n        }\n    }\n    return ys;\n}\n",
        "result": "ALL_AC"
    },
    "formal_dirichlet_series/gcd_convolution.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\n#include \"divisors_moebius.hpp\"\n#include \"divisors_zeta.hpp\"\ntemplate<typename T>\nVec<T> gcdConvolute(const Vec<T>& f, const Vec<T>& g)\n{\n    const int N = (int)std::min(f.size(), g.size());\n    auto F = divisorsZeta(f, false), G = divisorsZeta(g, false);\n    F.resize(N), G.resize(N);\n    for (int i : rep(N)) { F[i] *= G[i]; }\n    return divisorsMoebius(F, false);\n}\n",
        "result": "ALL_AC"
    },
    "formal_dirichlet_series/lcm_convolution.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\n#include \"divisors_moebius.hpp\"\n#include \"divisors_zeta.hpp\"\ntemplate<typename T>\nVec<T> lcmConvolute(const Vec<T>& f, const Vec<T>& g)\n{\n    const int N = (int)std::min(f.size(), g.size());\n    auto F = divisorsZeta(f, true), G = divisorsZeta(g, true);\n    F.resize(N), G.resize(N);\n    for (int i : rep(N)) { F[i] *= G[i]; }\n    return divisorsMoebius(F, true);\n}\n",
        "result": "ALL_AC"
    },
    "formal_power_series/berlekamp_massey.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\n\ntemplate<typename T>\nVec<T> berlekampMassey(const Vec<T>& A)\n{\n    const int N = (int)A.size();\n    Vec<T> B{1}, C{1};\n    T b = 1;\n    for (int j : irange(1, N + 1)) {\n        int m = (int)B.size(), l = (int)C.size();\n        T d = 0;\n        for (int i : rep(l)) { d += A[j - l + i] * C[i]; }\n        B.push_back(0), m++;\n        if (d == 0) { continue; }\n        const T c = -d / b;\n        if (l < m) {\n            auto temp = C;\n            C.insert(C.begin(), m - l, 0);\n            for (int i : rep(m)) { C[m - 1 - i] += c * B[m - 1 - i]; }\n            B = temp, b = d;\n        } else {\n            for (int i : rep(m)) { C[l - 1 - i] += c * B[m - 1 - i]; }\n        }\n    }\n    reverseAll(C);\n    return C;\n}\n",
        "result": "ALL_AC"
    },
    "formal_power_series/bostan_mori.hpp": {
        "code": "#pragma once\n#include \"formal_power_series.hpp\"\ntemplate<typename mint, typename I>\nmint bostanMori(FormalPowerSeries<mint> f, FormalPowerSeries<mint> g, I N)\n{\n    assert(not g.isZero());\n    const int f_zero = f.lsb(), g_zero = g.lsb();\n    assert(g_zero <= f_zero);\n    if (N < I(f_zero - g_zero)) { return 0; }\n    f <<= f_zero, g <<= g_zero;\n    N -= (f_zero - g_zero);\n    while (N > 0) {\n        f.shrink(N + 1), g.shrink(N + 1);\n        FormalPowerSeries<mint> mg;\n        for (int i : rep(g.size())) { mg[i] = g[i] * (i % 2 == 0 ? 1 : -1); }\n        const auto G = g * mg;\n        const auto F = f * mg;\n        for (int i : rep((F.size() + 1) / 2)) { f[i] = F.at(2 * i + (N % 2)); }\n        for (int i : rep((G.size() + 1) / 2)) { g[i] = G.at(2 * i); }\n        N /= 2;\n    }\n    return f[0] / g[0];\n}\n\ntemplate<typename mint, typename I>\nmint nthTermOfLinearRecurrentSequence(const Vec<mint>& as, I N)\n{\n    const FormalPowerSeries<mint> g{berlekampMassey(as)};\n    const int L = g.size();\n    const auto f = FormalPowerSeries<mint>{as}.mult(g, L - 1);\n    return bostanMori(f, g, N);\n}\n",
        "result": "ALL_AC"
    },
    "formal_power_series/formal_power_series.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\n#include \"../numerical/convolution.hpp\"\ntemplate<typename mint>\nclass FormalPowerSeries : public Vec<mint>\n{\n    using Vec<mint>::resize;\n    using Vec<mint>::push_back;\n    using Vec<mint>::pop_back;\n    using Vec<mint>::back;\n\npublic:\n    using typename Vec<mint>::vector;\n    FormalPowerSeries(const Vec<mint>& vs) : Vec<mint>{vs} { optimize(); }\n    int size() const { return (int)Vec<mint>::size(); }\n    int deg() const { return size() - 1; }\n    template<typename I>\n    void shrink(I n)\n    {\n        if (n >= (I)size()) { return; }\n        Vec<mint>::resize(n);\n        optimize();\n    }\n    template<typename I>\n    FormalPowerSeries low(I n) const\n    {\n        const I sz = std::min(n, (I)size());\n        return FormalPowerSeries{this->begin(), this->begin() + (int)sz};\n    }\n    mint& operator[](const int n)\n    {\n        if (n >= size()) { resize(n + 1, 0); }\n        return Vec<mint>::operator[](n);\n    }\n    template<typename I>\n    mint at(const I n) const\n    {\n        return (n < size() ? (*this)[n] : mint{0});\n    }\n    FormalPowerSeries operator-() const\n    {\n        FormalPowerSeries ans = *this;\n        for (auto& v : ans) { v = -v; }\n        return ans;\n    }\n    FormalPowerSeries& operator+=(const FormalPowerSeries& f)\n    {\n        for (int i : rep(f.size())) { (*this)[i] += f[i]; }\n        return *this;\n    }\n    FormalPowerSeries& operator-=(const FormalPowerSeries& f)\n    {\n        for (int i : rep(f.size())) { (*this)[i] -= f[i]; }\n        return *this;\n    }\n    FormalPowerSeries& operator*=(const FormalPowerSeries& f) { return (*this) = (*this) * f; }\n    FormalPowerSeries& operator<<=(const int s) { return *this = (*this << s); }\n    FormalPowerSeries& operator>>=(const int s) { return *this = (*this >> s); }\n    FormalPowerSeries operator+(const FormalPowerSeries& f) const\n    {\n        return FormalPowerSeries(*this) += f;\n    }\n    FormalPowerSeries operator-(const FormalPowerSeries& f) const\n    {\n        return FormalPowerSeries(*this) -= f;\n    }\n    FormalPowerSeries operator*(const FormalPowerSeries& f) const\n    {\n        return mult(f, size() + f.size() - 1);\n    }\n    FormalPowerSeries operator>>(int shift) const\n    {\n        FormalPowerSeries ans(size() + shift);\n        for (int i : rep(size())) { ans[i + shift] = (*this)[i]; }\n        return ans;\n    }\n    FormalPowerSeries operator<<(int shift) const\n    {\n        FormalPowerSeries ans;\n        for (int i : irange(shift, size())) { ans[i - shift] = (*this)[i]; }\n        return ans;\n    }\n    int lsb() const\n    {\n        for (int i : rep(size())) {\n            if ((*this)[i] != 0) { return i; }\n        }\n        return size();\n    }\n    bool isZero() const { return (size() == 1) and ((*this)[0] == 0); }\n    friend Ostream& operator<<(Ostream& os, const FormalPowerSeries& f)\n    {\n        return os << static_cast<Vec<mint>>(f);\n    }\n    FormalPowerSeries derivative() const\n    {\n        FormalPowerSeries ans;\n        for (int i : irange(1, size())) { ans[i - 1] = (*this)[i] * i; }\n        return ans;\n    }\n    FormalPowerSeries integral() const\n    {\n        FormalPowerSeries ans;\n        for (int i : irange(1, size() + 1)) { ans[i] = (*this)[i - 1] * mint::sinv(i); }\n        return ans;\n    }\n    FormalPowerSeries mult(const FormalPowerSeries& f, int size) const\n    {\n        assert(size > 0);\n        return FormalPowerSeries{convolute_mod(*this, f)}.low(size);\n    }\n    FormalPowerSeries inv(int size) const\n    {\n        assert(size > 0);\n        assert((*this)[0].val() != 0);\n        FormalPowerSeries g{(*this)[0].inv()};\n        for (int m = 1; m < size; m *= 2) {\n            auto f = low(m * 2);\n            g = (FormalPowerSeries{2} - f.mult(g, m * 2)).mult(g, 2 * m);\n        }\n        return g.low(size);\n    }\n    FormalPowerSeries log(int size) const\n    {\n        assert(size > 0);\n        assert((*this)[0] == 1);\n        return derivative().mult(inv(size), size).integral().low(size);\n    }\n    FormalPowerSeries exp(int size) const\n    {\n        assert(size > 0);\n        assert((*this)[0] == 0);\n        FormalPowerSeries g{1};\n        for (int m = 1; m < size; m *= 2) {\n            auto f = low(m * 2);\n            g = g.mult(FormalPowerSeries{1} - g.log(m * 2) + f, 2 * m);\n        }\n        return g.low(size);\n    }\n    template<typename I>\n    FormalPowerSeries pow(I n) const\n    {\n        return pow(n, deg() * n + 1);\n    }\n    template<typename I>\n    FormalPowerSeries pow(I n, int size) const\n    {\n        assert(size > 0);\n        if (n == 0) { return FormalPowerSeries{1}; }\n        if (isZero()) { return FormalPowerSeries{0}; }\n        const int k = lsb();\n        if (k >= ((I)size + n - 1) / n) { return FormalPowerSeries{}; }\n        size -= k * n;\n        auto f = ((*this) << k).low(size);\n        const mint c = f[0];\n        f *= FormalPowerSeries{c.inv()};\n        return ((f.log(size) * FormalPowerSeries{n}).exp(size) * FormalPowerSeries{c.pow(n)})\n               >> (k * n);\n    }\n\nprivate:\n    const mint& operator[](const int n) const\n    {\n        assert(n < size());\n        return Vec<mint>::operator[](n);\n    }\n    void optimize()\n    {\n        while (size() > 0) {\n            if (back() != 0) { return; }\n            pop_back();\n        }\n        if (size() == 0) { push_back(0); }\n    }\n};\n",
        "result": "ALL_AC"
    },
    "graph/bellman_ford.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\n#include \"graph.hpp\"\ntemplate<typename T>\nVec<T> bellmanFord(const Graph<T>& g, const int s)\n{\n    const int N = g.v();\n    assert(0 <= s and s < N);\n    Vec<T> ds(N, INF<T>);\n    ds[s] = 0;\n    for (int loop : rep(2 * N)) {\n        for (int u : rep(N)) {\n            if (ds[u] == INF<T>) { continue; }\n            for (const auto& e : g[u]) {\n                const int v = e.to;\n                const auto c = e.cost;\n                if (ds[v] <= ds[u] + c) { continue; }\n                ds[v] = ds[u] + c;\n                if (loop >= N - 1) { ds[v] = -INF<T>; }\n            }\n        }\n    }\n    return ds;\n}\n",
        "result": "ALL_AC"
    },
    "graph/bfs_01.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\n#include \"graph.hpp\"\ntemplate<typename T>\nVec<T> bfs01(const Graph<T>& g, int s)\n{\n    const int N = g.v();\n    assert(0 <= s and s < N);\n    Vec<T> ds(N, INF<T>);\n    using P = Pair<T, int>;\n    Deq<P> Q;\n    ds[s] = 0;\n    Q.push_front({T{}, s});\n    while (not Q.empty()) {\n        const auto [c, u] = Q.front();\n        Q.pop_front();\n        if (ds[u] < c) { continue; }\n        for (UNUSED const auto& [_, v, c] : g[u]) {\n            if (ds[v] <= ds[u] + c) { continue; }\n            ds[v] = ds[u] + c;\n            if (c == 0) {\n                Q.push_front({ds[v], v});\n            } else {\n                Q.push_back({ds[v], v});\n            }\n        }\n    }\n    return ds;\n}\n",
        "result": "NOT_TESTED"
    },
    "graph/dijkstra.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\n#include \"graph.hpp\"\ntemplate<typename T>\nVec<T> dijkstra(const Graph<T>& g, int s)\n{\n    const int N = g.v();\n    assert(0 <= s and s < N);\n    Vec<T> ds(N, INF<T>);\n    using P = Pair<T, int>;\n    MinHeap<P> Q;\n    ds[s] = 0;\n    Q.push({T{}, s});\n    while (not Q.empty()) {\n        const auto [c, u] = Q.top();\n        Q.pop();\n        if (ds[u] < c) { continue; }\n        for (UNUSED const auto& [_, v, c] : g[u]) {\n            if (ds[v] <= ds[u] + c) { continue; }\n            ds[v] = ds[u] + c;\n            Q.push({ds[v], v});\n        }\n    }\n    return ds;\n}\n",
        "result": "ALL_AC"
    },
    "graph/floyd_warshall.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\n#include \"graph.hpp\"\ntemplate<typename T>\nVec<Vec<T>> floydWarshall(const Graph<T>& g)\n{\n    const int N = g.v();\n    Vec<Vec<T>> dss(N, Vec<T>(N));\n    for (int i : rep(N)) {\n        for (int j : rep(N)) { dss[i][j] = (i == j ? T{} : INF<T>); }\n        for (UNUSED const auto& [_, j, c] : g[i]) { chmin(dss[i][j], c); }\n    }\n    for (int k : rep(N)) {\n        for (int i : rep(N)) {\n            for (int j : rep(N)) {\n                if (dss[i][k] != INF<T> and dss[k][j] != INF<T>) {\n                    chmin(dss[i][j], dss[i][k] + dss[k][j]);\n                }\n            }\n        }\n    }\n    return dss;\n}\n",
        "result": "ALL_AC"
    },
    "graph/graph.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\ntemplate<typename T = int>\nclass Graph\n{\n    struct Edge\n    {\n        Edge() = default;\n        Edge(int i, int t, T c) : id{i}, to{t}, cost{c} {}\n        int id;\n        int to;\n        T cost;\n        operator int() const { return to; }\n    };\n\npublic:\n    Graph(int n) : m_v{n}, m_edges(n) {}\n    void addEdge(int u, int v, bool bi = false)\n    {\n        assert(0 <= u and u < m_v);\n        assert(0 <= v and v < m_v);\n        m_edges[u].emplace_back(m_e, v, 1);\n        if (bi) { m_edges[v].emplace_back(m_e, u, 1); }\n        m_e++;\n    }\n    void addEdge(int u, int v, const T& c, bool bi = false)\n    {\n        assert(0 <= u and u < m_v);\n        assert(0 <= v and v < m_v);\n        m_edges[u].emplace_back(m_e, v, c);\n        if (bi) { m_edges[v].emplace_back(m_e, u, c); }\n        m_e++;\n    }\n    const Vec<Edge>& operator[](const int u) const\n    {\n        assert(0 <= u and u < m_v);\n        return m_edges[u];\n    }\n    Vec<Edge>& operator[](const int u)\n    {\n        assert(0 <= u and u < m_v);\n        return m_edges[u];\n    }\n    int v() const { return m_v; }\n    int e() const { return m_e; }\n    friend Ostream& operator<<(Ostream& os, const Graph& g)\n    {\n        for (int u : rep(g.v())) {\n            for (const auto& [id, v, c] : g[u]) {\n                os << \"[\" << id << \"]: \";\n                os << u << \"->\" << v << \"(\" << c << \")\\n\";\n            }\n        }\n        return os;\n    }\n    Vec<T> sizes(int root = 0) const\n    {\n        const int N = v();\n        assert(0 <= root and root < N);\n        Vec<T> ss(N, 1);\n        Fix([&](auto dfs, int u, int p) -> void {\n            for (UNUSED const auto& [_, v, c] : m_edges[u]) {\n                if (v == p) { continue; }\n                dfs(v, u);\n                ss[u] += ss[v];\n            }\n        })(root, -1);\n        return ss;\n    }\n    Vec<T> depths(int root = 0) const\n    {\n        const int N = v();\n        assert(0 <= root and root < N);\n        Vec<T> ds(N, 0);\n        Fix([&](auto dfs, int u, int p) -> void {\n            for (UNUSED const auto& [_, v, c] : m_edges[u]) {\n                if (v == p) { continue; }\n                ds[v] = ds[u] + c;\n                dfs(v, u);\n            }\n        })(root, -1);\n        return ds;\n    }\n    Vec<int> parents(int root = 0) const\n    {\n        const int N = v();\n        assert(0 <= root and root < N);\n        Vec<int> ps(N, -1);\n        Fix([&](auto dfs, int u, int p) -> void {\n            for (UNUSED const auto& [_, v, c] : m_edges[u]) {\n                if (v == p) { continue; }\n                ps[v] = u;\n                dfs(v, u);\n            }\n        })(root, -1);\n        return ps;\n    }\n\nprivate:\n    int m_v;\n    int m_e = 0;\n    Vec<Vec<Edge>> m_edges;\n};\n",
        "result": "ALL_AC"
    },
    "graph/low_link.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\n#include \"graph.hpp\"\ntemplate<typename T>\nclass LowLink\n{\n    using P = Pair<int, int>;\n\npublic:\n    LowLink(const Graph<T>& g) : m_v(g.v()), m_ords(m_v), m_lows(m_v), m_is_art(m_v)\n    {\n        const int N = g.v();\n        int ord = 0;\n        Vec<bool> used(N, false);\n        auto dfs = Fix([&](auto dfs, int u, int pe) -> void {\n            used[u] = true;\n            m_ords[u] = ord++;\n            m_lows[u] = m_ords[u];\n            bool is_art = false;\n            int dim = 0;\n            for (UNUSED const auto& [id, v, _] : g[u]) {\n                if (not used[v]) {\n                    dim++;\n                    dfs(v, id);\n                    chmin(m_lows[u], m_lows[v]);\n                    is_art |= (pe != -1 and m_ords[u] <= m_lows[v]);\n                    if (isBridge(u, v)) { m_bridges.push_back(std::minmax({u, v})); }\n                } else if (id != pe) {\n                    chmin(m_lows[u], m_ords[v]);\n                }\n            }\n            if (pe == -1) {\n                m_is_art[u] = (dim >= 2);\n            } else {\n                m_is_art[u] = is_art;\n            }\n        });\n        for (int i : rep(N)) {\n            if (not used[i]) { dfs(i, -1); }\n        }\n    }\n    bool isArt(int i) const\n    {\n        assert(0 <= i and i < m_v);\n        return m_is_art[i];\n    }\n    bool isBridge(int i, int j) const\n    {\n        assert(0 <= i and i < m_v);\n        assert(0 <= j and j < m_v);\n        if (m_ords[i] > m_ords[j]) { std::swap(i, j); }\n        return m_ords[i] < m_lows[j];\n    }\n    const Vec<P>& bridges() const { return m_bridges; }\n    const Vec<int>& arts() const { return m_arts; }\n\nprivate:\n    int m_v;\n    Vec<P> m_bridges;\n    Vec<int> m_arts;\n    Vec<int> m_ords;\n    Vec<int> m_lows;\n    Vec<bool> m_is_art;\n};\n",
        "result": "NOT_TESTED"
    },
    "graph/strongly_connected_components.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\n#include \"graph.hpp\"\ntemplate<typename T>\nclass StronglyConnectedComponents\n{\npublic:\n    StronglyConnectedComponents(const Graph<T>& g) : m_v(g.v()), m_cs(m_v, -1)\n    {\n        const int N = g.v();\n        Graph<> rg(N);\n        for (int u : rep(N)) {\n            for (int v : g[u]) { rg.addEdge(v, u); }\n        }\n        Vec<int> st;\n        Vec<bool> used(N, false);\n        auto dfs = Fix([&](auto dfs, int u) -> void {\n            used[u] = true;\n            for (int v : g[u]) {\n                if (not used[v]) { dfs(v); }\n            }\n            st.push_back(u);\n        });\n        auto rdfs = Fix([&](auto dfs, int v) -> void {\n            m_cs[v] = m_cnum;\n            for (int u : rg[v]) {\n                if (m_cs[u] != -1) { continue; }\n                dfs(u);\n            }\n        });\n        for (int i : rep(N)) {\n            if (used[i]) { continue; }\n            dfs(i);\n        }\n        reverseAll(st);\n        for (int i : st) {\n            if (m_cs[i] != -1) { continue; }\n            rdfs(i);\n            m_cnum++;\n        }\n    }\n    int operator[](int v) const\n    {\n        assert(0 <= v and v < m_v);\n        return m_cs[v];\n    }\n    int cnum() const { return m_cnum; }\n    Vec<Vec<int>> groups() const\n    {\n        Vec<Vec<int>> iss(m_v);\n        for (const int i : rep(m_v)) { iss[m_cs[i]].push_back(i); }\n        return iss;\n    }\n\nprivate:\n    int m_v;\n    int m_cnum = 0;\n    Vec<int> m_cs;\n};\n",
        "result": "ALL_AC"
    },
    "graph/topological_sort.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\n#include \"graph.hpp\"\ntemplate<typename T>\nPair<bool, Vec<int>> topologicalSort(const Graph<T>& g)\n{\n    const int N = g.v();\n    Vec<int> ans;\n    Vec<int> used(N, 0);\n    auto dfs = Fix([&](auto dfs, int s) -> bool {\n        if (used[s] == 1) {\n            return false;\n        } else if (used[s] == 0) {\n            used[s] = 1;\n            for (int to : g[s]) {\n                if (not dfs(to)) { return false; }\n            }\n            used[s] = 2;\n            ans.push_back(s);\n        }\n        return true;\n    });\n    for (int i : rep(N)) {\n        if (not dfs(i)) { return {false, ans}; }\n    }\n    reverseAll(ans);\n    return {true, ans};\n}\n",
        "result": "ALL_AC"
    },
    "graph/tree/centroid_decomposition.hpp": {
        "code": "#pragma once\n#include \"../../common.hpp\"\n#include \"../graph.hpp\"\ntemplate<typename T>\nclass CentroidDecomposition\n{\npublic:\n    CentroidDecomposition(const Graph<T>& g) : m_cs(g.v())\n    {\n        const int N = g.v();\n        Vec<int> szs(N, 1);\n        Vec<bool> used(N, false);\n        auto sizeDfs = Fix([&](auto dfs, int u, int p) -> int {\n            szs[u] = 1;\n            for (int v : g[u]) {\n                if (v == p or used[v]) { continue; }\n                szs[u] += dfs(v, u);\n            }\n            return szs[u];\n        });\n        auto getCentor = Fix([&](auto dfs, int u, int p, int tot) -> int {\n            for (int v : g[u]) {\n                if (v == p or used[v]) { continue; }\n                if (szs[v] * 2 > tot) { return dfs(v, u, tot); }\n            }\n            if (tot == N) { m_center = u; }\n            return u;\n        });\n        Fix([&](auto dfs, int u, int pc) -> void {\n            const int tot = sizeDfs(u, -1);\n            const int c = getCentor(u, -1, tot);\n            used[c] = true;\n            if (pc != -1) { m_cs.addEdge(pc, c); }\n            for (int v : g[c]) {\n                if (not used[v]) { dfs(v, c); }\n            }\n        })(0, -1);\n    }\n    int center() const { return m_center; }\n    const Graph<>& centers() const { return m_cs; }\n\nprivate:\n    int m_center;\n    Graph<> m_cs;\n};\n",
        "result": "ALL_AC"
    },
    "graph/tree/diameter.hpp": {
        "code": "#pragma once\n#include \"../../common.hpp\"\n#include \"../graph.hpp\"\nnamespace diameter_impl {\ntemplate<typename T>\nstruct Edge\n{\n    Edge(int i, int f, int t, T c) : id{i}, from{f}, to{t}, cost{c} {}\n    Edge(const Edge&) = default;\n    int id;\n    int from, to;\n    T cost;\n};\n};  // namespace diameter_impl\ntemplate<typename T>\nVec<diameter_impl::Edge<T>> diameter(const Graph<T>& g)\n{\n    auto ds = g.depths(0);\n    auto ps = g.parents(0);\n    const int s = maxInd(ds);\n    ds = g.depths(s);\n    ps = g.parents(s);\n    const int t = maxInd(ds);\n    Vec<diameter_impl::Edge<T>> es;\n    for (int u = t; ps[u] != -1; u = ps[u]) {\n        for (const auto& [id, v, c] : g[u]) {\n            if (v == ps[u]) { es.emplace_back(id, u, v, c); }\n        }\n    }\n    return es;\n}\n",
        "result": "ALL_AC"
    },
    "graph/tree/heavy_light_decomposition.hpp": {
        "code": "#pragma once\n#include \"../../common.hpp\"\n#include \"../graph.hpp\"\ntemplate<typename T>\nclass HeavyLightDecomposition\n{\n    using P = Pair<int, int>;\n\npublic:\n    HeavyLightDecomposition(Graph<T>& g, int r = 0)\n        : m_v(g.v()),\n          m_ps(m_v, -1),\n          m_tops(m_v, -1),\n          m_ords(m_v, -1),\n          m_ins(m_v, -1),\n          m_outs(m_v, -1)\n    {\n        const int N = g.v();\n        Vec<int> szs(N, 1);\n        Fix([&](auto dfs, int u, int p) -> int {\n            m_ps[u] = p;\n            for (int i : rep(g[u].size())) {\n                const int v = g[u][i];\n                if (p == v) { continue; }\n                szs[u] += dfs(v, u);\n                if (szs[(int)g[u][0]] < szs[v]) { std::swap(g[u][0], g[u][i]); }\n            }\n            return szs[u];\n        })(r, -1);\n        m_tops[r] = r;\n        int index = 0;\n        Fix([&](auto dfs, int u, int p) -> void {\n            m_ins[u] = index++;\n            m_outs[u] = m_ins[u] + szs[u];\n            m_ords[m_ins[u]] = u;\n            for (int i : rep(g[u].size())) {\n                const int v = g[u][i];\n                if (v == p) { continue; }\n                if (i == 0) {\n                    m_tops[v] = m_tops[u];\n                } else {\n                    m_tops[v] = v;\n                }\n                dfs(v, u);\n            }\n        })(r, -1);\n    }\n    int pos(int v) const\n    {\n        assert(0 <= v and v < m_v);\n        return m_ins[v];\n    }\n    int at(int n) const\n    {\n        assert(0 <= n and n < m_v);\n        return m_ords[n];\n    }\n    P sub(int v) const\n    {\n        assert(0 <= v and v < m_v);\n        return {m_ins[v], m_outs[v]};\n    }\n    Vec<P> path(int u, int v) const\n    {\n        assert(0 <= u and u < m_v);\n        assert(0 <= v and v < m_v);\n        Vec<P> head, tail;\n        for (int pu = m_tops[u], pv = m_tops[v]; pu != pv;) {\n            if (m_ins[pu] < m_ins[pv]) {\n                tail.push_back({m_ins[pv], m_ins[v]});\n                v = m_ps[pv];\n                pv = m_tops[v];\n            } else {\n                head.push_back({m_ins[u], m_ins[pu]});\n                u = m_ps[pu];\n                pu = m_tops[u];\n            }\n        }\n        head.push_back({m_ins[u], m_ins[v]});\n        reverseAll(tail);\n        for (const auto& p : tail) { head.push_back(p); }\n        return head;\n    }\n\nprivate:\n    int m_v;\n    Vec<int> m_ps;\n    Vec<int> m_tops;\n    Vec<int> m_ords;\n    Vec<int> m_ins, m_outs;\n};\n",
        "result": "ALL_AC"
    },
    "graph/tree/least_common_ancestor.hpp": {
        "code": "#pragma once\n#include \"../../data_structure/sparse_table/static_rmq.hpp\"\n#include \"../../common.hpp\"\n#include \"../graph.hpp\"\ntemplate<typename C>\nclass LowestCommonAncestor\n{\n    using P = Pair<int, int>;\n\npublic:\n    LowestCommonAncestor(const Graph<C>& g, int r = 0)\n        : m_v(g.v()),\n          m_ins(g.v(), 0),\n          m_ds([&]() {\n              Vec<P> ans;\n              Vec<bool> used(g.v(), false);\n              Fix([&](auto dfs, const P& s) -> void {\n                  const int u = s.second;\n                  used[u] = true;\n                  m_ins[u] = ans.size();\n                  ans.push_back(s);\n                  for (int v : g[u]) {\n                      if (used[v]) { continue; }\n                      dfs(P{s.first + 1, v});\n                      ans.push_back(s);\n                  }\n              })(P{0, r});\n              return ans;\n          }()),\n          m_rmq(m_ds)\n    {}\n    int operator()(int u, int v) const\n    {\n        const auto [ul, vl] = std::minmax({m_ins[u], m_ins[v]});\n        return m_rmq.fold(ul, vl + 1).second;\n    }\n\nprivate:\n    struct Ord\n    {\n        using T = P;\n        bool operator()(const T& p1, const T& p2) const { return p1 < p2; }\n    };\n    int m_v;\n    Vec<int> m_ins;\n    Vec<P> m_ds;\n    StaticRMQ<Ord> m_rmq;\n};\n",
        "result": "ALL_AC"
    },
    "graph/tree/level_ancestor.hpp": {
        "code": "#pragma once\n#include \"../../common.hpp\"\n#include \"../graph.hpp\"\nclass LevelAncestor\n{\npublic:\n    template<typename T>\n    LevelAncestor(const Graph<T>& g, int r = 0) : m_v(g.v()), m_ds(m_v, 0), m_ps(m_v)\n    {\n        Fix([&](auto dfs, int u, int p) -> void {\n            for (int k = 1; (1 << k) <= m_ds[u]; k++) {\n                m_ps[u].push_back(m_ps[m_ps[u][k - 1]][k - 1]);\n            }\n            for (int v : g[u]) {\n                if (v == p) { continue; }\n                m_ds[v] = m_ds[u] + 1;\n                m_ps[v].push_back(u);\n                dfs(v, u);\n            }\n        })(r, -1);\n    };\n    int lca(int u, int v) const\n    {\n        assert(0 <= u and u < m_v);\n        assert(0 <= v and v < m_v);\n        if (m_ds[u] > m_ds[v]) { std::swap(u, v); }\n        v = (*this)(v, m_ds[v] - m_ds[u]);\n        if (u == v) { return u; }\n        while (true) {\n            if (m_ps[u][0] == m_ps[v][0]) { return m_ps[u][0]; }\n            for (int i = m_ps[u].size() - 1; i >= 0; i--) {\n                const int nu = m_ps[u][i], nv = m_ps[v][i];\n                if (nu != nv) {\n                    u = nu, v = nv;\n                    break;\n                }\n            }\n        }\n    }\n    int operator()(int v, int d) const\n    {\n        assert(0 <= v and v < m_v);\n        for (int k = (int)bitWidth(d); k >= 0; k--) {\n            if (isBitOn(d, k)) { v = m_ps[v][k]; }\n        }\n        return v;\n    }\n\nprivate:\n    int m_v;\n    Vec<int> m_ds;\n    Vec<Vec<int>> m_ps;\n};\n",
        "result": "ALL_AC"
    },
    "graph/two_edge_connected_components.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\n#include \"low_link.hpp\"\ntemplate<typename T>\nclass TwoEdgeConnectedComponent : public LowLink<T>\n{\npublic:\n    using LowLink<T>::LowLink;\n    using LowLink<T>::isBridge;\n    using LowLink<T>::bridges;\n    TwoEdgeConnectedComponent(const Graph<T>& g) : LowLink<T>(g), m_v(g.v()), m_cs(g.v(), -1)\n    {\n        auto dfs = Fix([&](auto dfs, int u) -> void {\n            m_cs[u] = m_cnum;\n            for (int v : g[u]) {\n                if (isBridge(u, v) or m_cs[v] != -1) { continue; }\n                dfs(v);\n            }\n        });\n        for (int i : rep(g.v())) {\n            if (m_cs[i] != -1) { continue; }\n            dfs(i);\n            m_cnum++;\n        }\n    }\n    int operator[](int v) const\n    {\n        assert(0 <= v and v < m_v);\n        return m_cs[v];\n    }\n    int cnum() const { return m_cnum; }\n    Vec<Vec<int>> groups() const\n    {\n        Vec<Vec<int>> iss(m_v);\n        for (int i : rep(m_v)) { iss[m_cs[i]].push_back(i); }\n        return iss;\n    }\n\nprivate:\n    int m_v;\n    int m_cnum = 0;\n    Vec<int> m_cs;\n};\n",
        "result": "NOT_TESTED"
    },
    "header.hpp": {
        "code": "#pragma once\n#include \"common.hpp\"\n#include \"utility/scanner.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/nd_vec.hpp\"\n#include \"utility/bin_search.hpp\"\n#include \"utility/modint.hpp\"\n#include \"graph/graph.hpp\"\n",
        "result": "NOT_TESTED"
    },
    "linear_algebra/bit_bases.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\ntemplate<int D>\nclass BitBases\n{\n    using T = BSet<D>;\n\npublic:\n    BitBases() { fillAll(m_vis, -1); }\n    bool add(const T& v_)\n    {\n        auto v = v_;\n        T mask = 0;\n        auto less = [&](const T& v1, const T& v2) -> bool {\n            const int i = (v1 ^ v2)._Find_first();\n            return v2[i];\n        };\n        for (int i : rep(m_reduced_bases.size())) {\n            if (less(v ^ m_reduced_bases[i], v)) {\n                v ^= m_reduced_bases[i];\n                mask ^= m_masks[i];\n            }\n        }\n        if (v.count()) {\n            const int vi = m_reduced_bases.size();\n            mask.set(vi);\n            m_orig_bases.push_back(v_);\n            m_reduced_bases.push_back(v);\n            m_masks.push_back(mask);\n            for (int j : irange(D - 1, -1, -1)) {\n                if (v[j]) {\n                    m_vis[j] = vi;\n                    break;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    const Vec<T>& origBases() const { return m_orig_bases; }\n    const Vec<T>& reducedBases() const { return m_reduced_bases; }\n    int rank() const { return m_reduced_bases.size(); }\n    Pair<bool, T> decomp(T v) const\n    {\n        T mask = 0;\n        for (int j : per(D)) {\n            if (v[j]) {\n                if (m_vis[j] == -1) { return {false, T{}}; }\n                const int vi = m_vis[j];\n                v ^= m_reduced_bases[vi];\n                mask ^= m_masks[vi];\n            }\n        }\n        assert(v.count() == 0);\n        return {true, mask};\n    }\n\nprivate:\n    Vec<T> m_orig_bases;     // \u5143\u306e\u5165\u529b\u306b\u3088\u308b\u57fa\u5e95\n    Vec<T> m_reduced_bases;  // \u7e2e\u7d04\u3055\u308c\u305f\u57fa\u5e95\n    Vec<T> m_masks;          // m_reduced[i]\u3092m_orig\u3067\u4f5c\u308b\u305f\u3081\u306e\u4fc2\u6570\n    Arr<int, D> m_vis;\n};\n",
        "result": "ALL_AC"
    },
    "linear_algebra/dynamic_matrix.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\ntemplate<typename T>\nclass DynamicMatrix\n{\n    template<typename V>\n    using IList = std::initializer_list<V>;\n\npublic:\n    DynamicMatrix(const int row, const int column)\n        : m_row{row}, m_column{column}, m_vss(row, Vec<T>(column, T{}))\n    {}\n    DynamicMatrix(const IList<IList<T>>& vss)\n        : m_row{(int)vss.size()},\n          m_column{(int)(vss.begin()->size())},\n          m_vss(m_row, Vec<T>(m_column, T{}))\n    {\n        int i = 0;\n        for (auto it = vss.begin(); it != vss.end(); it++) {\n            std::copy(it->begin(), it->end(), m_vss[i++].begin());\n        }\n    }\n    const Vec<T>& operator[](const int r) const\n    {\n        assert(0 <= r and r < m_row);\n        return m_vss[r];\n    }\n    Vec<T>& operator[](const int r)\n    {\n        assert(0 <= r and r < m_row);\n        return m_vss[r];\n    }\n    friend DynamicMatrix operator-(const DynamicMatrix& m)\n    {\n        DynamicMatrix ans(m.m_row, m.m_column);\n        for (int i : rep(m.m_row)) {\n            for (int j : rep(m.m_column)) { ans[i][j] = -m[i][j]; }\n        }\n        return ans;\n    }\n    friend DynamicMatrix operator+(const DynamicMatrix& m1, const DynamicMatrix& m2)\n    {\n        assert(m1.m_row == m2.m_row);\n        assert(m1.m_column == m2.m_column);\n        DynamicMatrix ans(m1.m_row, m1.m_column);\n        for (int i : rep(m1.m_row)) {\n            for (int j : rep(m1.m_column)) { ans[i][j] = m1[i][j] + m2[i][j]; }\n        }\n        return ans;\n    }\n    friend DynamicMatrix operator-(const DynamicMatrix& m1, const DynamicMatrix& m2)\n    {\n        assert(m1.m_row == m2.m_row);\n        assert(m1.m_column == m2.m_column);\n        DynamicMatrix ans(m1.m_row, m1.m_column);\n        for (int i : rep(m1.m_row)) {\n            for (int j : rep(m1.m_column)) { ans[i][j] = m1[i][j] - m2[i][j]; }\n        }\n        return ans;\n    }\n    friend DynamicMatrix operator*(const DynamicMatrix& m1, const DynamicMatrix& m2)\n    {\n        assert(m1.m_column == m2.m_row);\n        DynamicMatrix ans(m1.m_row, m2.m_column);\n        for (int i : rep(m1.m_row)) {\n            for (int j : rep(m2.m_column)) {\n                for (int k : rep(m1.m_column)) { ans[i][j] += m1[i][k] * m2[k][j]; }\n            }\n        }\n        return ans;\n    }\n    friend DynamicMatrix operator*(const DynamicMatrix& m, const T& t)\n    {\n        DynamicMatrix ans(m.m_row, m.m_column);\n        for (int i : rep(m.m_row)) {\n            for (int j : rep(m.m_column)) { ans[i][j] = m[i][j] * t; }\n        }\n        return ans;\n    }\n    friend DynamicMatrix operator/(const DynamicMatrix& m, const T& t)\n    {\n        DynamicMatrix ans(m.m_row, m.m_column);\n        for (int i : rep(m.m_row)) {\n            for (int j : rep(m.m_column)) { ans[i][j] = m[i][j] / t; }\n        }\n        return ans;\n    }\n    friend DynamicMatrix operator*(const T& t, const DynamicMatrix& m) { return m * t; }\n    friend DynamicMatrix& operator+=(DynamicMatrix& m1, const DynamicMatrix& m2)\n    {\n        return m1 = m1 + m2;\n    }\n    friend DynamicMatrix& operator-=(DynamicMatrix& m1, const DynamicMatrix& m2)\n    {\n        return m1 = m1 - m2;\n    }\n    friend DynamicMatrix& operator*=(DynamicMatrix& m1, const DynamicMatrix& m2)\n    {\n        return m1 = m1 * m2;\n    }\n    friend DynamicMatrix& operator*=(DynamicMatrix& m, const T& t) { return m = m * t; }\n    friend DynamicMatrix& operator/=(DynamicMatrix& m, const T& t) { return m = m / t; }\n    friend Ostream& operator<<(Ostream& os, const DynamicMatrix& m)\n    {\n        os << \"[\\n\";\n        for (int i : rep(m.m_row)) {\n            os << \"[\";\n            for (int j : rep(m.m_column)) { os << m[i][j] << \",\"; }\n            os << \"]\\n\";\n        }\n        return (os << \"]\\n\");\n    }\n    template<typename N>\n    DynamicMatrix pow(N n) const\n    {\n        assert(m_row == m_column);\n        return powerMonoid(*this, n, DynamicMatrix::I(m_row));\n    }\n    static DynamicMatrix I(int N)\n    {\n        DynamicMatrix ans(N, N);\n        for (int i : rep(N)) { ans[i][i] = 1; }\n        return ans;\n    }\n    int row() const { return m_row; }\n    int column() const { return m_column; }\n\nprivate:\n    int m_row, m_column;\n    Vec<Vec<T>> m_vss;\n};\n",
        "result": "ALL_AC"
    },
    "linear_algebra/int_bases.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\ntemplate<typename T = u64>\nclass IntBases\n{\n    static constexpr int D = sizeof(T) * 8;\n\npublic:\n    IntBases() { fillAll(m_vis, -1); }\n    bool add(const T& v)\n    {\n        auto reduced_v = v;\n        T mask = 0;\n        for (int i : rep(m_reduced_bases.size())) {\n            if (chmin(reduced_v, reduced_v ^ m_reduced_bases[i])) { mask ^= m_masks[i]; }\n        }\n        if (reduced_v) {\n            const int vi = m_reduced_bases.size();\n            mask ^= (T{1} << vi);\n            m_orig_bases.push_back(v), m_reduced_bases.push_back(reduced_v);\n            m_masks.push_back(mask);\n            for (int j : per(D)) {\n                if (isBitOn(reduced_v, j)) {\n                    m_vis[j] = vi;\n                    break;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    const Vec<T>& origBases() const { return m_orig_bases; }\n    const Vec<T>& reducedBases() const { return m_reduced_bases; }\n    int rank() const { return m_reduced_bases.size(); }\n    Pair<bool, T> decomp(T v) const\n    {\n        T mask = 0;\n        for (int j : irange(D - 1, -1, -1)) {\n            if (isBitOn(v, j)) {\n                if (m_vis[j] == -1) { return {false, 0}; }\n                const int vi = m_vis[j];\n                v ^= m_reduced_bases[vi];\n                mask ^= m_masks[vi];\n            }\n        }\n        assert(v == 0);\n        return {true, mask};\n    }\n\nprivate:\n    Vec<T> m_orig_bases;     // \u5143\u306e\u5165\u529b\u306b\u3088\u308b\u57fa\u5e95\n    Vec<T> m_reduced_bases;  // \u7e2e\u7d04\u3055\u308c\u305f\u57fa\u5e95\n    Vec<T> m_masks;          // m_reduced[i]\u3092m_orig\u3067\u4f5c\u308b\u305f\u3081\u306e\u4fc2\u6570\n    Arr<int, D> m_vis;\n};\n",
        "result": "ALL_AC"
    },
    "linear_algebra/static_matrix.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\ntemplate<typename T, int row, int column>\nclass StaticMatrix\n{\n    template<typename V>\n    using IList = std::initializer_list<V>;\n\npublic:\n    StaticMatrix()\n    {\n        for (auto& vs : m_vss) { fillAll(vs, T{}); }\n    }\n    StaticMatrix(const IList<IList<T>>& vss)\n    {\n        assert(row == vss.size());\n        assert(column == vss.begin()->size());\n        int i = 0;\n        for (auto it = vss.begin(); it != vss.end(); it++) {\n            std::copy(it->begin(), it->end(), m_vss[i++].begin());\n        }\n    }\n    StaticMatrix(const StaticMatrix& m) : m_vss{m.m_vss} {}\n    StaticMatrix& operator=(const StaticMatrix& m)\n    {\n        for (const int i : rep(row)) {\n            for (const int j : rep(column)) { m_vss[i][j] = m[i][j]; }\n        }\n        return *this;\n    }\n    const Arr<T, column>& operator[](const int r) const { return m_vss[r]; }\n    Arr<T, column>& operator[](const int r) { return m_vss[r]; }\n    friend StaticMatrix operator-(const StaticMatrix& m)\n    {\n        StaticMatrix ans;\n        for (const int r : rep(row)) {\n            for (const int c : rep(column)) { ans[r][c] = -m[r][c]; }\n        }\n        return ans;\n    }\n    friend StaticMatrix operator+(const StaticMatrix& m1, const StaticMatrix& m2)\n    {\n        StaticMatrix ans;\n        for (const int r : rep(row)) {\n            for (const int c : rep(column)) { ans[r][c] = m1[r][c] + m2[r][c]; }\n        }\n        return ans;\n    }\n    friend StaticMatrix operator-(const StaticMatrix& m1, const StaticMatrix& m2)\n    {\n        StaticMatrix ans;\n        for (const int r : rep(row)) {\n            for (const int c : rep(column)) { ans[r][c] = m1[r][c] - m2[r][c]; }\n        }\n        return ans;\n    }\n    template<int c>\n    friend StaticMatrix operator*(const StaticMatrix<T, row, c>& m1,\n                                  const StaticMatrix<T, c, column>& m2)\n    {\n        StaticMatrix<T, row, column> ans;\n        for (const int i : rep(row)) {\n            for (const int j : rep(column)) {\n                for (const int k : rep(c)) { ans[i][j] += m1[i][k] * m2[k][j]; }\n            }\n        }\n        return ans;\n    }\n    friend StaticMatrix operator*(const StaticMatrix& m, const T& t)\n    {\n        StaticMatrix ans;\n        for (const int r : rep(row)) {\n            for (const int c : rep(column)) { ans[r][c] = m[r][c] * t; }\n        }\n        return ans;\n    }\n    friend StaticMatrix operator/(const StaticMatrix& m, const T& t)\n    {\n        StaticMatrix ans;\n        for (const int r : rep(row)) {\n            for (const int c : rep(column)) { ans[r][c] = m[r][c] / t; }\n        }\n        return ans;\n    }\n    friend StaticMatrix operator*(const T& t, const StaticMatrix& m) { return m * t; }\n    friend StaticMatrix& operator+=(StaticMatrix& m1, const StaticMatrix& m2)\n    {\n        return m1 = m1 + m2;\n    }\n    friend StaticMatrix& operator-=(StaticMatrix& m1, const StaticMatrix& m2)\n    {\n        return m1 = m1 - m2;\n    }\n    friend StaticMatrix& operator*=(StaticMatrix& m1, const StaticMatrix& m2)\n    {\n        return m1 = m1 * m2;\n    }\n    friend StaticMatrix& operator*=(StaticMatrix& m, const T& t) { return m = m * t; }\n    friend StaticMatrix& operator/=(StaticMatrix& m, const T& t) { return m = m / t; }\n    friend std::ostream& operator<<(std::ostream& os, const StaticMatrix& m)\n    {\n        os << \"[\\n\";\n        for (const int i : rep(row)) {\n            os << \"[\";\n            for (const int j : rep(column)) { os << m[i][j] << \",\"; }\n            os << \"]\\n\";\n        }\n        return (os << \"]\");\n    }\n    template<typename Int>\n    StaticMatrix pow(Int n) const\n    {\n        return powerMonoid(*this, n, I());\n    }\n    static StaticMatrix I()\n    {\n        static_assert(row == column, \"StaticMatrix::I() should be rectangular!\");\n        StaticMatrix ans;\n        for (const int i : rep(row)) { ans[i][i] = 1; }\n        return ans;\n    }\n\nprivate:\n    Arr<Arr<T, column>, row> m_vss;\n};\n",
        "result": "ALL_AC"
    },
    "number/discrete_log.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\n#include \"../utility/int_nthroot.hpp\"\n#include \"../algorithm/babystep_giantstep.hpp\"\n\ntemplate<typename mint>\ninline i64 discreteLog(mint X, mint Y)\n{\n    static_assert(mint::isDynamic(), \"Only dynamic-modint supportted!\");\n    i64 P = mint::mod();\n    if (P == 1) { return 0; }\n    if (X == 0) { return (Y == 1 ? 0 : (Y == 0 ? 1 : -1)); }\n\n    mint pX = 1;\n    const int offset = bitWidth(P);\n    for (int d : rep(offset)) {\n        if (pX == Y) { return d; }\n        pX *= X;\n    }\n    const i64 g = std::gcd((i64)pX.val(), P);\n    if (Y.val() % g != 0) { return -1; }\n    const i64 nP = P / g;\n    mint::setMod(nP);\n    const mint npX = pX.val();\n    const mint nX = X.val(), nY = npX.inv() * Y.val();\n    const i64 W = intNthRoot(nP, 2);\n    const mint nXW = nX.pow(W), nXI = nX.inv();\n    auto f_wtimes = [&](i64 x) { return (nXW * x).val(); };\n    auto f_inv = [&](i64 x) { return (nXI * x).val(); };\n    const i64 n\n        = (nY == 1 ? 0_i64\n                   : babyStepGiantStep(f_wtimes, f_inv, (i64)nX.val(), (i64)nY.val(), nP, W));\n    mint::setMod(P);\n\n    if (n == -1) { return -1; }\n    return offset + n;\n}\n",
        "result": "ALL_AC"
    },
    "number/divisors.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\ntemplate<typename T>\nVec<T> divisors(const T n)\n{\n    Vec<T> head, tail;\n    for (T i = 1; i * i <= n; i++) {\n        if (n % i == 0) {\n            head.push_back(i);\n            if (i * i != n) { tail.push_back(n / i); }\n        }\n    }\n    reverseAll(tail);\n    concat(head, tail);\n    return head;\n}\n",
        "result": "ALL_AC"
    },
    "number/eratosthenes_sieve.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\nclass EratosthenesSieve\n{\npublic:\n    EratosthenesSieve(int N) : m_N{N}, m_factors{iotaVec(N)}\n    {\n        for (int i : irange(2, N)) {\n            if (m_factors[i] != i) { continue; }\n            for (int j : irange(i + i, N, i)) { m_factors[j] = i; }\n        }\n    }\n    int maxPrimeFactor(int x) const\n    {\n        assert(1 < x and x < m_N);\n        return m_factors[x];\n    }\n    bool isPrime(int x) const\n    {\n        assert(x < m_N);\n        if (x <= 1) { return false; }\n        return m_factors[x] == x;\n    }\n    Vec<int> primes() const\n    {\n        Vec<int> ps;\n        for (int i : irange(2, m_N)) {\n            if (m_factors[i] == i) { ps.push_back(i); }\n        }\n        return ps;\n    }\n    Map<int, int> primeFactors(int x) const\n    {\n        assert(1 <= x and x < m_N);\n        Map<int, int> fs;\n        while (x > 1) {\n            const int p = m_factors[x];\n            fs[p]++;\n            x /= p;\n        }\n        return fs;\n    }\n\nprivate:\n    int m_N;\n    Vec<int> m_factors;\n};\n",
        "result": "ALL_AC"
    },
    "number/garner.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\nclass Garner\n{\npublic:\n    template<typename mint, typename mint1, typename mint2>\n    static mint restore_mod(const mint1& x1, const mint2& x2)\n    {\n        constexpr auto m1 = mint1::mod();\n        const auto [y0, y1] = coeff(x1, x2);\n        return mint(y0.val()) + mint(y1.val()) * m1;\n    }\n    template<typename mint, typename mint1, typename mint2, typename mint3>\n    static mint restore_mod(const mint1& x1, const mint2& x2, const mint3& x3)\n    {\n        constexpr auto m1 = mint1::mod();\n        constexpr auto m2 = mint2::mod();\n        const auto [y0, y1, y2] = coeff(x1, x2, x3);\n        return mint(y0.val()) + mint(y1.val()) * m1 + mint(y2.val()) * m1 * m2;\n    }\n    template<typename mint1, typename mint2>\n    static i64 restore_i64(const mint1& x1, const mint2& x2)\n    {\n        constexpr u32 m1 = mint1::mod();\n        constexpr u32 m2 = mint2::mod();\n        const auto [y0, y1] = coeff(x1, x2);\n        constexpr u64 MAX = 1_u64 << 63;\n        const i128 M = (i128)m1 * m2;\n        i128 S = i128(y0.val()) + i128(y1.val()) * m1;\n        if (S >= MAX) { S -= M; }\n        return (i64)S;\n    }\n    template<typename mint1, typename mint2, typename mint3>\n    static i64 restore_i64(const mint1& x1, const mint2& x2, const mint3& x3)\n    {\n        constexpr u32 m1 = mint1::mod();\n        constexpr u32 m2 = mint2::mod();\n        constexpr u32 m3 = mint3::mod();\n        const auto [y0, y1, y2] = coeff(x1, x2, x3);\n        constexpr u64 MAX = 1_u64 << 63;\n        const i128 M = (i128)m1 * m2 * m3;\n        i128 S = i128(y0.val()) + i128(y1.val()) * m1 + i128(y2.val()) * m1 * m2;\n        if (S >= MAX) { S -= M; }\n        return (i64)S;\n    }\n\nprivate:\n    template<typename mint1, typename mint2>\n    static Pair<mint1, mint2> coeff(const mint1& x1, const mint2& x2)\n    {\n        constexpr auto m1 = mint1::mod();\n        constexpr mint2 m1_inv = mint2(m1).inv();\n        const mint1 y0 = x1;\n        const mint2 y1 = (x2 - mint2(y0.val())) * m1_inv;\n        return {y0, y1};\n    }\n    template<typename mint1, typename mint2, typename mint3>\n    static Tup<mint1, mint2, mint3> coeff(const mint1& x1, const mint2& x2, const mint3& x3)\n    {\n        constexpr auto m1 = mint1::mod();\n        constexpr auto m2 = mint2::mod();\n        constexpr mint2 m1_inv = mint2(m1).inv();\n        constexpr mint3 m1m2_inv = (mint3(m1) * mint3(m2)).inv();\n        const mint1 y0 = x1;\n        const mint2 y1 = (x2 - mint2(y0.val())) * m1_inv;\n        const mint3 y2 = (x3 - mint3(y0.val()) - mint3(y1.val()) * m1) * m1m2_inv;\n        return {y0, y1, y2};\n    }\n};\n",
        "result": "ALL_AC"
    },
    "number/miller_rabin.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\n#include \"../utility/modint.hpp\"\n#include \"../utility/modint64.hpp\"\ntemplate<typename mint>\nbool millerRabin(u64 n, const Vec<u64>& as)\n{\n    auto d = n - 1;\n    for (; (d & 1) == 0; d >>= 1) {}\n    for (const u64 a : as) {\n        if (n <= a) { break; }\n        auto s = d;\n        mint x = mint(a).pow(s);\n        while (x.val() != 1 and x.val() != n - 1 and s != n - 1) { x *= x, s <<= 1; }\n        if (x.val() != n - 1 and s % 2 == 0) { return false; }\n    }\n    return true;\n}\ninline bool isPrime(u64 n)\n{\n    using mint = modint_dynamic<873293817>;\n    using mint64 = modint64_dynamic<828271328>;\n    if (n == 1) { return false; }\n    if ((n & 1) == 0) { return n == 2; }\n    if (n < (1ULL << 30)) {\n        mint::setMod(n);\n        return millerRabin<mint>(n, {2, 7, 61});\n    } else {\n        mint64::setMod(n);\n        return millerRabin<mint64>(n, {2, 325, 9375, 28178, 450775, 9780504});\n    }\n}\n",
        "result": "ALL_AC"
    },
    "number/mod_nthroot.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\n#include \"../algorithm/ext_gcd.hpp\"\n#include \"prime_factors.hpp\"\ntemplate<typename mint>\nmint modNthRoot(mint A, i64 k)\n{\n    const i64 P = mint::mod();\n    assert(P > 0);\n    if (A == 0) { return 0; }\n    if (k == 0) { return A; }\n    const i64 g = std::gcd(P - 1, k);\n    if (A.pow((P - 1) / g).val() != 1) { return 0; }\n    A = A.pow(inverse(k / g, (P - 1) / g));\n    if (g == 1) { return A; }\n    const auto fs = primeFactors(g);\n    for (const auto& [p, e] : fs) {\n        i64 pe = 1;\n        LOOP (e) { pe *= p; }\n        i64 q = P - 1, Q = 0;\n        while (q % p == 0) { q /= p, Q++; }\n        auto [y, z] = extgcd(-q, pe);\n        if (y <= 0) { y += pe, z += q; }\n        mint X = A.pow(z);\n        if ((int)Q == e) {\n            A = X;\n            continue;\n        }\n        mint Eraser = 1;\n        const i64 h = (P - 1) / p;\n        for (mint Z = 2;; Z += 1) {\n            if (Z.pow(h) != 1) {\n                Eraser = Z.pow(q);\n                break;\n            }\n        }\n        mint Error = A.pow(y * q);\n        mint pEraser = Eraser;\n        LOOP (Q - 1) { pEraser = pEraser.pow(p); }\n        const mint ipEraser = pEraser.inv();\n        UMap<i64, i64> memo;\n        {\n            const i64 M = std::max(1_i64, (i64)(std::sqrt(p) * std::sqrt(Q - e)));\n            const i64 B = std::max(1_i64, ((i64)p - 1) / M);\n            const mint ppEraser = pEraser.pow(B);\n            mint prod = 1;\n            for (i64 i = 0; i < (i64)p; i += B, prod *= ppEraser) { memo[prod.val()] = i; }\n        }\n        while (Error.val() != 1) {\n            i64 l = 0;\n            mint pError = Error;\n            for (i64 i : rep(Q)) {\n                const auto npError = pError.pow(p);\n                if (npError == 1) {\n                    l = Q - (i + 1);\n                    break;\n                }\n                pError = npError;\n            }\n            i64 c = -1;\n            {\n                mint small = pError.inv();\n                for (i64 j = 0;; j++, small *= ipEraser) {\n                    if (memo.count(small.val())) {\n                        const i64 i = memo[small.val()];\n                        c = i + j;\n                        break;\n                    }\n                }\n            }\n            auto pEraser2 = Eraser.pow(c);\n            LOOP (l - e) { pEraser2 = pEraser2.pow(p); }\n            X *= pEraser2, Error *= pEraser2.pow(pe);\n        }\n        A = X;\n    }\n    return A;\n}\n",
        "result": "ALL_AC"
    },
    "number/mod_sqrt.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\ntemplate<typename mint>\nmint modsqrt(const mint& A)\n{\n    const u64 P = mint::mod();\n    if (A == 0) { return 0; }\n    if (P == 2) { return 1; }\n    const u64 h = (P - 1) >> 1;\n    if (A.pow(h).val() != 1) { return 0; }\n    u64 q = P - 1, Q = 0;\n    while ((q & 1) == 0) { q >>= 1, Q++; }\n    mint Eraser = 1;\n    for (mint Z = 2;; Z += 1) {\n        if (Z.pow(h) != 1) {\n            Eraser = Z.pow(q);\n            break;\n        }\n    }\n    mint Error = A.pow(q), X = A.pow((q + 1) / 2);\n    while (Error.val() != 1) {\n        u64 l = 0;\n        mint pError = Error;\n        for (u64 i = 0; i < Q; i++, pError *= pError) {\n            if (pError.val() == 1) {\n                l = Q - i;\n                break;\n            }\n        }\n        mint pEraser = Eraser;\n        for (u64 i = 0; i < l - 1; i++, pEraser *= pEraser) {}\n        X *= pEraser, Error *= (pEraser * pEraser);\n    }\n    return X;\n}\n",
        "result": "ALL_AC"
    },
    "number/multiplicative_prefix_sum.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\n#include \"prime_power_sum.hpp\"\ntemplate<typename T, typename F, u32 MAXD = 2>\nclass MultiplicativePrefixSum : public PrimePowerSum<T, MAXD>\n{\n    using PrimePowerSum<T>::id;\n    using PrimePowerSum<T>::m_ps;\n    using PrimePowerSum<T>::m_ns;\n    using PrimePowerSum<T>::m_hss;\n\npublic:\n    MultiplicativePrefixSum(u64 N, F f, const Arr<T, MAXD + 1>& coeffs)\n        : PrimePowerSum<T>{N}, m_buf(m_ns.size(), 0), m_f{f}\n    {\n        for (u32 i : rep(m_buf.size())) {\n            for (u32 d : rep(MAXD + 1)) { m_buf[i] += coeffs[d] * m_hss[d][i]; }\n        }\n    }\n    T get(u64 n) const\n    {\n        T ans = m_buf[id(n)] + 1;\n        for (u32 i : rep(m_ps.size())) { ans += dfs(i, 1, m_ps[i], n / m_ps[i], 1); }\n        return ans;\n    }\n\nprivate:\n    T dfs(u32 i, u32 c, u64 v, u64 lim, T fv) const\n    {\n        T ans = fv * m_f(m_ps[i] * v, m_ps[i], c + 1);\n        if (lim >= m_ps[i] * m_ps[i]) { ans += dfs(i, c + 1, m_ps[i] * v, lim / m_ps[i], fv); }\n        fv *= m_f(v, m_ps[i], c);\n        ans += fv * (m_buf[id(lim)] - m_buf[id(m_ps[i])]);\n        for (u32 j = i + 1; j < m_ps.size() and m_ps[j] * m_ps[j] <= lim; j++) {\n            ans += dfs(j, 1, m_ps[j], lim / m_ps[j], fv);\n        }\n        return ans;\n    }\n    Vec<T> m_buf;\n    F m_f;\n};\n",
        "result": "ALL_AC"
    },
    "number/prime_factors.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\n#include \"../utility/rng.hpp\"\n#include \"miller_rabin.hpp\"\ntemplate<typename mint>\nu64 pollardRho(u64 n)\n{\n    if (n % 2 == 0) { return 2; }\n    if (isPrime(n)) { return n; }\n    mint c;\n    auto f = [&](const mint& x) { return x * x + c; };\n    while (true) {\n        mint x, y, ys, q = 1;\n        y = rng64.val<u64>(0, n - 2) + 2;\n        c = rng64.val<u64>(0, n - 2) + 2;\n        u64 d = 1;\n        constexpr u32 dk = 128;\n        for (u32 r = 1; d == 1; r <<= 1) {\n            x = y;\n            for (u32 i = 0; i < r; i++) { y = f(y); }\n            for (u32 k = 0; k < r and d == 1; k += dk) {\n                ys = y;\n                for (u32 i = 0; i < dk and i < r - k; i++) { q *= x - (y = f(y)); }\n                d = std::gcd((u64)q.val(), n);\n            }\n        }\n        if (d == n) {\n            do {\n                d = std::gcd(u64((x - (ys = f(ys))).val()), n);\n            } while (d == 1);\n        }\n        if (d != n) { return d; }\n    }\n    return n;\n}\nMap<u64, int> primeFactors(u64 n)\n{\n    using mint = modint_dynamic<287687412>;\n    using mint64 = modint64_dynamic<4832432>;\n    Map<u64, int> ans;\n    Fix([&](auto dfs, u64 x) -> void {\n        while ((x & 1) == 0) { x >>= 1, ans[2]++; }\n        if (x == 1) { return; }\n        u64 p;\n        if (x < (1ULL << 30)) {\n            mint::setMod(x);\n            p = pollardRho<mint>(x);\n        } else {\n            mint64::setMod(x);\n            p = pollardRho<mint64>(x);\n        }\n        if (p == x) {\n            ans[p]++;\n            return;\n        }\n        dfs(p), dfs(x / p);\n    })(n);\n    return ans;\n}\nVec<u64> divisors(const u64 n)\n{\n    const auto fs = primeFactors(n);\n    Vec<u64> ds{1};\n    for (const auto& [p, e] : fs) {\n        u64 pe = p;\n        const u32 dn = ds.size();\n        for (i32 i = 0; i < e; i++, pe *= p) {\n            for (u32 j = 0; j < dn; j++) { ds.push_back(ds[j] * pe); }\n        }\n    }\n    return ds;\n}\n",
        "result": "ALL_AC"
    },
    "number/prime_power_sum.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\ntemplate<typename T, u32 MAXD = 2>\nclass PrimePowerSum\n{\npublic:\n    PrimePowerSum(u64 N) : m_N{N}, m_sqrt{(u32)std::sqrt(N)}, m_ns{0}\n    {\n        assert(N >= 2);\n        for (u64 i = N; i > 0; i = N / (N / i + 1)) { m_ns.push_back(i); }\n        for (const auto n : m_ns) {\n            const T x = n;\n            m_hss[0].push_back(x - 1);\n            m_hss[1].push_back(x * (x + 1) / 2 - 1);\n            m_hss[2].push_back(x * (x + 1) * (x * 2 + 1) / 6 - 1);\n        }\n        for (u32 x = 2; x <= m_sqrt; x++) {\n            if (m_hss[0][m_ns.size() - x] == m_hss[0][m_ns.size() - x + 1]) { continue; }\n            m_ps.push_back(x);\n            const u64 y = (u64)x * x;\n            for (u32 i = 1; i < m_ns.size(); i++) {\n                const u64 n = m_ns[i];\n                if (n < y) { break; }\n                const u32 j = (i * x <= m_sqrt ? i * x : m_ns.size() - n / x);\n                const u32 k = m_ns.size() - x + 1;\n                m_hss[0][i] -= (m_hss[0][j] - m_hss[0][k]);\n                m_hss[1][i] -= (m_hss[1][j] - m_hss[1][k]) * x;\n                m_hss[2][i] -= (m_hss[2][j] - m_hss[2][k]) * x * x;\n            }\n        }\n    }\n    T get(u32 d, u64 n) const\n    {\n        const u32 i = id(n);\n        assert(m_ns[i] == n);\n        return m_hss[d][i];\n    }\n\nprotected:\n    u32 id(u64 x) const { return x <= m_sqrt ? m_ns.size() - x : m_N / x; }\n    u64 m_N;\n    u32 m_sqrt;\n    Vec<u64> m_ns, m_ps;\n    Arr<Vec<T>, MAXD + 1> m_hss;\n};\n",
        "result": "ALL_AC"
    },
    "numerical/convolution.hpp": {
        "code": "#pragma once\n#include \"number_theoritic_transform.hpp\"\n#include \"../number/garner.hpp\"\n#include \"../utility/modint.hpp\"\ntemplate<typename mint>\nVec<mint> convolute_mod(const Vec<mint>& as, const Vec<mint>& bs)\n{\n    constexpr u32 L_MAX = mint::max2p();\n    constexpr int N_MAX = (1 << L_MAX);\n    const int AN = as.size();\n    const int BN = bs.size();\n    if (AN == 0 or BN == 0) { return {}; }\n    if (AN > BN) { return convolute_mod(bs, as); }\n    const int N = AN + BN - 1;\n    if (AN * 2 <= BN) {\n        Vec<mint> cs(N, 0);\n        for (int sj : irange(0, BN, AN)) {\n            const int tj = std::min(BN, sj + AN);\n            const auto bbs = Vec<mint>(std::begin(bs) + sj, std::begin(bs) + tj);\n            const auto bcs = convolute_mod(as, bbs);\n            for (int dj : rep(bcs.size())) { cs[sj + dj] += bcs[dj]; }\n        }\n        return cs;\n    }\n    if (N <= N_MAX) {\n        // mint\u306fNTT Friendly\u306a\u306e\u3067\u305d\u306e\u307e\u307e\u7573\u307f\u8fbc\u307f\n        return NumberTheoriticTransform<mint>::convolute(as, bs);\n    } else {\n        assert(N <= (1 << 24));\n        using submint1 = modint<469762049, 3, 26>;\n        using submint2 = modint<167772161, 3, 25>;\n        using submint3 = modint<754974721, 11, 24>;\n        // mod 3\u3064\u3067Garner\u5fa9\u5143\n        Vec<submint1> as1(AN), bs1(BN);\n        Vec<submint2> as2(AN), bs2(BN);\n        Vec<submint3> as3(AN), bs3(BN);\n        for (int i : rep(AN)) { as1[i] = as[i].val(), as2[i] = as[i].val(), as3[i] = as[i].val(); }\n        for (int i : rep(BN)) { bs1[i] = bs[i].val(), bs2[i] = bs[i].val(), bs3[i] = bs[i].val(); }\n        const auto cs1 = NumberTheoriticTransform<submint1>::convolute(as1, bs1);\n        const auto cs2 = NumberTheoriticTransform<submint2>::convolute(as2, bs2);\n        const auto cs3 = NumberTheoriticTransform<submint3>::convolute(as3, bs3);\n        Vec<mint> cs(N);\n        for (int i : rep(N)) { cs[i] = Garner::restore_mod<mint>(cs1[i], cs2[i], cs3[i]); }\n        return cs;\n    }\n}\ntemplate<typename I>\nVec<i64> convolute_i64(const Vec<I>& as, const Vec<I>& bs)\n{\n    const int AN = as.size();\n    const int BN = bs.size();\n    if (AN == 0 or BN == 0) { return {}; }\n    if (AN > BN) { return convolute_i64<I>(bs, as); }\n    const int N = AN + BN - 1;\n    assert(N <= (1 << 24));\n    if (AN * 2 <= BN) {\n        Vec<i64> cs(N, 0);\n        for (int sj : irange(0, BN, AN)) {\n            const int tj = std::min(BN, sj + AN);\n            const auto bbs = Vec<I>(std::begin(bs) + sj, std::begin(bs) + tj);\n            const auto bcs = convolute_i64<I>(as, bbs);\n            for (int dj : rep(bcs.size())) { cs[sj + dj] += bcs[dj]; }\n        }\n        return cs;\n    }\n    using submint1 = modint<469762049, 3, 26>;\n    using submint2 = modint<167772161, 3, 25>;\n    using submint3 = modint<754974721, 11, 24>;\n    // mod 3\u3064\u3067Garner\u5fa9\u5143\n    Vec<submint1> as1(AN), bs1(BN);\n    Vec<submint2> as2(AN), bs2(BN);\n    Vec<submint3> as3(AN), bs3(BN);\n    for (int i : rep(AN)) { as1[i] = as[i], as2[i] = as[i], as3[i] = as[i]; }\n    for (int i : rep(BN)) { bs1[i] = bs[i], bs2[i] = bs[i], bs3[i] = bs[i]; }\n    const auto cs1 = NumberTheoriticTransform<submint1>::convolute(as1, bs1);\n    const auto cs2 = NumberTheoriticTransform<submint2>::convolute(as2, bs2);\n    const auto cs3 = NumberTheoriticTransform<submint3>::convolute(as3, bs3);\n    Vec<i64> cs(N);\n    for (int i : rep(N)) { cs[i] = Garner::restore_i64(cs1[i], cs2[i], cs3[i]); }\n    return cs;\n}\n",
        "result": "ALL_AC"
    },
    "numerical/number_theoritic_transform.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\ntemplate<typename mint>\nclass NumberTheoriticTransform\n{\n    // DynamicModint \u975e\u5bfe\u5fdc\n    static_assert(not mint::isDynamic(), \"class NTT: Not support dynamic modint.\");\n\nprivate:\n    static constexpr u32 MOD = mint::mod();\n    static constexpr u32 ROOT = mint::root();\n    static constexpr u32 L_MAX = mint::max2p();\n    static constexpr int N_MAX = (1 << L_MAX);\n\npublic:\n    static Vec<mint> convolute(Vec<mint> as, Vec<mint> bs)\n    {\n        const int AN = as.size();\n        const int BN = bs.size();\n        const int CN = AN + BN - 1;\n        const int N = bitCeil(CN);\n        as.resize(N, 0), bs.resize(N, 0);\n        transform(as, false), transform(bs, false);\n        for (int i : rep(N)) { as[i] *= bs[i]; }\n        transform(as, true);\n        as.resize(CN);\n        return as;\n    }\n    static void transform(Vec<mint>& as, bool rev)\n    {\n        const int N = as.size();\n        assert(hasSingleBit(N));\n        if (N == 1) { return; }\n        const int L = topBit(N);\n        const auto l_range = (rev ? irange(1, L + 1, 1) : irange(L, 0, -1));\n        for (int l : l_range) {\n            const int H = 1 << l;\n            const int B = N / H;\n            for (int b : rep(B)) {\n                const mint W = zeta(l, rev);\n                mint W_h = 1;\n                for (int h : rep(H / 2)) {\n                    const int y1 = H * b + h;\n                    const int y2 = y1 + H / 2;\n                    const mint a1 = as[y1];\n                    const mint a2 = as[y2];\n                    const mint na1 = (rev ? a1 + a2 * W_h : a1 + a2);\n                    const mint na2 = (rev ? a1 - a2 * W_h : (a1 - a2) * W_h);\n                    as[y1] = na1;\n                    as[y2] = na2;\n                    W_h *= W;\n                }\n            }\n        }\n        if (rev) {\n            const mint iN = mint::sinv(N);\n            for (auto& a : as) { a *= iN; }\n        }\n    }\n\nprivate:\n    static mint zeta(int i, bool rev)\n    {\n        static Vec<mint> zs;   // zs[i] = 1\u306e2^i\u4e57\u6839\n        static Vec<mint> izs;  // izs[i] = zs[i]\u306e\u9006\u5143\n        if (zs.empty()) {\n            zs.resize(L_MAX + 1, 1);\n            izs.resize(L_MAX + 1, 1);\n            zs[L_MAX] = mint(ROOT).pow((MOD - 1) / (1 << L_MAX));\n            izs[L_MAX] = zs[L_MAX].inv();\n            for (int l : per(L_MAX)) {\n                zs[l] = zs[l + 1] * zs[l + 1];\n                izs[l] = izs[l + 1] * izs[l + 1];\n            }\n        }\n        return (rev ? izs[i] : zs[i]);\n    }\n};\n",
        "result": "ALL_AC"
    },
    "polynomial/lagrange_extrapolate.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\n\ntemplate<typename mint>\nmint lagrangeExtrapolate(const Vec<mint>& ys, const mint& X)\n{\n    const int N = ys.size();\n    const int x = X.val();\n    if (x < N) { return ys[x]; }\n    Vec<mint> ls(N, 1), rs(N, 1);\n    for (int i : rep(N - 1)) { ls[i + 1] = ls[i] * (X - i); }\n    for (int i : per(N - 1)) { rs[i] = rs[i + 1] * (X - i - 1); }\n    Vec<mint> Fs(N);\n    Vec<mint> Gs(N);\n    for (int i : rep(N)) {\n        Fs[i] = ys[i] * mint::ifact(i) * mint::ifact(N - 1 - i) * ((N - 1 - i) % 2 == 0 ? 1 : -1);\n        Gs[i] = ls[N - 1 - i] * rs[N - 1 - i];\n    }\n    mint ans = 0;\n    for (int i : rep(N)) { ans += Fs[i] * Gs[N - 1 - i]; }\n    return ans;\n}\n",
        "result": "NOT_TESTED"
    },
    "polynomial/polynomial.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\n#include \"../numerical/convolution.hpp\"\ntemplate<typename mint>\nclass Polynomial : public Vec<mint>\n{\n    using Vec<mint>::resize;\n    using Vec<mint>::push_back;\n    using Vec<mint>::pop_back;\n    using Vec<mint>::back;\n\npublic:\n    using Vec<mint>::vector;\n    Polynomial(const Vec<mint>& vs) : Vec<mint>{vs} { optimize(); }\n    int size() const { return (int)Vec<mint>::size(); }\n    int deg() const { return size() - 1; }\n    mint& operator[](const int n)\n    {\n        if (n >= size()) { resize(n + 1, 0); }\n        return Vec<mint>::operator[](n);\n    }\n    template<typename I>\n    mint at(const I n) const\n    {\n        return (n < size() ? (*this)[n] : mint{0});\n    }\n    Polynomial operator-() const\n    {\n        Polynomial ans = *this;\n        for (auto& v : ans) { v = -v; }\n        return ans;\n    }\n    Polynomial& operator+=(const Polynomial& f)\n    {\n        for (int i : rep(f.size())) { (*this)[i] += f[i]; }\n        return *this;\n    }\n    Polynomial& operator-=(const Polynomial& f)\n    {\n        for (int i : rep(f.size())) { (*this)[i] -= f[i]; }\n        return *this;\n    }\n    Polynomial& operator*=(const Polynomial& f) { return (*this) = (*this) * f; }\n    Polynomial operator+(const Polynomial& f) const { return Polynomial(*this) += f; }\n    Polynomial operator-(const Polynomial& f) const { return Polynomial(*this) -= f; }\n    Polynomial operator*(const Polynomial& f) const { return mult(f, size() + f.size() - 1); }\n    bool isZero() const { return (size() == 1) and ((*this)[0] == 0); }\n    friend Ostream& operator<<(Ostream& os, const Polynomial& f)\n    {\n        return os << static_cast<Vec<mint>>(f);\n    }\n    Polynomial mult(const Polynomial& f) const { return Polynomial{convolute_mod(*this, f)}; }\n    template<typename I>\n    Polynomial pow(I n) const\n    {\n        return powerMonoid(*this, n, {1});\n    }\n    mint eval(const mint& x) const\n    {\n        mint ans = 0;\n        mint p = 1;\n        for (int i : rep(size())) {\n            ans += p * (*this)[i];\n            p *= x;\n        }\n        return ans;\n    }\n\nprivate:\n    const mint& operator[](const int n) const\n    {\n        assert(n < size());\n        return Vec<mint>::operator[](n);\n    }\n    void optimize()\n    {\n        while (size() > 0) {\n            if (back() != 0) { return; }\n            pop_back();\n        }\n        if (size() == 0) { push_back(0); }\n    }\n};\n",
        "result": "NOT_TESTED"
    },
    "set_power_series/and_convolution.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\n#include \"set_moebius.hpp\"\n#include \"set_zeta.hpp\"\ntemplate<typename T>\nVec<T> andConvolute(Vec<T> f, Vec<T> g)\n{\n    const int N = bitCeil(std::max(f.size(), g.size()));\n    f.resize(N), g.resize(N);\n    auto F = setZeta(f, false), G = setZeta(g, false);\n    for (int i : rep(N)) { F[i] *= G[i]; }\n    return setMoebius(F, false);\n}\n",
        "result": "ALL_AC"
    },
    "set_power_series/or_convolution.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\n#include \"and_convolution.hpp\"\ntemplate<typename T>\nVec<T> orConvolute(Vec<T> f, Vec<T> g)\n{\n    const int N = bitCeil(std::max(f.size(), g.size()));\n    f.resize(N), g.resize(N);\n    auto F = setZeta(f, true), G = setZeta(g, true);\n    for (int i : rep(N)) { F[i] *= G[i]; }\n    return setMoebius(F, true);\n}\n",
        "result": "ALL_AC"
    },
    "set_power_series/set_hadamard.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\ntemplate<typename T>\nVec<T> setHadamard(const Vec<T>& xs, bool rev = false)\n{\n    const int N = bitCeil(xs.size());\n    Vec<T> ys(N);\n    for (int i : rep(xs.size())) { ys[i] = xs[i]; }\n    for (int i = 1; i < N; i <<= 1) {\n        for (int j : rep(N)) {\n            if ((j & i) == 0) {\n                const T x = ys[j], y = ys[j | i];\n                ys[j] = x + y, ys[j | i] = x - y;\n            }\n        }\n    }\n    if (rev) {\n        const T iN = T{1} / N;\n        for (auto& y : ys) { y *= iN; }\n    }\n    return ys;\n}\n",
        "result": "ALL_AC"
    },
    "set_power_series/set_moebius.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\ntemplate<typename T>\nVec<T> setMoebius(const Vec<T>& xs, bool subset)\n{\n    const int N = bitCeil(xs.size());\n    Vec<T> ys(N);\n    for (int i : rep(xs.size())) { ys[i] = xs[i]; }\n    for (int i = 1; i < N; i <<= 1) {\n        for (int j : rep(N)) {\n            if ((j & i) == 0) {\n                if (subset) {\n                    ys[j | i] -= ys[j];\n                } else {\n                    ys[j] -= ys[j | i];\n                }\n            }\n        }\n    }\n    return ys;\n}\n",
        "result": "ALL_AC"
    },
    "set_power_series/set_zeta.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\ntemplate<typename T>\nVec<T> setZeta(const Vec<T>& xs, const bool subset)\n{\n    const int N = bitCeil(xs.size());\n    Vec<T> ys(N);\n    for (int i : rep(xs.size())) { ys[i] = xs[i]; }\n    for (int i = 1; i < N; i <<= 1) {\n        for (int j : rep(N)) {\n            if ((j & i) == 0) {\n                if (subset) {\n                    ys[j | i] += ys[j];\n                } else {\n                    ys[j] += ys[j | i];\n                }\n            }\n        }\n    }\n    return ys;\n}\n",
        "result": "ALL_AC"
    },
    "set_power_series/subset_convolution.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\ntemplate<typename T>\nVec<T> subsetConvolute(const Vec<T>& f, const Vec<T>& g)\n{\n    const int l = topBit(bitCeil(std::max(f.size(), g.size())));\n    const int N = 1 << l;\n    auto F = Vec<Vec<T>>(N, Vec<T>(l + 1, 0));\n    auto G = Vec<Vec<T>>(N, Vec<T>(l + 1, 0));\n    for (int i : rep(f.size())) { F[i][popCount(i)] += f[i]; }\n    for (int i : rep(g.size())) { G[i][popCount(i)] += g[i]; }\n    for (int i = 1; i < N; i <<= 1) {\n        for (int j : rep(N)) {\n            if ((j & i) == 0) {\n                for (int k : rep(l + 1)) {\n                    F[j | i][k] += F[j][k];\n                    G[j | i][k] += G[j][k];\n                }\n            }\n        }\n    }\n    auto H = Vec<Vec<T>>(N, Vec<T>(l + 1, 0));\n    for (int i : rep(N)) {\n        for (int j : rep(l + 1)) {\n            for (int k : rep(l + 1)) {\n                if (j + k > l) { continue; }\n                H[i][j + k] += F[i][j] * G[i][k];\n            }\n        }\n    }\n    for (int i = 1; i < N; i <<= 1) {\n        for (int j : rep(N)) {\n            if ((j & i) == 0) {\n                for (int k : rep(l + 1)) { H[j | i][k] -= H[j][k]; }\n            }\n        }\n    }\n    Vec<T> ans(N);\n    for (int i : rep(N)) { ans[i] = H[i][popCount(i)]; }\n    return ans;\n}\n",
        "result": "ALL_AC"
    },
    "set_power_series/xor_convolution.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\n#include \"set_hadamard.hpp\"\ntemplate<typename T>\nVec<T> xorConvolute(Vec<T> f, Vec<T> g)\n{\n    const int N = bitCeil(std::max(f.size(), g.size()));\n    f.resize(N), g.resize(N);\n    auto F = setHadamard(f, false), G = setHadamard(g, false);\n    for (int i : rep(N)) { F[i] *= G[i]; }\n    return setHadamard(F, true);\n}\n",
        "result": "ALL_AC"
    },
    "string/manacher.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\ntemplate<typename V>\nVec<int> manacher(const V& vs)\n{\n    const int N = std::size(vs);\n    Vec<int> ans(N);\n    for (int i = 0, k = 1, j = 0; i < N; i += k, j -= k, k = 1) {\n        while (i >= j and i + j < N and vs[i - j] == vs[i + j]) { ++j; }\n        ans[i] = j;\n        while (i >= k and i + k < N and k + ans[i - k] < j) {\n            ans[i + k] = ans[i - k];\n            k++;\n        }\n    }\n    return ans;\n}\n",
        "result": "ALL_AC"
    },
    "string/morris_pratt.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\ntemplate<typename V>\nVec<int> morrisPratt(const V& vs)\n{\n    const int N = std::size(vs);\n    Vec<int> A(N + 1, -1);\n    for (int i = 0, j = -1; i < N; i++) {\n        while (j != -1 and vs[i] != vs[j]) { j = A[j]; }\n        j = (j == -1 ? 0 : j + 1);\n        A[i + 1] = j;\n    }\n    return A;\n}\n",
        "result": "ALL_AC"
    },
    "string/rolling_hash.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\nclass RollingHash\n{\npublic:\n    template<typename V>\n    RollingHash(const V& vs, u64 base)\n        : m_size(std::size(vs)), m_ps(m_size + 1, 1), m_hs(m_size + 1, 0), m_base{base}\n    {\n        for (int i : irange(1, m_size + 1)) {\n            m_ps[i] = mod(mul(m_ps[i - 1], m_base)),\n            m_hs[i] = mod(mul(m_hs[i - 1], m_base) + vs[i - 1]);\n        }\n    }\n    u64 operator()(int l, int r) const { return mod(m_hs[r] + offset - mul(m_hs[l], m_ps[r - l])); }\n    template<typename C>\n    void pushBack(C c)\n    {\n        m_size++;\n        m_ps.push_back(mod(mul(m_ps.back(), m_base)));\n        m_hs.push_back(mod(mul(m_hs.back(), m_base) + c));\n    }\n\nprivate:\n    static constexpr u64 mask30 = (1_u64 << 30) - 1;\n    static constexpr u64 mask31 = (1_u64 << 31) - 1;\n    static constexpr u64 mask61 = (1_u64 << 61) - 1;\n    static constexpr u64 offset = mask61 * 7_u64;\n    static constexpr u64 mod(u64 x)\n    {\n        const u64 y = (x >> 61) + (x & mask61);\n        return y >= mask61 ? y - mask61 : y;\n    }\n    static constexpr u64 mul(u64 x, u64 y)\n    {\n        const u64 xh = x >> 31, xl = x & mask31;\n        const u64 yh = y >> 31, yl = y & mask31;\n        const u64 z = xl * yh + xh * yl;\n        const u64 zh = z >> 30, zl = z & mask30;\n        return xh * yh * 2 + zh + (zl << 31) + xl * yl;\n    }\n    int m_size;\n    Vec<u64> m_ps, m_hs;\n    u64 m_base;\n};\n",
        "result": "NOT_TESTED"
    },
    "string/suffix_array.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\n\ntemplate<typename V>\nVec<int> suffixArray(const V& vs)\n{\n    const int N = std::size(vs);\n    const int B = *std::max_element(ALL(vs)) + 1;\n    auto val = [&](int i) { return (i == N ? 0 : vs[i] + 1); };\n    Vec<bool> is_s(N + 1, true);\n    for (int i : per(N)) { is_s[i] = val(i) == val(i + 1) ? is_s[i + 1] : val(i) < val(i + 1); }\n    auto isS = [&](int i) { return is_s[i]; };\n    auto isL = [&](int i) { return not isS(i); };\n    auto isLms = [&](int i) { return i > 0 and isL(i - 1) and isS(i); };\n    auto sameLmsSubstr = [&](int i, int j) {\n        if (val(i++) != val(j++)) { return false; }\n        while (i <= N and j <= N) {\n            if (val(i) != val(j)) { return false; }\n            if (isLms(i)) { i = N; }\n            if (isLms(j)) { j = N; }\n            i++, j++;\n        }\n        return i >= N and j >= N;\n    };\n    Vec<int> poss = Vec<int>(B + 2, 0);\n    for (int i : rep(N + 1)) { poss[val(i) + 1]++; }\n    for (int b : rep(B + 1)) { poss[b + 1] += poss[b]; }\n\n    Vec<int> sa(N + 1, -1);\n    auto inducedSort = [&](const Vec<int>& lmss) {\n        fillAll(sa, -1);\n        Vec<int> inds = Vec<int>(B + 1, 0);\n        auto pushL = [&](int i) {\n            if (i >= 0 and isL(i)) { sa[inds[val(i)]++] = i; }\n        };\n        auto pushS = [&](int i) {\n            if (i >= 0 and isS(i)) { sa[--inds[val(i)]] = i; }\n        };\n        // \u4e0b\u304b\u3089LMS\u3092\u8a70\u3081\u308b\n        for (int b : rep(B + 1)) { inds[b] = poss[b + 1]; }\n        std::for_each(std::rbegin(lmss), std::rend(lmss), [&](int lms) { pushS(lms); });\n        // \u4e0a\u304b\u3089L\u3092\u8a70\u3081\u308b\n        for (int b : rep(B + 1)) { inds[b] = poss[b]; }\n        for (int i : rep(N + 1)) { pushL(sa[i] - 1); }\n        // \u4e0b\u304b\u3089S\u3092\u8a70\u3081\u308b\n        for (int b : irange(1, B + 1)) { inds[b] = poss[b + 1]; }\n        for (int i : per(N + 1)) { pushS(sa[i] - 1); }\n    };\n\n    Vec<int> lmss;  // LMS\u3092\u767b\u5834\u9806\u306b\u8a70\u3081\u305f\u3082\u306e\n    for (int i : rep(N + 1)) {\n        if (isLms(i)) { lmss.push_back(i); }\n    }\n    const int LMS = lmss.size();\n    inducedSort(lmss);  // \u30c6\u30ad\u30c8\u30fc\u306b\u4e00\u56deIS\n    if (LMS > 1) {\n        Vec<int> nlmss;  // LMS Substr\u306e\u4e2d\u8eab\u3067\u30bd\u30fc\u30c8\u3057\u305fLMS\n        for (int i : rep(N + 1)) {\n            if (isLms(sa[i])) { nlmss.push_back(sa[i]); }\n        }\n        Vec<int> kinds(N + 1, 0);\n        for (int ii : irange(1, LMS)) {\n            const int lms = nlmss[ii], plms = nlmss[ii - 1];\n            kinds[lms] = kinds[plms] + 1;\n            if (sameLmsSubstr(plms, lms)) { kinds[lms]--; }\n        }\n        Vec<int> sub_vs(LMS);\n        for (int i : rep(LMS)) { sub_vs[i] = kinds[lmss[i]]; }\n        // LMS\u3092\u30bd\u30fc\u30c8\u3059\u308b\n        const auto lmss_ords = suffixArray(sub_vs);\n        for (int i : rep(LMS)) { nlmss[i] = lmss[lmss_ords[i]]; }\n        // \u6b63\u3057\u3044LMS\u9806\u3067IS\n        inducedSort(nlmss);\n    }\n    return Vec<int>(std::begin(sa) + 1, std::end(sa));\n}\n",
        "result": "ALL_AC"
    },
    "string/z_algorithm.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\ntemplate<typename V>\nVec<int> z_algorithm(const V& vs)\n{\n    const int N = std::size(vs);\n    Vec<int> ans(N, -1);\n    for (int i = 1, j = 0; i < N;) {\n        while (i + j < N and vs[j] == vs[i + j]) { j++; }\n        ans[i] = j;\n        if (j == 0) {\n            ++i;\n            continue;\n        }\n        int k = 1;\n        while (i + k < N and k + ans[k] < j) {\n            ans[i + k] = ans[k];\n            k++;\n        }\n        i += k, j -= k;\n    }\n    ans[0] = N;\n    return ans;\n}\n",
        "result": "ALL_AC"
    },
    "utility/bin_search.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\ntemplate<typename T, typename F>\ninline T binSearch(T ng, T ok, F check)\n{\n    while (std::abs(ok - ng) > 1) {\n        const T mid = (ok + ng) / 2;\n        (check(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\n",
        "result": "ALL_AC"
    },
    "utility/floor_divs.hpp": {
        "code": "#pragma once\n#include \"common.hpp\"\n\nclass FloorDivs\n{\npublic:\n    FloorDivs(i64 X) : m_numerator{X}\n    {\n        assert(X >= 1);\n        for (i64 y = 1; y * y <= X; y++) { m_divs.push_back(y); }\n        const i64 Y = m_divs.back();\n        for (i64 x = X / (Y + 1); x >= 1; x--) {\n            const i64 y = X / x;\n            if (m_divs.back() < y) { m_divs.push_back(y); }\n        }\n    };\n    const Vec<i64>& divs() const { return m_divs; }\n    i64 at(int i) const\n    {\n        assert(0 <= i and i < (int)m_divs.size());\n        return m_divs[i];\n    }\n    int pos(i64 y) const\n    {\n        i64 id = 0;\n        if (y * y <= m_numerator) {\n            id = y - 1;\n        } else {\n            id = (i64)m_divs.size() - (m_numerator / y);\n        }\n        assert(m_divs[id] == y);\n        return id;\n    }\n    int divNum() const { return m_divs.size(); }\n\nprivate:\n    i64 m_numerator;\n    Vec<i64> m_divs;\n};\n",
        "result": "NOT_TESTED"
    },
    "utility/int_nthroot.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\n#include \"bin_search.hpp\"\n\ninline u64 intNthRoot(u64 a, u64 k)\n{\n    if (a == 0) { return 0; }\n    if (k == 1) { return a; }\n    if (k >= 64) { return 1; }\n    auto satPow = [&](const u128& a, int k) {\n        u128 x = 1;\n        LOOP (k) {\n            x *= a;\n            if (x >= (u128(1) << 64)) { break; }\n        }\n        return x;\n    };\n    return binSearch(1_i64 << 32, 1_i64, [&](i64 x) { return satPow(x, k) <= a; });\n}\n",
        "result": "ALL_AC"
    },
    "utility/modint.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\n#include \"../algorithm/ext_gcd.hpp\"\ntemplate<u32 mod_, u32 root_, u32 max2p_>\nclass modint\n{\n    template<typename U = u32&>\n    static U modRef()\n    {\n        static u32 s_mod = 0;\n        return s_mod;\n    }\n    template<typename U = u32&>\n    static U rootRef()\n    {\n        static u32 s_root = 0;\n        return s_root;\n    }\n    template<typename U = u32&>\n    static U max2pRef()\n    {\n        static u32 s_max2p = 0;\n        return s_max2p;\n    }\n\npublic:\n    static_assert(mod_ <= LIMMAX<i32>, \"mod(signed int size) only supported!\");\n    static constexpr bool isDynamic() { return (mod_ == 0); }\n    template<typename U = const u32>\n    static constexpr std::enable_if_t<mod_ != 0, U> mod()\n    {\n        return mod_;\n    }\n    template<typename U = const u32>\n    static std::enable_if_t<mod_ == 0, U> mod()\n    {\n        return modRef();\n    }\n    template<typename U = const u32>\n    static constexpr std::enable_if_t<mod_ != 0, U> root()\n    {\n        return root_;\n    }\n    template<typename U = const u32>\n    static std::enable_if_t<mod_ == 0, U> root()\n    {\n        return rootRef();\n    }\n    template<typename U = const u32>\n    static constexpr std::enable_if_t<mod_ != 0, U> max2p()\n    {\n        return max2p_;\n    }\n    template<typename U = const u32>\n    static std::enable_if_t<mod_ == 0, U> max2p()\n    {\n        return max2pRef();\n    }\n    template<typename U = u32>\n    static void setMod(std::enable_if_t<mod_ == 0, U> m)\n    {\n        assert(1 <= m and m <= LIMMAX<i32>);\n        modRef() = m;\n        sinvRef() = {1, 1};\n        factRef() = {1, 1};\n        ifactRef() = {1, 1};\n    }\n    template<typename U = u32>\n    static void setRoot(std::enable_if_t<mod_ == 0, U> r)\n    {\n        rootRef() = r;\n    }\n    template<typename U = u32>\n    static void setMax2p(std::enable_if_t<mod_ == 0, U> m)\n    {\n        max2pRef() = m;\n    }\n    constexpr modint() : m_val{0} {}\n    constexpr modint(i64 v) : m_val{normll(v)} {}\n    constexpr void setRaw(u32 v) { m_val = v; }\n    constexpr modint operator-() const { return modint{0} - (*this); }\n    constexpr modint& operator+=(const modint& m)\n    {\n        m_val = norm(m_val + m.val());\n        return *this;\n    }\n    constexpr modint& operator-=(const modint& m)\n    {\n        m_val = norm(m_val + mod() - m.val());\n        return *this;\n    }\n    constexpr modint& operator*=(const modint& m)\n    {\n        m_val = normll((i64)m_val * (i64)m.val() % (i64)mod());\n        return *this;\n    }\n    constexpr modint& operator/=(const modint& m) { return *this *= m.inv(); }\n    constexpr modint operator+(const modint& m) const\n    {\n        auto v = *this;\n        return v += m;\n    }\n    constexpr modint operator-(const modint& m) const\n    {\n        auto v = *this;\n        return v -= m;\n    }\n    constexpr modint operator*(const modint& m) const\n    {\n        auto v = *this;\n        return v *= m;\n    }\n    constexpr modint operator/(const modint& m) const\n    {\n        auto v = *this;\n        return v /= m;\n    }\n    constexpr bool operator==(const modint& m) const { return m_val == m.val(); }\n    constexpr bool operator!=(const modint& m) const { return not(*this == m); }\n    friend Istream& operator>>(Istream& is, modint& m)\n    {\n        i64 v;\n        return is >> v, m = v, is;\n    }\n    friend Ostream& operator<<(Ostream& os, const modint& m) { return os << m.val(); }\n    constexpr u32 val() const { return m_val; }\n    template<typename I>\n    constexpr modint pow(I n) const\n    {\n        return powerInt(*this, n);\n    }\n    constexpr modint inv() const { return inverse<i32>(m_val, mod()); }\n    static modint sinv(u32 n)\n    {\n        auto& is = sinvRef();\n        for (u32 i = (u32)is.size(); i <= n; i++) { is.push_back(-is[mod() % i] * (mod() / i)); }\n        return is[n];\n    }\n    static modint fact(u32 n)\n    {\n        auto& fs = factRef();\n        for (u32 i = (u32)fs.size(); i <= n; i++) { fs.push_back(fs.back() * i); }\n        return fs[n];\n    }\n    static modint ifact(u32 n)\n    {\n        auto& ifs = ifactRef();\n        for (u32 i = (u32)ifs.size(); i <= n; i++) { ifs.push_back(ifs.back() * sinv(i)); }\n        return ifs[n];\n    }\n    static modint perm(int n, int k) { return k > n or k < 0 ? modint{0} : fact(n) * ifact(n - k); }\n    static modint comb(int n, int k)\n    {\n        return k > n or k < 0 ? modint{0} : fact(n) * ifact(n - k) * ifact(k);\n    }\n\nprivate:\n    static Vec<modint>& sinvRef()\n    {\n        static Vec<modint> is{1, 1};\n        return is;\n    }\n    static Vec<modint>& factRef()\n    {\n        static Vec<modint> fs{1, 1};\n        return fs;\n    }\n    static Vec<modint>& ifactRef()\n    {\n        static Vec<modint> ifs{1, 1};\n        return ifs;\n    }\n    static constexpr u32 norm(u32 x) { return x < mod() ? x : x - mod(); }\n    static constexpr u32 normll(i64 x) { return norm(u32(x % (i64)mod() + (i64)mod())); }\n    u32 m_val;\n};\nusing modint_1000000007 = modint<1000000007, 5, 1>;\nusing modint_998244353 = modint<998244353, 3, 23>;\ntemplate<int id>\nusing modint_dynamic = modint<0, 0, id>;\n",
        "result": "ALL_AC"
    },
    "utility/modint64.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\n#include \"../algorithm/ext_gcd.hpp\"\ntemplate<u64 mod_, u64 root_, u64 max2p_>\nclass modint64\n{\n    template<typename U = u64&>\n    static U modRef()\n    {\n        static u64 s_mod = 0;\n        return s_mod;\n    }\n    template<typename U = u64&>\n    static U rootRef()\n    {\n        static u64 s_root = 0;\n        return s_root;\n    }\n    template<typename U = u64&>\n    static U max2pRef()\n    {\n        static u64 s_max2p = 0;\n        return s_max2p;\n    }\n\npublic:\n    static_assert(mod_ <= LIMMAX<i64>, \"mod(signed int size) only supported!\");\n    static constexpr bool isDynamic() { return (mod_ == 0); }\n    template<typename U = const u64>\n    static constexpr std::enable_if_t<mod_ != 0, U> mod()\n    {\n        return mod_;\n    }\n    template<typename U = const u64>\n    static std::enable_if_t<mod_ == 0, U> mod()\n    {\n        return modRef();\n    }\n    template<typename U = const u64>\n    static constexpr std::enable_if_t<mod_ != 0, U> root()\n    {\n        return root_;\n    }\n    template<typename U = const u64>\n    static std::enable_if_t<mod_ == 0, U> root()\n    {\n        return rootRef();\n    }\n    template<typename U = const u64>\n    static constexpr std::enable_if_t<mod_ != 0, U> max2p()\n    {\n        return max2p_;\n    }\n    template<typename U = const u64>\n    static std::enable_if_t<mod_ == 0, U> max2p()\n    {\n        return max2pRef();\n    }\n    template<typename U = u64>\n    static void setMod(std::enable_if_t<mod_ == 0, U> m)\n    {\n        assert(1 <= m and m <= LIMMAX<i64>);\n        modRef() = m;\n        sinvRef() = {1, 1};\n        factRef() = {1, 1};\n        ifactRef() = {1, 1};\n    }\n    template<typename U = u64>\n    static void setRoot(std::enable_if_t<mod_ == 0, U> r)\n    {\n        rootRef() = r;\n    }\n    template<typename U = u64>\n    static void setMax2p(std::enable_if_t<mod_ == 0, U> m)\n    {\n        max2pRef() = m;\n    }\n    constexpr modint64() : m_val{0} {}\n    constexpr modint64(const i64 v) : m_val{normLL(v)} {}\n    constexpr void setRaw(const u64 v) { m_val = v; }\n    constexpr modint64 operator+() const { return *this; }\n    constexpr modint64 operator-() const { return modint64{0} - (*this); }\n    constexpr modint64& operator+=(const modint64& m)\n    {\n        m_val = norm(m_val + m.val());\n        return *this;\n    }\n    constexpr modint64& operator-=(const modint64& m)\n    {\n        m_val = norm(m_val + mod() - m.val());\n        return *this;\n    }\n    constexpr modint64& operator*=(const modint64& m)\n    {\n        m_val = normLL((i128)m_val * (i128)m.val() % (i128)mod());\n        return *this;\n    }\n    constexpr modint64& operator/=(const modint64& m) { return *this *= m.inv(); }\n    constexpr modint64 operator+(const modint64& m) const\n    {\n        auto v = *this;\n        return v += m;\n    }\n    constexpr modint64 operator-(const modint64& m) const\n    {\n        auto v = *this;\n        return v -= m;\n    }\n    constexpr modint64 operator*(const modint64& m) const\n    {\n        auto v = *this;\n        return v *= m;\n    }\n    constexpr modint64 operator/(const modint64& m) const\n    {\n        auto v = *this;\n        return v /= m;\n    }\n    constexpr bool operator==(const modint64& m) const { return m_val == m.val(); }\n    constexpr bool operator!=(const modint64& m) const { return not(*this == m); }\n    friend Istream& operator>>(Istream& is, modint64& m)\n    {\n        i64 v;\n        return is >> v, m = v, is;\n    }\n    friend Ostream& operator<<(Ostream& os, const modint64& m) { return os << m.val(); }\n    constexpr u64 val() const { return m_val; }\n    template<typename I>\n    constexpr modint64 pow(I n) const\n    {\n        return powerInt(*this, n);\n    }\n    constexpr modint64 inv() const { return inverse<i64>(m_val, mod()); }\n    modint64 sinv() const { return sinv(m_val); }\n    static modint64 sinv(u32 n)\n    {\n        auto& is = sinvRef();\n        for (u32 i = (u32)is.size(); i <= n; i++) { is.push_back(-is[mod() % i] * (mod() / i)); }\n        return is[n];\n    }\n    static modint64 fact(u32 n)\n    {\n        auto& fs = factRef();\n        for (u32 i = (u32)fs.size(); i <= n; i++) { fs.push_back(fs.back() * i); }\n        return fs[n];\n    }\n    static modint64 ifact(u32 n)\n    {\n        auto& ifs = ifactRef();\n        for (u32 i = (u32)ifs.size(); i <= n; i++) { ifs.push_back(ifs.back() * sinv(i)); }\n        return ifs[n];\n    }\n    static modint64 perm(int n, int k)\n    {\n        return k > n or k < 0 ? modint64{0} : fact(n) * ifact(n - k);\n    }\n    static modint64 comb(int n, int k)\n    {\n        return k > n or k < 0 ? modint64{0} : fact(n) * ifact(n - k) * ifact(k);\n    }\n\nprivate:\n    static Vec<modint64>& sinvRef()\n    {\n        static Vec<modint64> is{1, 1};\n        return is;\n    }\n    static Vec<modint64>& factRef()\n    {\n        static Vec<modint64> fs{1, 1};\n        return fs;\n    }\n    static Vec<modint64>& ifactRef()\n    {\n        static Vec<modint64> ifs{1, 1};\n        return ifs;\n    }\n    static constexpr u64 norm(const u64 x) { return x < mod() ? x : x - mod(); }\n    static constexpr u64 normLL(const i64 x)\n    {\n        return norm(u64((i128)x % (i128)mod() + (i128)mod()));\n    }\n    u64 m_val;\n};\ntemplate<int id>\nusing modint64_dynamic = modint64<0, 0, id>;\n",
        "result": "ALL_AC"
    },
    "utility/nd_rep.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\nclass ndRep\n{\nprivate:\n    struct itr\n    {\n        itr(const Vec<int>& ns) : m_ns{ns}, m_cs(ns.size(), 0), m_end{false} {}\n        bool operator!=(const itr&) const { return not m_end; }\n        const Vec<int>& operator*() { return m_cs; }\n        itr& operator++()\n        {\n            for (const int i : per(m_ns.size())) {\n                m_cs[i]++;\n                if (m_cs[i] < m_ns[i]) {\n                    break;\n                } else {\n                    if (i == 0) { m_end = true; }\n                    m_cs[i] = 0;\n                }\n            }\n            return *this;\n        }\n        Vec<int> m_ns, m_cs;\n        bool m_end;\n    };\n    Vec<int> m_ns;\n\npublic:\n    ndRep(const Vec<int>& ns) : m_ns{ns} {}\n    itr begin() const { return itr{m_ns}; }\n    itr end() const { return itr{m_ns}; }\n};\n",
        "result": "ALL_AC"
    },
    "utility/nd_vec.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\ntemplate<typename T, int n, int i = 0>\nauto ndVec(int const (&szs)[n], const T x = T{})\n{\n    if constexpr (i == n) {\n        return x;\n    } else {\n        return std::vector(szs[i], ndVec<T, n, i + 1>(szs, x));\n    }\n}\n",
        "result": "ALL_AC"
    },
    "utility/printer.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\nclass Printer\n{\npublic:\n    Printer(Ostream& os = std::cout) : m_os{os} { m_os << std::fixed << std::setprecision(15); }\n    template<typename... Args>\n    int operator()(const Args&... args)\n    {\n        return dump(args...), 0;\n    }\n    template<typename... Args>\n    int ln(const Args&... args)\n    {\n        return dump(args...), m_os << '\\n', 0;\n    }\n    template<typename... Args>\n    int el(const Args&... args)\n    {\n        return dump(args...), m_os << std::endl, 0;\n    }\n    int YES(bool b = true) { return ln(b ? \"YES\" : \"NO\"); }\n    int NO(bool b = true) { return YES(not b); }\n    int Yes(bool b = true) { return ln(b ? \"Yes\" : \"No\"); }\n    int No(bool b = true) { return Yes(not b); }\n\nprivate:\n    template<typename T>\n    void dump(const T& v)\n    {\n        m_os << v;\n    }\n    template<typename T>\n    void dump(const Vec<T>& vs)\n    {\n        for (int i : rep(vs.size())) { m_os << (i ? \" \" : \"\"), dump(vs[i]); }\n    }\n    template<typename T>\n    void dump(const Vec<Vec<T>>& vss)\n    {\n        for (int i : rep(vss.size())) { m_os << (i ? \"\\n\" : \"\"), dump(vss[i]); }\n    }\n    template<typename T, typename... Ts>\n    int dump(const T& v, const Ts&... args)\n    {\n        return dump(v), m_os << ' ', dump(args...), 0;\n    }\n    Ostream& m_os;\n};\ninline Printer out;\n",
        "result": "ALL_AC"
    },
    "utility/rational.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\ntemplate<typename T>\nclass Rational\n{\npublic:\n    constexpr Rational() : m_num{0}, m_den{1} {}\n    constexpr Rational(const T& v) : m_num{v}, m_den{1} {}\n    constexpr Rational(const T& num, const T& den) { std::tie(m_num, m_den) = norm(num, den); }\n    constexpr Rational operator-() const\n    {\n        auto ans = *this;\n        ans.m_num = -ans.m_num;\n        return ans;\n    }\n    constexpr Rational& operator+=(const Rational& x2)\n    {\n        const auto& [n, d] = norm(m_num * x2.m_den + x2.m_num * m_den, m_den * x2.m_den);\n        return setRaw(n, d), *this;\n    }\n    constexpr Rational& operator-=(const Rational& x2)\n    {\n        const auto& [n, d] = norm(m_num * x2.m_den - x2.m_num * m_den, m_den * x2.m_den);\n        return setRaw(n, d), *this;\n    }\n    constexpr Rational& operator*=(const Rational& x2)\n    {\n        const T g12 = std::gcd(m_num, x2.m_den), g21 = std::gcd(x2.m_num, m_den);\n        return setRaw((m_num / g12) * (x2.m_num / g21), (m_den / g21) * (x2.m_den / g12)), *this;\n    }\n    constexpr Rational& operator/=(const Rational& x2)\n    {\n        const T g12 = std::gcd(m_num, x2.m_num), g21 = std::gcd(x2.m_den, m_den);\n        return setRaw((m_num / g12) * (x2.m_den / g21), (m_den / g21) * (x2.m_num / g12)), *this;\n    }\n    constexpr Rational operator+(const Rational& x2) const\n    {\n        auto v = *this;\n        return v += x2;\n    }\n    constexpr Rational operator-(const Rational& x2) const\n    {\n        auto v = *this;\n        return v -= x2;\n    }\n    constexpr Rational operator*(const Rational& x2) const\n    {\n        auto v = *this;\n        return v *= x2;\n    }\n    constexpr Rational operator/(const Rational& x2) const\n    {\n        auto v = *this;\n        return v /= x2;\n    }\n    constexpr bool operator==(const Rational& x2) const\n    {\n        return m_num == x2.m_num and m_den == x2.m_den;\n    }\n    constexpr bool operator<(const Rational& x2) const\n    {\n        if (x2.m_den == 0) { return x2.m_num > 0; }\n        if (m_den == 0) { return m_num < 0; }\n        return m_num * x2.m_den < x2.m_num * m_den;\n    }\n    constexpr bool operator>(const Rational& x2) const\n    {\n        if (x2.m_den == 0) { return x2.m_num < 0; }\n        if (m_den == 0) { return m_num > 0; }\n        return m_num * x2.m_den > x2.m_num * m_den;\n    }\n    constexpr bool operator<=(const Rational& x2) const { return not(*this > x2); }\n    constexpr bool operator>=(const Rational& x2) const { return not(*this < x2); }\n    friend Ostream& operator<<(Ostream& os, const Rational& x)\n    {\n        const auto& [den, num] = x;\n        return os << den << \"/\" << num;\n    }\n    constexpr void setRaw(T num, T den) { m_num = num, m_den = den; }\n    constexpr Pair<T, T> val() const { return {m_num, m_den}; }\n    constexpr T num() const { return m_num; }\n    constexpr T den() const { return m_den; }\n\nprivate:\n    static constexpr Pair<T, T> norm(T num, T den)\n    {\n        if (den < 0) { num = -num, den = -den; }\n        const auto g = std::gcd(num, den);\n        return {num / g, den / g};\n    }\n    T m_num, m_den;\n};\n",
        "result": "NOT_TESTED"
    },
    "utility/rng.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\ntemplate<typename Engine>\nclass RNG\n{\npublic:\n    using result_type = typename Engine::result_type;\n    using T = result_type;\n    static constexpr T min() { return Engine::min(); }\n    static constexpr T max() { return Engine::max(); }\n    RNG() : RNG(std::random_device{}()) {}\n    RNG(T seed) : m_rng(seed) {}\n    T operator()() { return m_rng(); }\n    template<typename T>\n    T val(T min, T max)\n    {\n        return std::uniform_int_distribution<T>(min, max)(m_rng);\n    }\n    template<typename T, typename... Args>\n    auto tup(T min, T max, const Args&... offsets)\n    {\n        return Tup<T, Args...>{val<T>(min, max), val<Args>(offsets)...};\n    }\n    template<typename T>\n    Vec<T> vec(int n, T min, T max)\n    {\n        return genVec<T>(n, [&]() { return val<T>(min, max); });\n    }\n    template<typename T>\n    Vec<Vec<T>> vvec(int n, int m, T min, T max)\n    {\n        return genVec<Vec<T>>(n, [&]() { return vec(m, min, max); });\n    }\n\nprivate:\n    Engine m_rng;\n};\ninline RNG<std::mt19937> rng;\ninline RNG<std::mt19937_64> rng64;\n",
        "result": "ALL_AC"
    },
    "utility/scanner.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\nclass Scanner\n{\npublic:\n    Scanner(Istream& is = std::cin) : m_is{is} { m_is.tie(nullptr)->sync_with_stdio(false); }\n    template<typename T>\n    T val()\n    {\n        T v;\n        return m_is >> v, v;\n    }\n    template<typename T>\n    T val(T offset)\n    {\n        return val<T>() - offset;\n    }\n    template<typename T>\n    Vec<T> vec(int n)\n    {\n        return genVec<T>(n, [&]() { return val<T>(); });\n    }\n    template<typename T>\n    Vec<T> vec(int n, T offset)\n    {\n        return genVec<T>(n, [&]() { return val<T>(offset); });\n    }\n    template<typename T>\n    Vec<Vec<T>> vvec(int n, int m)\n    {\n        return genVec<Vec<T>>(n, [&]() { return vec<T>(m); });\n    }\n    template<typename T>\n    Vec<Vec<T>> vvec(int n, int m, const T offset)\n    {\n        return genVec<Vec<T>>(n, [&]() { return vec<T>(m, offset); });\n    }\n    template<typename... Args>\n    auto tup()\n    {\n        return Tup<Args...>{val<Args>()...};\n    }\n    template<typename... Args>\n    auto tup(const Args&... offsets)\n    {\n        return Tup<Args...>{val<Args>(offsets)...};\n    }\n\nprivate:\n    Istream& m_is;\n};\ninline Scanner in;\n",
        "result": "ALL_AC"
    },
    "utility/stopwatch.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\nclass StopWatch\n{\n    using SysClock = std::chrono::system_clock;\n    using Tp = SysClock::time_point;\n\npublic:\n    StopWatch() : m_start{SysClock::now()}, m_rap{m_start} {}\n    template<typename D = std::chrono::milliseconds>\n    typename D::rep rap()\n    {\n        const auto now = SysClock::now();\n        const auto ans = std::chrono::duration_cast<D>(now - m_rap).count();\n        m_rap = now;\n        return ans;\n    }\n    template<typename D = std::chrono::milliseconds>\n    typename D::rep get()\n    {\n        const auto now = SysClock::now();\n        return std::chrono::duration_cast<D>(now - m_rap).count();\n    }\n    template<typename D = std::chrono::milliseconds>\n    typename D::rep total()\n    {\n        const auto now = SysClock::now();\n        return std::chrono::duration_cast<D>(now - m_start).count();\n    }\n\nprivate:\n    Tp m_start, m_rap;\n};\n",
        "result": "NOT_TESTED"
    },
    "utility/zipper.hpp": {
        "code": "#pragma once\n#include \"../common.hpp\"\ntemplate<typename T>\nclass Zipper\n{\npublic:\n    Zipper() {}\n    Zipper(const Vec<T>& vs) : m_vs{vs}, m_calced(false) {}\n    T unzip(int n)\n    {\n        assert(0 <= n and n < (int)m_vs.size());\n        calc();\n        return m_vs[n];\n    }\n    int zip(T v)\n    {\n        calc();\n        return lbInd(m_vs, v);\n    }\n    void add(T v)\n    {\n        m_vs.push_back(v);\n        m_calced = false;\n    }\n    void add(const Vec<T>& vs)\n    {\n        for (const auto& v : vs) { m_vs.push_back(v); }\n        m_calced = false;\n    }\n    int size()\n    {\n        calc();\n        return m_vs.size();\n    }\n    friend Ostream& operator<<(Ostream& os, const Zipper& zipper_)\n    {\n        auto zipper = zipper_;\n        zipper.calc();\n        return os << zipper.m_vs << \"\\n\";\n    }\n\nprivate:\n    void calc()\n    {\n        if (not m_calced) {\n            sortAll(m_vs);\n            m_vs.erase(std::unique(m_vs.begin(), m_vs.end()), m_vs.end());\n            m_calced = true;\n        }\n    }\n    Vec<T> m_vs;\n    bool m_calced = true;\n};\n",
        "result": "ALL_AC"
    }
}