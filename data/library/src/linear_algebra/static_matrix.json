{
    "code": "#pragma once\n#include \"../common.hpp\"\ntemplate<typename T, int row, int column>\nclass StaticMatrix\n{\n    template<typename V>\n    using IList = std::initializer_list<V>;\n\npublic:\n    StaticMatrix()\n    {\n        for (auto& vs : m_vss) { fillAll(vs, T{}); }\n    }\n    StaticMatrix(const IList<IList<T>>& vss)\n    {\n        assert(row == vss.size());\n        assert(column == vss.begin()->size());\n        int i = 0;\n        for (auto it = vss.begin(); it != vss.end(); it++) {\n            std::copy(it->begin(), it->end(), m_vss[i++].begin());\n        }\n    }\n    StaticMatrix(const StaticMatrix& m) : m_vss{m.m_vss} {}\n    StaticMatrix& operator=(const StaticMatrix& m)\n    {\n        for (const int i : rep(row)) {\n            for (const int j : rep(column)) { m_vss[i][j] = m[i][j]; }\n        }\n        return *this;\n    }\n    const Arr<T, column>& operator[](const int r) const { return m_vss[r]; }\n    Arr<T, column>& operator[](const int r) { return m_vss[r]; }\n    friend StaticMatrix operator-(const StaticMatrix& m)\n    {\n        StaticMatrix ans;\n        for (const int r : rep(row)) {\n            for (const int c : rep(column)) { ans[r][c] = -m[r][c]; }\n        }\n        return ans;\n    }\n    friend StaticMatrix operator+(const StaticMatrix& m1, const StaticMatrix& m2)\n    {\n        StaticMatrix ans;\n        for (const int r : rep(row)) {\n            for (const int c : rep(column)) { ans[r][c] = m1[r][c] + m2[r][c]; }\n        }\n        return ans;\n    }\n    friend StaticMatrix operator-(const StaticMatrix& m1, const StaticMatrix& m2)\n    {\n        StaticMatrix ans;\n        for (const int r : rep(row)) {\n            for (const int c : rep(column)) { ans[r][c] = m1[r][c] - m2[r][c]; }\n        }\n        return ans;\n    }\n    template<int c>\n    friend StaticMatrix operator*(const StaticMatrix<T, row, c>& m1,\n                                  const StaticMatrix<T, c, column>& m2)\n    {\n        StaticMatrix<T, row, column> ans;\n        for (const int i : rep(row)) {\n            for (const int j : rep(column)) {\n                for (const int k : rep(c)) { ans[i][j] += m1[i][k] * m2[k][j]; }\n            }\n        }\n        return ans;\n    }\n    friend StaticMatrix operator*(const StaticMatrix& m, const T& t)\n    {\n        StaticMatrix ans;\n        for (const int r : rep(row)) {\n            for (const int c : rep(column)) { ans[r][c] = m[r][c] * t; }\n        }\n        return ans;\n    }\n    friend StaticMatrix operator/(const StaticMatrix& m, const T& t)\n    {\n        StaticMatrix ans;\n        for (const int r : rep(row)) {\n            for (const int c : rep(column)) { ans[r][c] = m[r][c] / t; }\n        }\n        return ans;\n    }\n    friend StaticMatrix operator*(const T& t, const StaticMatrix& m) { return m * t; }\n    friend StaticMatrix& operator+=(StaticMatrix& m1, const StaticMatrix& m2)\n    {\n        return m1 = m1 + m2;\n    }\n    friend StaticMatrix& operator-=(StaticMatrix& m1, const StaticMatrix& m2)\n    {\n        return m1 = m1 - m2;\n    }\n    friend StaticMatrix& operator*=(StaticMatrix& m1, const StaticMatrix& m2)\n    {\n        return m1 = m1 * m2;\n    }\n    friend StaticMatrix& operator*=(StaticMatrix& m, const T& t) { return m = m * t; }\n    friend StaticMatrix& operator/=(StaticMatrix& m, const T& t) { return m = m / t; }\n    friend std::ostream& operator<<(std::ostream& os, const StaticMatrix& m)\n    {\n        os << \"[\\n\";\n        for (const int i : rep(row)) {\n            os << \"[\";\n            for (const int j : rep(column)) { os << m[i][j] << \",\"; }\n            os << \"]\\n\";\n        }\n        return (os << \"]\");\n    }\n    template<typename Int>\n    StaticMatrix pow(Int n) const\n    {\n        return powerMonoid(*this, n, I());\n    }\n    static StaticMatrix I()\n    {\n        static_assert(row == column, \"StaticMatrix::I() should be rectangular!\");\n        StaticMatrix ans;\n        for (const int i : rep(row)) { ans[i][i] = 1; }\n        return ans;\n    }\n\nprivate:\n    Arr<Arr<T, column>, row> m_vss;\n};\n",
    "result": "NOT_TESTED",
    "verified_with": [
        "verifications/linear_algebra/static_matrix.test.cpp"
    ]
}