{
    "code": "#pragma once\n#include \"../common.hpp\"\n#include \"graph.hpp\"\ntemplate<typename T>\nclass LowLink\n{\n    using P = Pair<int, int>;\n\npublic:\n    LowLink(const Graph<T>& g) : m_v(g.v()), m_ords(m_v), m_lows(m_v), m_is_art(m_v)\n    {\n        const int N = g.v();\n        int ord = 0;\n        Vec<bool> used(N, false);\n        auto dfs = Fix([&](auto dfs, int u, int pe) -> void {\n            used[u] = true;\n            m_ords[u] = ord++;\n            m_lows[u] = m_ords[u];\n            bool is_art = false;\n            int dim = 0;\n            for (UNUSED const auto& [id, v, _] : g[u]) {\n                if (not used[v]) {\n                    dim++;\n                    dfs(v, id);\n                    chmin(m_lows[u], m_lows[v]);\n                    is_art |= (pe != -1 and m_ords[u] <= m_lows[v]);\n                    if (isBridge(u, v)) { m_bridges.push_back(std::minmax({u, v})); }\n                } else if (id != pe) {\n                    chmin(m_lows[u], m_ords[v]);\n                }\n            }\n            if (pe == -1) {\n                m_is_art[u] = (dim >= 2);\n            } else {\n                m_is_art[u] = is_art;\n            }\n        });\n        for (int i : rep(N)) {\n            if (not used[i]) { dfs(i, -1); }\n        }\n    }\n    bool isArt(int i) const\n    {\n        assert(0 <= i and i < m_v);\n        return m_is_art[i];\n    }\n    bool isBridge(int i, int j) const\n    {\n        assert(0 <= i and i < m_v);\n        assert(0 <= j and j < m_v);\n        if (m_ords[i] > m_ords[j]) { std::swap(i, j); }\n        return m_ords[i] < m_lows[j];\n    }\n    const Vec<P>& bridges() const { return m_bridges; }\n    const Vec<int>& arts() const { return m_arts; }\n\nprivate:\n    int m_v;\n    Vec<P> m_bridges;\n    Vec<int> m_arts;\n    Vec<int> m_ords;\n    Vec<int> m_lows;\n    Vec<bool> m_is_art;\n};\n",
    "result": "NOT_TESTED",
    "verified_with": []
}