{
    "code": "#pragma once\n#include \"../common.hpp\"\ntemplate<typename T = int>\nclass Graph\n{\n    struct Edge\n    {\n        Edge() = default;\n        Edge(int i, int t, T c) : id{i}, to{t}, cost{c} {}\n        int id;\n        int to;\n        T cost;\n        operator int() const { return to; }\n    };\n\npublic:\n    Graph(int n) : m_v{n}, m_edges(n) {}\n    void addEdge(int u, int v, bool bi = false)\n    {\n        assert(0 <= u and u < m_v);\n        assert(0 <= v and v < m_v);\n        m_edges[u].emplace_back(m_e, v, 1);\n        if (bi) { m_edges[v].emplace_back(m_e, u, 1); }\n        m_e++;\n    }\n    void addEdge(int u, int v, const T& c, bool bi = false)\n    {\n        assert(0 <= u and u < m_v);\n        assert(0 <= v and v < m_v);\n        m_edges[u].emplace_back(m_e, v, c);\n        if (bi) { m_edges[v].emplace_back(m_e, u, c); }\n        m_e++;\n    }\n    const Vec<Edge>& operator[](const int u) const\n    {\n        assert(0 <= u and u < m_v);\n        return m_edges[u];\n    }\n    Vec<Edge>& operator[](const int u)\n    {\n        assert(0 <= u and u < m_v);\n        return m_edges[u];\n    }\n    int v() const { return m_v; }\n    int e() const { return m_e; }\n    friend Ostream& operator<<(Ostream& os, const Graph& g)\n    {\n        for (int u : rep(g.v())) {\n            for (const auto& [id, v, c] : g[u]) {\n                os << \"[\" << id << \"]: \";\n                os << u << \"->\" << v << \"(\" << c << \")\\n\";\n            }\n        }\n        return os;\n    }\n    Vec<T> sizes(int root = 0) const\n    {\n        const int N = v();\n        assert(0 <= root and root < N);\n        Vec<T> ss(N, 1);\n        Fix([&](auto dfs, int u, int p) -> void {\n            for (UNUSED const auto& [_, v, c] : m_edges[u]) {\n                if (v == p) { continue; }\n                dfs(v, u);\n                ss[u] += ss[v];\n            }\n        })(root, -1);\n        return ss;\n    }\n    Vec<T> depths(int root = 0) const\n    {\n        const int N = v();\n        assert(0 <= root and root < N);\n        Vec<T> ds(N, 0);\n        Fix([&](auto dfs, int u, int p) -> void {\n            for (UNUSED const auto& [_, v, c] : m_edges[u]) {\n                if (v == p) { continue; }\n                ds[v] = ds[u] + c;\n                dfs(v, u);\n            }\n        })(root, -1);\n        return ds;\n    }\n    Vec<int> parents(int root = 0) const\n    {\n        const int N = v();\n        assert(0 <= root and root < N);\n        Vec<int> ps(N, -1);\n        Fix([&](auto dfs, int u, int p) -> void {\n            for (UNUSED const auto& [_, v, c] : m_edges[u]) {\n                if (v == p) { continue; }\n                ps[v] = u;\n                dfs(v, u);\n            }\n        })(root, -1);\n        return ps;\n    }\n\nprivate:\n    int m_v;\n    int m_e = 0;\n    Vec<Vec<Edge>> m_edges;\n};\n",
    "result": "NOT_TESTED",
    "verified_with": [
        "verifications/graph/bellman_ford.test.cpp",
        "verifications/graph/floyd_warshall.test.cpp",
        "verifications/graph/dijkstra.test.cpp",
        "verifications/graph/strongly_connected_components.test.cpp",
        "verifications/graph/tree/least_common_ancestor.test.cpp",
        "verifications/graph/tree/level_ancestor.ut.test.cpp",
        "verifications/graph/tree/level_ancestor.lca.test.cpp",
        "verifications/graph/tree/heavy_light_decomposition.test.cpp",
        "verifications/graph/tree/centroid_decomposition.test.cpp",
        "verifications/graph/tree/diameter.test.cpp"
    ]
}