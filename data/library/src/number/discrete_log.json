{
    "code": "#pragma once\n#include \"../common.hpp\"\n#include \"../utility/int_nthroot.hpp\"\n#include \"../algorithm/babystep_giantstep.hpp\"\n\ntemplate<typename mint>\ninline i64 discreteLog(mint X, mint Y)\n{\n    static_assert(mint::isDynamic(), \"Only dynamic-modint supportted!\");\n    i64 P = mint::mod();\n    if (P == 1) { return 0; }\n    if (X == 0) { return (Y == 1 ? 0 : (Y == 0 ? 1 : -1)); }\n\n    mint pX = 1;\n    const int offset = bitWidth(P);\n    for (int d : rep(offset)) {\n        if (pX == Y) { return d; }\n        pX *= X;\n    }\n    const i64 g = std::gcd((i64)pX.val(), P);\n    if (Y.val() % g != 0) { return -1; }\n    const i64 nP = P / g;\n    mint::setMod(nP);\n    const mint npX = pX.val();\n    const mint nX = X.val(), nY = npX.inv() * Y.val();\n    const i64 W = intNthRoot(nP, 2);\n    const mint nXW = nX.pow(W), nXI = nX.inv();\n    auto f_wtimes = [&](i64 x) { return (nXW * x).val(); };\n    auto f_inv = [&](i64 x) { return (nXI * x).val(); };\n    const i64 n\n        = (nY == 1 ? 0_i64\n                   : babyStepGiantStep(f_wtimes, f_inv, (i64)nX.val(), (i64)nY.val(), nP, W));\n    mint::setMod(P);\n\n    if (n == -1) { return -1; }\n    return offset + n;\n}\n",
    "result": "NOT_TESTED",
    "verified_with": [
        "verifications/number/discrete_log.test.cpp"
    ]
}