{
    "code": "#pragma once\n#include \"../common.hpp\"\n#include \"../numerical/convolution.hpp\"\ntemplate<typename mint>\nclass Polynomial : public Vec<mint>\n{\n    using Vec<mint>::resize;\n    using Vec<mint>::push_back;\n    using Vec<mint>::pop_back;\n    using Vec<mint>::back;\n\npublic:\n    using Vec<mint>::vector;\n    Polynomial(const Vec<mint>& vs) : Vec<mint>{vs} { optimize(); }\n    int size() const { return (int)Vec<mint>::size(); }\n    int deg() const { return size() - 1; }\n    mint& operator[](const int n)\n    {\n        if (n >= size()) { resize(n + 1, 0); }\n        return Vec<mint>::operator[](n);\n    }\n    template<typename I>\n    mint at(const I n) const\n    {\n        return (n < size() ? (*this)[n] : mint{0});\n    }\n    Polynomial operator-() const\n    {\n        Polynomial ans = *this;\n        for (auto& v : ans) { v = -v; }\n        return ans;\n    }\n    Polynomial& operator+=(const Polynomial& f)\n    {\n        for (int i : rep(f.size())) { (*this)[i] += f[i]; }\n        return *this;\n    }\n    Polynomial& operator-=(const Polynomial& f)\n    {\n        for (int i : rep(f.size())) { (*this)[i] -= f[i]; }\n        return *this;\n    }\n    Polynomial& operator*=(const Polynomial& f) { return (*this) = (*this) * f; }\n    Polynomial operator+(const Polynomial& f) const { return Polynomial(*this) += f; }\n    Polynomial operator-(const Polynomial& f) const { return Polynomial(*this) -= f; }\n    Polynomial operator*(const Polynomial& f) const { return mult(f, size() + f.size() - 1); }\n    bool isZero() const { return (size() == 1) and ((*this)[0] == 0); }\n    friend Ostream& operator<<(Ostream& os, const Polynomial& f)\n    {\n        return os << static_cast<Vec<mint>>(f);\n    }\n    Polynomial mult(const Polynomial& f) const { return Polynomial{convolute_mod(*this, f)}; }\n    template<typename I>\n    Polynomial pow(I n) const\n    {\n        return powerMonoid(*this, n, {1});\n    }\n    mint eval(const mint& x) const\n    {\n        mint ans = 0;\n        mint p = 1;\n        for (int i : rep(size())) {\n            ans += p * (*this)[i];\n            p *= x;\n        }\n        return ans;\n    }\n\nprivate:\n    const mint& operator[](const int n) const\n    {\n        assert(n < size());\n        return Vec<mint>::operator[](n);\n    }\n    void optimize()\n    {\n        while (size() > 0) {\n            if (back() != 0) { return; }\n            pop_back();\n        }\n        if (size() == 0) { push_back(0); }\n    }\n};\n",
    "result": "NOT_TESTED",
    "verified_with": []
}