{
    "code": "#pragma once\n#include \"../common.hpp\"\ntemplate<typename T>\nclass LiChaoTree\n{\n    using L = Pair<T, T>;\n    static constexpr L NIL = {0, INF<T>};\n    struct Node\n    {\n        L line = NIL;\n        Arr<int, 2> sons{-1, -1};\n    };\n    static bool comp(const L& l1, const L& l2, T x)\n    {\n        if (l1 == NIL or l2 == NIL) { return l2 == NIL; }\n        const auto& [a1, b1] = l1;\n        const auto& [a2, b2] = l2;\n        if (a1 == a2) {\n            return b1 <= b2;\n        } else if (a1 > a2) {\n            return x <= floorDiv(b2 - b1, a1 - a2);\n        } else {\n            return floorDiv(b1 - b2, a2 - a1) < x;\n        }\n    }\n\npublic:\n    LiChaoTree(T xmin, T xsup) : m_xmin{xmin}, m_xsup{xsup}, m_nodes{Node{}}\n    {\n        assert(m_xmin < m_xsup);\n    }\n    void addLine(const L& line) { add(line, 0, m_xmin, m_xsup); }\n    void addSeg(const L& line, T x_left, T x_right)\n    {\n        if (x_left >= x_right) { return; }\n        assert(m_xmin <= x_left and x_right <= m_xsup);\n        Fix([&](auto dfs, int i, T lx, T rx) -> void {\n            if (x_left <= lx and rx <= x_right) {\n                add(line, i, lx, rx);\n            } else {\n                if (rx - lx == 1) { return; }\n                auto [li, ri] = m_nodes[i].sons;\n                const T mx = (lx + rx) / 2;\n                if (lx < x_right and x_left < mx) {\n                    if (li == -1) { li = m_nodes[i].sons[0] = alloc(); }\n                    dfs(li, lx, mx);\n                }\n                if (mx < x_right and x_left < rx) {\n                    if (ri == -1) { ri = m_nodes[i].sons[1] = alloc(); }\n                    dfs(ri, mx, rx);\n                }\n            }\n        })(0, m_xmin, m_xsup);\n    }\n    Pair<bool, L> minLine(const T x) const\n    {\n        T lx = m_xmin, rx = m_xsup;\n        L ans = NIL;\n        for (int i = 0; i != -1;) {\n            const auto& pl = m_nodes[i].line;\n            if (pl != NIL) {\n                if (comp(pl, ans, x)) { ans = pl; }\n            }\n            const auto& [li, ri] = m_nodes[i].sons;\n            const T mx = (lx + rx) / 2;\n            if (x < mx) {\n                i = li;\n                rx = mx;\n            } else {\n                i = ri;\n                lx = mx;\n            }\n        }\n        return {ans != NIL, ans};\n    }\n\nprivate:\n    void add(L l, int i, T lx, T rx)\n    {\n        for (;;) {\n            const auto& pl = m_nodes[i].line;\n            const T mx = (lx + rx) / 2;\n            const bool lunder = comp(l, pl, lx);\n            const bool runder = comp(l, pl, rx - 1);\n            const bool munder = comp(l, pl, mx);\n            if (munder) { std::swap(l, m_nodes[i].line); }\n            if (lunder == runder) { break; }\n            int dir = (lunder == munder ? 1 : 0);\n            int nind = m_nodes[i].sons[dir];\n            if (nind == -1) { nind = m_nodes[i].sons[dir] = alloc(); }\n            i = nind;\n            if (rx - lx == 1) { break; }\n            if (lunder == munder) {\n                lx = mx;\n            } else {\n                rx = mx;\n            }\n        }\n    }\n    int alloc()\n    {\n        m_nodes.push_back(Node{});\n        return (int)m_nodes.size() - 1;\n    }\n    T m_xmin, m_xsup;\n    Vec<Node> m_nodes;\n};\n",
    "result": "NOT_TESTED",
    "verified_with": [
        "verifications/convex_hull_trick/li_chao_tree.segment.test.cpp",
        "verifications/convex_hull_trick/li_chao_tree.line.test.cpp"
    ]
}