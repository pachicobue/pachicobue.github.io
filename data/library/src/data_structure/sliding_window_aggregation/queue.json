{
    "code": "#pragma once\n#include \"../../common.hpp\"\ntemplate<typename SemiGroup>\nclass SwagQueue\n{\n    using T = typename SemiGroup::T;\n\npublic:\n    SwagQueue() {}\n    void pushBack(const T& x)\n    {\n        m_backs.push_back(x);\n        m_Backs.push_back(m_Backs.empty() ? x : m_merge(m_Backs.back(), x));\n    }\n    void popFront()\n    {\n        if (m_Fronts.empty()) {\n            std::swap(m_fronts, m_backs), reverseAll(m_fronts), m_fronts.pop_back();\n            m_backs.clear(), m_Backs.clear();\n            calc();\n        } else {\n            m_fronts.pop_back(), m_Fronts.pop_back();\n        }\n    }\n    T foldAll() const\n    {\n        return m_fronts.empty()\n                   ? m_Backs.back()\n                   : (m_backs.empty() ? m_Fronts.back() : m_merge(m_Fronts.back(), m_Backs.back()));\n    }\n    bool empty() const { return m_backs.empty() and m_fronts.empty(); }\n\nprivate:\n    void calc()\n    {\n        if (not m_fronts.empty()) {\n            m_Fronts.push_back(m_fronts[0]);\n            for (int i : irange(1, m_fronts.size())) {\n                m_Fronts.push_back(m_merge(m_fronts[i], m_Fronts.back()));\n            }\n        }\n        if (not m_backs.empty()) {\n            m_Backs.push_back(m_backs[0]);\n            for (int i : irange(1, m_backs.size())) {\n                m_Backs.push_back(m_merge(m_Backs.back(), m_backs[i]));\n            }\n        }\n    }\n    Vec<T> m_fronts, m_backs;\n    Vec<T> m_Fronts, m_Backs;\n    static inline SemiGroup m_merge;\n};\n",
    "result": "NOT_TESTED",
    "verified_with": [
        "verifications/data_structure/sliding_window_aggregation/queue.test.cpp"
    ]
}