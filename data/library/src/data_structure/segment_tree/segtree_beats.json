{
    "code": "#pragma once\n#include \"../../common.hpp\"\ntemplate<typename MergeMonoid, typename OpMonoid, typename Act>\nclass SegBeats\n{\n    using T = typename MergeMonoid::T;\n    using F = typename OpMonoid::F;\n    static constexpr T e() { return MergeMonoid::e(); }\n    static constexpr F id() { return OpMonoid::id(); }\n\npublic:\n    SegBeats(const Vec<T>& vs)\n        : m_size(vs.size()),\n          m_half(bitCeil(m_size)),\n          m_depth(bitWidth(m_half)),\n          m_vs(m_half << 1, e()),\n          m_ops(m_half << 1, id())\n    {\n        std::copy(vs.begin(), vs.end(), m_vs.begin() + m_half);\n        for (int i : irange(m_half - 1, 0, -1)) { up(i); }\n    }\n    SegBeats(int N, const T& v = MergeMonoid::e()) : SegBeats{Vec<T>(N, v)} {}\n    T get(const int a)\n    {\n        assert(a < m_size);\n        return fold(a, a + 1);\n    }\n    void set(int i, const T& v)\n    {\n        assert(0 <= i and i < m_size);\n        i += m_half;\n        topDown(i), topDown(i + 1);\n        m_ops[i] = id();\n        m_vs[i] = v;\n        while (i >>= 1) { up(i); }\n    }\n    T fold(int l, int r)\n    {\n        assert(0 <= l and l <= r and r <= m_size);\n        if (l >= r) { return e(); }\n        l += m_half, r += m_half;\n        topDown(l), topDown(r);\n        T accl = e(), accr = e();\n        for (; l < r; l >>= 1, r >>= 1) {\n            if (l & 1) { accl = merge(accl, m_vs[l++]); }\n            if (r & 1) { accr = merge(m_vs[--r], accr); }\n        }\n        return merge(accl, accr);\n    }\n    void act(int l, int r, const F& f)\n    {\n        assert(0 <= l and l <= r and r <= m_size);\n        int li = l + m_half, ri = r + m_half;\n        topDown(li), topDown(ri);\n        for (; li < ri; li >>= 1, ri >>= 1) {\n            if (li & 1) { update(li++, f); }\n            if (ri & 1) { update(--ri, f); }\n        }\n        bottomUp(l + m_half), bottomUp(r + m_half);\n    }\n    friend Ostream& operator<<(Ostream& os, const SegBeats& lseg)\n    {\n        auto lseg2 = lseg;\n        os << \"[\";\n        for (int i : rep(lseg.m_size)) { os << (i == 0 ? \"\" : \",\") << lseg2.get(i); }\n        return (os << \"]\\n\");\n    }\n\nprivate:\n    void up(int i) { m_vs[i] = merge(m_vs[i << 1], m_vs[i << 1 | 1]); }\n    void update(int i, const F& f)\n    {\n        if (f == OpMonoid::id()) { return; }\n        m_ops[i] = compose(f, m_ops[i]);\n        m_vs[i] = apply(f, m_vs[i]);\n        if (apply.failed(m_vs[i])) {\n            down(i);\n            up(i);\n        }\n    }\n    void down(int i)\n    {\n        update(i << 1, m_ops[i]), update(i << 1 | 1, m_ops[i]);\n        m_ops[i] = id();\n    }\n    void topDown(int i)\n    {\n        const int j = (i / (i & -i)) >> 1;\n        for (const int h : per(m_depth)) {\n            const int v = i >> h;\n            if (v > j) { break; }\n            down(v);\n        }\n    }\n    void bottomUp(int i)\n    {\n        i = (i / (i & -i)) >> 1;\n        for (; i >= 1; i >>= 1) { up(i); }\n    }\n    int m_size, m_half, m_depth;\n    Vec<T> m_vs;\n    Vec<F> m_ops;\n    static inline MergeMonoid merge;\n    static inline OpMonoid compose;\n    static inline Act apply;\n};\n",
    "result": "NOT_TESTED",
    "verified_with": [
        "verifications/data_structure/segment_tree/segtree_beats.test.cpp"
    ]
}