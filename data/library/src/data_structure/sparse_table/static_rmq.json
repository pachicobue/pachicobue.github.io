{
    "code": "#pragma once\n#include \"../../common.hpp\"\n#include \"disjoint_sparse_table.hpp\"\ntemplate<typename TotalOrd>\nclass StaticRMQ\n{\n    using T = typename TotalOrd::T;\n    using B = u64;\n    static constexpr int bs = sizeof(B) * 8;\n    static constexpr int bslog = bitWidth(bs) - 1;\n    static constexpr int wind(int n) { return n >> (bslog); }\n    static constexpr int bind(int n) { return n ^ (wind(n) << bslog); }\n    static constexpr int ind(int w, int b) { return (w << bslog) | b; }\n\npublic:\n    StaticRMQ(const Vec<T>& vs)\n        : m_size{(int)vs.size()},\n          m_bn{wind(m_size + bs - 1)},\n          m_vals{vs},\n          m_masks(m_size, 0),\n          m_st{[&]() {\n              Vec<T> ans(m_bn);\n              for (int i : rep(m_size)) {\n                  ans[wind(i)]\n                      = (i % bs == 0 ? m_vals[i] : std::min(ans[wind(i)], m_vals[i], comp));\n              }\n              return ans;\n          }()}\n    {\n        for (int i : rep(m_bn)) {\n            Vec<int> g(bs, m_size), stack;\n            for (const int j : rep(bs)) {\n                if (ind(i, j) >= m_size) { break; }\n                for (; not stack.empty() and not comp(m_vals[stack.back()], m_vals[ind(i, j)]);\n                     stack.pop_back()) {}\n                g[j] = stack.empty() ? m_size : stack.back(), stack.push_back(ind(i, j));\n            }\n            for (int j : rep(bs)) {\n                if (ind(i, j) >= m_size) { break; }\n                m_masks[ind(i, j)] = g[j] == m_size\n                                         ? static_cast<B>(0)\n                                         : (m_masks[g[j]] | static_cast<B>(1) << (g[j] - i * bs));\n            }\n        }\n    }\n    T fold(int l, int r) const\n    {\n        assert(0 <= l and l < r and r <= m_size);\n        const int lb = (l + bs - 1) / bs, rb = r / bs;\n        if (lb > rb) {\n            return brmq(l, r);\n        } else {\n            return lb < rb\n                       ? (l < bs * lb\n                              ? (bs * rb < r ? std::min(\n                                     {m_st.fold(lb, rb), brmq(l, bs * lb), brmq(bs * rb, r)}, comp)\n                                             : std::min(m_st.fold(lb, rb), brmq(l, bs * lb), comp))\n                              : (bs * rb < r ? std::min(m_st.fold(lb, rb), brmq(bs * rb, r), comp)\n                                             : m_st.fold(lb, rb)))\n                       : (l < bs * lb\n                              ? (bs * rb < r ? std::min(brmq(l, bs * lb), brmq(bs * rb, r), comp)\n                                             : brmq(l, bs * lb))\n                              : (bs * rb < r ? brmq(bs * rb, r) : T{}));\n        }\n    }\n\nprivate:\n    T brmq(int l, int r) const\n    {\n        const B w = m_masks[r - 1] >> (l % bs);\n        return w == 0 ? m_vals[r - 1] : m_vals[l + lowBit(w)];\n    }\n    struct SemiGroup\n    {\n        using T = typename TotalOrd::T;\n        T operator()(const T& x1, const T& x2) const { return std::min(x1, x2, comp); }\n    };\n    int m_size, m_bn;\n    Vec<T> m_vals, m_bucket_vals;\n    Vec<B> m_masks;\n    DisjointSparseTable<SemiGroup> m_st;\n    static inline TotalOrd comp;\n};\n",
    "result": "NOT_TESTED",
    "verified_with": [
        "verifications/data_structure/sparse_table/static_rmq.rmq.test.cpp",
        "verifications/data_structure/sparse_table/static_rmq.rMq.test.cpp",
        "verifications/graph/tree/least_common_ancestor.test.cpp"
    ]
}