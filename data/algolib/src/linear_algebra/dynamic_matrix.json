{
    "code": "#pragma once\n#include \"../common.hpp\"\ntemplate<typename T>\nclass DynamicMatrix\n{\n    template<typename V>\n    using IList = std::initializer_list<V>;\n\npublic:\n    DynamicMatrix(const int row, const int column)\n        : m_row{row}, m_column{column}, m_vss(row, Vec<T>(column, T{}))\n    {}\n    DynamicMatrix(const IList<IList<T>>& vss)\n        : m_row{(int)vss.size()},\n          m_column{(int)(vss.begin()->size())},\n          m_vss(m_row, Vec<T>(m_column, T{}))\n    {\n        int i = 0;\n        for (auto it = vss.begin(); it != vss.end(); it++) {\n            std::copy(it->begin(), it->end(), m_vss[i++].begin());\n        }\n    }\n    const Vec<T>& operator[](const int r) const\n    {\n        assert(0 <= r and r < m_row);\n        return m_vss[r];\n    }\n    Vec<T>& operator[](const int r)\n    {\n        assert(0 <= r and r < m_row);\n        return m_vss[r];\n    }\n    friend DynamicMatrix operator-(const DynamicMatrix& m)\n    {\n        DynamicMatrix ans(m.m_row, m.m_column);\n        for (int i : rep(m.m_row)) {\n            for (int j : rep(m.m_column)) { ans[i][j] = -m[i][j]; }\n        }\n        return ans;\n    }\n    friend DynamicMatrix operator+(const DynamicMatrix& m1, const DynamicMatrix& m2)\n    {\n        assert(m1.m_row == m2.m_row);\n        assert(m1.m_column == m2.m_column);\n        DynamicMatrix ans(m1.m_row, m1.m_column);\n        for (int i : rep(m1.m_row)) {\n            for (int j : rep(m1.m_column)) { ans[i][j] = m1[i][j] + m2[i][j]; }\n        }\n        return ans;\n    }\n    friend DynamicMatrix operator-(const DynamicMatrix& m1, const DynamicMatrix& m2)\n    {\n        assert(m1.m_row == m2.m_row);\n        assert(m1.m_column == m2.m_column);\n        DynamicMatrix ans(m1.m_row, m1.m_column);\n        for (int i : rep(m1.m_row)) {\n            for (int j : rep(m1.m_column)) { ans[i][j] = m1[i][j] - m2[i][j]; }\n        }\n        return ans;\n    }\n    friend DynamicMatrix operator*(const DynamicMatrix& m1, const DynamicMatrix& m2)\n    {\n        assert(m1.m_column == m2.m_row);\n        DynamicMatrix ans(m1.m_row, m2.m_column);\n        for (int i : rep(m1.m_row)) {\n            for (int j : rep(m2.m_column)) {\n                for (int k : rep(m1.m_column)) { ans[i][j] += m1[i][k] * m2[k][j]; }\n            }\n        }\n        return ans;\n    }\n    friend DynamicMatrix operator*(const DynamicMatrix& m, const T& t)\n    {\n        DynamicMatrix ans(m.m_row, m.m_column);\n        for (int i : rep(m.m_row)) {\n            for (int j : rep(m.m_column)) { ans[i][j] = m[i][j] * t; }\n        }\n        return ans;\n    }\n    friend DynamicMatrix operator/(const DynamicMatrix& m, const T& t)\n    {\n        DynamicMatrix ans(m.m_row, m.m_column);\n        for (int i : rep(m.m_row)) {\n            for (int j : rep(m.m_column)) { ans[i][j] = m[i][j] / t; }\n        }\n        return ans;\n    }\n    friend DynamicMatrix operator*(const T& t, const DynamicMatrix& m) { return m * t; }\n    friend DynamicMatrix& operator+=(DynamicMatrix& m1, const DynamicMatrix& m2)\n    {\n        return m1 = m1 + m2;\n    }\n    friend DynamicMatrix& operator-=(DynamicMatrix& m1, const DynamicMatrix& m2)\n    {\n        return m1 = m1 - m2;\n    }\n    friend DynamicMatrix& operator*=(DynamicMatrix& m1, const DynamicMatrix& m2)\n    {\n        return m1 = m1 * m2;\n    }\n    friend DynamicMatrix& operator*=(DynamicMatrix& m, const T& t) { return m = m * t; }\n    friend DynamicMatrix& operator/=(DynamicMatrix& m, const T& t) { return m = m / t; }\n    friend Ostream& operator<<(Ostream& os, const DynamicMatrix& m)\n    {\n        os << \"[\\n\";\n        for (int i : rep(m.m_row)) {\n            os << \"[\";\n            for (int j : rep(m.m_column)) { os << m[i][j] << \",\"; }\n            os << \"]\\n\";\n        }\n        return (os << \"]\\n\");\n    }\n    template<typename N>\n    DynamicMatrix pow(N n) const\n    {\n        assert(m_row == m_column);\n        return powerMonoid(*this, n, DynamicMatrix::I(m_row));\n    }\n    static DynamicMatrix I(int N)\n    {\n        DynamicMatrix ans(N, N);\n        for (int i : rep(N)) { ans[i][i] = 1; }\n        return ans;\n    }\n    int row() const { return m_row; }\n    int column() const { return m_column; }\n\nprivate:\n    int m_row, m_column;\n    Vec<Vec<T>> m_vss;\n};\n",
    "result": "NOT_TESTED",
    "verified_with": [
        "verifications/linear_algebra/dynamic_matrix.test.cpp"
    ]
}