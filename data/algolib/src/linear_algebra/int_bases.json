{
    "code": "#pragma once\n#include \"../common.hpp\"\ntemplate<typename T = u64>\nclass IntBases\n{\n    static constexpr int D = sizeof(T) * 8;\n\npublic:\n    IntBases() { fillAll(m_vis, -1); }\n    bool add(const T& v)\n    {\n        auto reduced_v = v;\n        T mask = 0;\n        for (int i : rep(m_reduced_bases.size())) {\n            if (chmin(reduced_v, reduced_v ^ m_reduced_bases[i])) { mask ^= m_masks[i]; }\n        }\n        if (reduced_v) {\n            const int vi = m_reduced_bases.size();\n            mask ^= (T{1} << vi);\n            m_orig_bases.push_back(v), m_reduced_bases.push_back(reduced_v);\n            m_masks.push_back(mask);\n            for (int j : per(D)) {\n                if (isBitOn(reduced_v, j)) {\n                    m_vis[j] = vi;\n                    break;\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    const Vec<T>& origBases() const { return m_orig_bases; }\n    const Vec<T>& reducedBases() const { return m_reduced_bases; }\n    int rank() const { return m_reduced_bases.size(); }\n    Pair<bool, T> decomp(T v) const\n    {\n        T mask = 0;\n        for (int j : irange(D - 1, -1, -1)) {\n            if (isBitOn(v, j)) {\n                if (m_vis[j] == -1) { return {false, 0}; }\n                const int vi = m_vis[j];\n                v ^= m_reduced_bases[vi];\n                mask ^= m_masks[vi];\n            }\n        }\n        assert(v == 0);\n        return {true, mask};\n    }\n\nprivate:\n    Vec<T> m_orig_bases;     // \u5143\u306e\u5165\u529b\u306b\u3088\u308b\u57fa\u5e95\n    Vec<T> m_reduced_bases;  // \u7e2e\u7d04\u3055\u308c\u305f\u57fa\u5e95\n    Vec<T> m_masks;          // m_reduced[i]\u3092m_orig\u3067\u4f5c\u308b\u305f\u3081\u306e\u4fc2\u6570\n    Arr<int, D> m_vis;\n};\n",
    "result": "NOT_TESTED",
    "verified_with": [
        "verifications/linear_algebra/int_bases.test.cpp",
        "verifications/linear_algebra/int_bases.ut.test.cpp"
    ]
}