{
    "code": "#pragma once\n#include \"../common.hpp\"\nclass RollingHash\n{\npublic:\n    template<typename V>\n    RollingHash(const V& vs, u64 base)\n        : m_size(std::size(vs)), m_ps(m_size + 1, 1), m_hs(m_size + 1, 0), m_base{base}\n    {\n        for (int i : irange(1, m_size + 1)) {\n            m_ps[i] = mod(mul(m_ps[i - 1], m_base)),\n            m_hs[i] = mod(mul(m_hs[i - 1], m_base) + vs[i - 1]);\n        }\n    }\n    u64 operator()(int l, int r) const { return mod(m_hs[r] + offset - mul(m_hs[l], m_ps[r - l])); }\n    template<typename C>\n    void pushBack(C c)\n    {\n        m_size++;\n        m_ps.push_back(mod(mul(m_ps.back(), m_base)));\n        m_hs.push_back(mod(mul(m_hs.back(), m_base) + c));\n    }\n\nprivate:\n    static constexpr u64 mask30 = (1_u64 << 30) - 1;\n    static constexpr u64 mask31 = (1_u64 << 31) - 1;\n    static constexpr u64 mask61 = (1_u64 << 61) - 1;\n    static constexpr u64 offset = mask61 * 7_u64;\n    static constexpr u64 mod(u64 x)\n    {\n        const u64 y = (x >> 61) + (x & mask61);\n        return y >= mask61 ? y - mask61 : y;\n    }\n    static constexpr u64 mul(u64 x, u64 y)\n    {\n        const u64 xh = x >> 31, xl = x & mask31;\n        const u64 yh = y >> 31, yl = y & mask31;\n        const u64 z = xl * yh + xh * yl;\n        const u64 zh = z >> 30, zl = z & mask30;\n        return xh * yh * 2 + zh + (zl << 31) + xl * yl;\n    }\n    int m_size;\n    Vec<u64> m_ps, m_hs;\n    u64 m_base;\n};\n",
    "result": "NOT_TESTED",
    "verified_with": []
}