{
    "code": "#pragma once\n#include \"../common.hpp\"\n\ntemplate<typename V>\nVec<int> suffixArray(const V& vs)\n{\n    const int N = std::size(vs);\n    const int B = *std::max_element(ALL(vs)) + 1;\n    auto val = [&](int i) { return (i == N ? 0 : vs[i] + 1); };\n    Vec<bool> is_s(N + 1, true);\n    for (int i : per(N)) { is_s[i] = val(i) == val(i + 1) ? is_s[i + 1] : val(i) < val(i + 1); }\n    auto isS = [&](int i) { return is_s[i]; };\n    auto isL = [&](int i) { return not isS(i); };\n    auto isLms = [&](int i) { return i > 0 and isL(i - 1) and isS(i); };\n    auto sameLmsSubstr = [&](int i, int j) {\n        if (val(i++) != val(j++)) { return false; }\n        while (i <= N and j <= N) {\n            if (val(i) != val(j)) { return false; }\n            if (isLms(i)) { i = N; }\n            if (isLms(j)) { j = N; }\n            i++, j++;\n        }\n        return i >= N and j >= N;\n    };\n    Vec<int> poss = Vec<int>(B + 2, 0);\n    for (int i : rep(N + 1)) { poss[val(i) + 1]++; }\n    for (int b : rep(B + 1)) { poss[b + 1] += poss[b]; }\n\n    Vec<int> sa(N + 1, -1);\n    auto inducedSort = [&](const Vec<int>& lmss) {\n        fillAll(sa, -1);\n        Vec<int> inds = Vec<int>(B + 1, 0);\n        auto pushL = [&](int i) {\n            if (i >= 0 and isL(i)) { sa[inds[val(i)]++] = i; }\n        };\n        auto pushS = [&](int i) {\n            if (i >= 0 and isS(i)) { sa[--inds[val(i)]] = i; }\n        };\n        // \u4e0b\u304b\u3089LMS\u3092\u8a70\u3081\u308b\n        for (int b : rep(B + 1)) { inds[b] = poss[b + 1]; }\n        std::for_each(std::rbegin(lmss), std::rend(lmss), [&](int lms) { pushS(lms); });\n        // \u4e0a\u304b\u3089L\u3092\u8a70\u3081\u308b\n        for (int b : rep(B + 1)) { inds[b] = poss[b]; }\n        for (int i : rep(N + 1)) { pushL(sa[i] - 1); }\n        // \u4e0b\u304b\u3089S\u3092\u8a70\u3081\u308b\n        for (int b : irange(1, B + 1)) { inds[b] = poss[b + 1]; }\n        for (int i : per(N + 1)) { pushS(sa[i] - 1); }\n    };\n\n    Vec<int> lmss;  // LMS\u3092\u767b\u5834\u9806\u306b\u8a70\u3081\u305f\u3082\u306e\n    for (int i : rep(N + 1)) {\n        if (isLms(i)) { lmss.push_back(i); }\n    }\n    const int LMS = lmss.size();\n    inducedSort(lmss);  // \u30c6\u30ad\u30c8\u30fc\u306b\u4e00\u56deIS\n    if (LMS > 1) {\n        Vec<int> nlmss;  // LMS Substr\u306e\u4e2d\u8eab\u3067\u30bd\u30fc\u30c8\u3057\u305fLMS\n        for (int i : rep(N + 1)) {\n            if (isLms(sa[i])) { nlmss.push_back(sa[i]); }\n        }\n        Vec<int> kinds(N + 1, 0);\n        for (int ii : irange(1, LMS)) {\n            const int lms = nlmss[ii], plms = nlmss[ii - 1];\n            kinds[lms] = kinds[plms] + 1;\n            if (sameLmsSubstr(plms, lms)) { kinds[lms]--; }\n        }\n        Vec<int> sub_vs(LMS);\n        for (int i : rep(LMS)) { sub_vs[i] = kinds[lmss[i]]; }\n        // LMS\u3092\u30bd\u30fc\u30c8\u3059\u308b\n        const auto lmss_ords = suffixArray(sub_vs);\n        for (int i : rep(LMS)) { nlmss[i] = lmss[lmss_ords[i]]; }\n        // \u6b63\u3057\u3044LMS\u9806\u3067IS\n        inducedSort(nlmss);\n    }\n    return Vec<int>(std::begin(sa) + 1, std::end(sa));\n}\n",
    "result": "NOT_TESTED",
    "verified_with": [
        "verifications/string/suffix_array.test.cpp"
    ]
}