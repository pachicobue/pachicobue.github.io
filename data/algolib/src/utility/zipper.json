{
    "code": "#pragma once\n#include \"../common.hpp\"\ntemplate<typename T>\nclass Zipper\n{\npublic:\n    Zipper() {}\n    Zipper(const Vec<T>& vs) : m_vs{vs}, m_calced(false) {}\n    T unzip(int n)\n    {\n        assert(0 <= n and n < (int)m_vs.size());\n        calc();\n        return m_vs[n];\n    }\n    int zip(T v)\n    {\n        calc();\n        return lbInd(m_vs, v);\n    }\n    void add(T v)\n    {\n        m_vs.push_back(v);\n        m_calced = false;\n    }\n    void add(const Vec<T>& vs)\n    {\n        for (const auto& v : vs) { m_vs.push_back(v); }\n        m_calced = false;\n    }\n    int size()\n    {\n        calc();\n        return m_vs.size();\n    }\n    friend Ostream& operator<<(Ostream& os, const Zipper& zipper_)\n    {\n        auto zipper = zipper_;\n        zipper.calc();\n        return os << zipper.m_vs << \"\\n\";\n    }\n\nprivate:\n    void calc()\n    {\n        if (not m_calced) {\n            sortAll(m_vs);\n            m_vs.erase(std::unique(m_vs.begin(), m_vs.end()), m_vs.end());\n            m_calced = true;\n        }\n    }\n    Vec<T> m_vs;\n    bool m_calced = true;\n};\n",
    "result": "NOT_TESTED",
    "verified_with": [
        "verifications/algorithm/mo.test.cpp",
        "verifications/utility/zipper.ut.test.cpp"
    ]
}