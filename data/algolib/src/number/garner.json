{
    "code": "#pragma once\n#include \"../common.hpp\"\nclass Garner\n{\npublic:\n    template<typename mint, typename mint1, typename mint2>\n    static mint restore_mod(const mint1& x1, const mint2& x2)\n    {\n        constexpr auto m1 = mint1::mod();\n        const auto [y0, y1] = coeff(x1, x2);\n        return mint(y0.val()) + mint(y1.val()) * m1;\n    }\n    template<typename mint, typename mint1, typename mint2, typename mint3>\n    static mint restore_mod(const mint1& x1, const mint2& x2, const mint3& x3)\n    {\n        constexpr auto m1 = mint1::mod();\n        constexpr auto m2 = mint2::mod();\n        const auto [y0, y1, y2] = coeff(x1, x2, x3);\n        return mint(y0.val()) + mint(y1.val()) * m1 + mint(y2.val()) * m1 * m2;\n    }\n    template<typename mint1, typename mint2>\n    static i64 restore_i64(const mint1& x1, const mint2& x2)\n    {\n        constexpr u32 m1 = mint1::mod();\n        constexpr u32 m2 = mint2::mod();\n        const auto [y0, y1] = coeff(x1, x2);\n        constexpr u64 MAX = 1_u64 << 63;\n        const i128 M = (i128)m1 * m2;\n        i128 S = i128(y0.val()) + i128(y1.val()) * m1;\n        if (S >= MAX) { S -= M; }\n        return (i64)S;\n    }\n    template<typename mint1, typename mint2, typename mint3>\n    static i64 restore_i64(const mint1& x1, const mint2& x2, const mint3& x3)\n    {\n        constexpr u32 m1 = mint1::mod();\n        constexpr u32 m2 = mint2::mod();\n        constexpr u32 m3 = mint3::mod();\n        const auto [y0, y1, y2] = coeff(x1, x2, x3);\n        constexpr u64 MAX = 1_u64 << 63;\n        const i128 M = (i128)m1 * m2 * m3;\n        i128 S = i128(y0.val()) + i128(y1.val()) * m1 + i128(y2.val()) * m1 * m2;\n        if (S >= MAX) { S -= M; }\n        return (i64)S;\n    }\n\nprivate:\n    template<typename mint1, typename mint2>\n    static Pair<mint1, mint2> coeff(const mint1& x1, const mint2& x2)\n    {\n        constexpr auto m1 = mint1::mod();\n        constexpr mint2 m1_inv = mint2(m1).inv();\n        const mint1 y0 = x1;\n        const mint2 y1 = (x2 - mint2(y0.val())) * m1_inv;\n        return {y0, y1};\n    }\n    template<typename mint1, typename mint2, typename mint3>\n    static Tup<mint1, mint2, mint3> coeff(const mint1& x1, const mint2& x2, const mint3& x3)\n    {\n        constexpr auto m1 = mint1::mod();\n        constexpr auto m2 = mint2::mod();\n        constexpr mint2 m1_inv = mint2(m1).inv();\n        constexpr mint3 m1m2_inv = (mint3(m1) * mint3(m2)).inv();\n        const mint1 y0 = x1;\n        const mint2 y1 = (x2 - mint2(y0.val())) * m1_inv;\n        const mint3 y2 = (x3 - mint3(y0.val()) - mint3(y1.val()) * m1) * m1m2_inv;\n        return {y0, y1, y2};\n    }\n};\n",
    "result": "NOT_TESTED",
    "verified_with": [
        "verifications/numerical/convolution.ut.test.cpp",
        "verifications/formal_power_series/formal_power_series.exp.test.cpp",
        "verifications/formal_power_series/formal_power_series.log.test.cpp",
        "verifications/formal_power_series/formal_power_series.pow.test.cpp",
        "verifications/formal_power_series/formal_power_series.inv.test.cpp",
        "verifications/formal_power_series/formal_power_series.convolution.test.cpp",
        "verifications/formal_power_series/formal_power_series.convolution1000000007.test.cpp",
        "verifications/formal_power_series/bostan_mori.test.cpp"
    ]
}