{
    "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/range_affine_range_sum\n#include \"data_structure/segment_tree/lazy_segtree.hpp\"\n#include \"utility/modint.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\n\nint main()\n{\n    using mint = modint_998244353;\n    using Func = Pair<mint, mint>;\n    struct MergeMonoid\n    {\n        using T = Pair<mint, int>;\n        static T e() { return {0, 0}; }\n        T operator()(const T& x1, const T& x2) const\n        {\n            return {x1.first + x2.first, x1.second + x2.second};\n        }\n    };\n    struct OpMonoid\n    {\n        using F = Func;\n        static F id() { return F{1, 0}; }\n        F operator()(const F& f1, const F& f2) const\n        {\n            return F{f1.first * f2.first, f1.first * f2.second + f1.second};\n        }\n    };\n    struct Act\n    {\n        using T = MergeMonoid::T;\n        using F = OpMonoid::F;\n        T operator()(const F& f, const T& x) const\n        {\n            return {f.first * x.first + f.second * x.second, x.second};\n        }\n    };\n\n    const auto [N, Q] = in.tup<int, int>();\n    Vec<Pair<mint, int>> as(N, {0, 1});\n    for (int i : rep(N)) { as[i].first = in.val<mint>(); }\n    auto seg = LazySeg<MergeMonoid, OpMonoid, Act>(as);\n    LOOP (Q) {\n        const auto t = in.val<int>();\n        if (t == 0) {\n            const auto [l, r, b, c] = in.tup<int, int, mint, mint>();\n            seg.act(l, r, Func{b, c});\n        } else {\n            const auto [l, r] = in.tup<int, int>();\n            out.ln(seg.fold(l, r).first.val());\n        }\n    }\n    return 0;\n}\n",
    "result": "AC"
}