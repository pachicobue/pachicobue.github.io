{
    "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/vertex_set_path_composite\n#include \"graph/tree/heavy_light_decomposition.hpp\"\n#include \"data_structure/segment_tree/segtree.hpp\"\n#include \"utility/modint.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\nint main()\n{\n    using mint = modint_998244353;\n    const auto [N, Q] = in.tup<int, int>();\n    Graph g(N);\n    using Func = Pair<mint, mint>;\n    struct Monoid\n    {\n        using T = Func;\n        static const T e() { return T{1, 0}; }\n        T operator()(const T& f2, const T& f1) const\n        {\n            return T{f1.first * f2.first, f1.first * f2.second + f1.second};\n        }\n    };\n    struct RMonoid\n    {\n        using T = Func;\n        static const T e() { return T{1, 0}; }\n        T operator()(const T& f1, const T& f2) const\n        {\n            return T{f1.first * f2.first, f1.first * f2.second + f1.second};\n        }\n    };\n\n    Vec<mint> as(N), bs(N);\n    for (int i : rep(N)) { std::tie(as[i], bs[i]) = in.tup<mint, mint>(); }\n    LOOP (N - 1) {\n        const auto [u, v] = in.tup<int, int>();\n        g.addEdge(u, v, true);\n    }\n    const HeavyLightDecomposition hld{g};\n    Vec<Func> vs(N);\n    for (int i : rep(N)) { vs[hld.pos(i)] = Func{as[i], bs[i]}; }\n    auto seg = SegTree<Monoid>(vs);\n    auto rseg = SegTree<RMonoid>(vs);\n    LOOP (Q) {\n        const auto t = in.val<int>();\n        if (t == 0) {\n            const auto [p, c, d] = in.tup<int, mint, mint>();\n            seg.set(hld.pos(p), {c, d}), rseg.set(hld.pos(p), {c, d});\n        } else {\n            const auto [u, v, x] = in.tup<int, int, mint>();\n            const auto ps = hld.path(u, v);\n            Func f{1, 0};\n            for (const auto& [a, b] : ps) {\n                f = Monoid{}(f, a <= b ? seg.fold(a, b + 1) : rseg.fold(b, a + 1));\n            }\n            out.ln((f.first * x + f.second).val());\n        }\n    }\n    return 0;\n}\n",
    "result": "AC"
}