{
    "code": "// verification-helper: PROBLEM https://judge.yosupo.jp/problem/static_range_inversions_query\n#include \"data_structure/fenwick_tree/fenwick_tree.hpp\"\n#include \"algorithm/mo.hpp\"\n#include \"utility/printer.hpp\"\n#include \"utility/scanner.hpp\"\n#include \"utility/zipper.hpp\"\nint main()\n{\n    //hoge\n    const auto [N, Q] = in.tup<int, int>();\n    auto as = in.vec<u32>(N);\n    Zipper<u32> zipper(as);\n    for (auto& a : as) { a = zipper.zip(a); }\n    const int L = zipper.size();\n    FenwickTree<int> bit(Vec<int>(L, 0));\n    u64 inv = 0;\n    auto left = [&](int x, int) {  // (x,y)->(x-1,y)\n        const int a = as[x - 1];\n        inv += bit.sum(0, a);\n        bit.add(a, 1);\n    };\n    auto right = [&](int x, int) {  // (x,y)->(x+1,y)\n        const int a = as[x];\n        inv -= bit.sum(0, a);\n        bit.add(a, -1);\n    };\n    auto up = [&](int, int y) {  // (x,y)->(x,y-1)\n        const int a = as[y - 1];\n        inv -= bit.sum(a + 1, L);\n        bit.add(a, -1);\n    };\n    auto down = [&](int, int y) {  // (x,y)->(x,y+1)\n        const int a = as[y];\n        inv += bit.sum(a + 1, L);\n        bit.add(a, 1);\n    };\n\n    Vec<int> ls(Q), rs(Q);\n    for (int q : rep(Q)) { std::tie(ls[q], rs[q]) = in.tup<int, int>(); }\n    Mo mo(ls, rs);\n    Vec<u64> ans(Q);\n    mo.solve(right, left, down, up, [&](int q) { ans[q] = inv; });\n    out.ln(ans);\n\n    return 0;\n}\n",
    "result": "AC"
}