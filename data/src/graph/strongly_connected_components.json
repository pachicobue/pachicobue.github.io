{
    "code": "#pragma once\n#include \"../common.hpp\"\n#include \"graph.hpp\"\ntemplate<typename T>\nclass StronglyConnectedComponents\n{\npublic:\n    StronglyConnectedComponents(const Graph<T>& g) : m_v(g.v()), m_cs(m_v, -1)\n    {\n        const int N = g.v();\n        Graph<> rg(N);\n        for (int u : rep(N)) {\n            for (int v : g[u]) { rg.addEdge(v, u); }\n        }\n        Vec<int> st;\n        Vec<bool> used(N, false);\n        auto dfs = Fix([&](auto dfs, int u) -> void {\n            used[u] = true;\n            for (int v : g[u]) {\n                if (not used[v]) { dfs(v); }\n            }\n            st.push_back(u);\n        });\n        auto rdfs = Fix([&](auto dfs, int v) -> void {\n            m_cs[v] = m_cnum;\n            for (int u : rg[v]) {\n                if (m_cs[u] != -1) { continue; }\n                dfs(u);\n            }\n        });\n        for (int i : rep(N)) {\n            if (used[i]) { continue; }\n            dfs(i);\n        }\n        reverseAll(st);\n        for (int i : st) {\n            if (m_cs[i] != -1) { continue; }\n            rdfs(i);\n            m_cnum++;\n        }\n    }\n    int operator[](int v) const\n    {\n        assert(0 <= v and v < m_v);\n        return m_cs[v];\n    }\n    int cnum() const { return m_cnum; }\n    Vec<Vec<int>> groups() const\n    {\n        Vec<Vec<int>> iss(m_v);\n        for (const int i : rep(m_v)) { iss[m_cs[i]].push_back(i); }\n        return iss;\n    }\n\nprivate:\n    int m_v;\n    int m_cnum = 0;\n    Vec<int> m_cs;\n};\n",
    "result": "NOT_TESTED",
    "verified_with": [
        "verifications/graph/strongly_connected_components.test.cpp"
    ]
}