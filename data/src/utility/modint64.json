{
    "code": "#pragma once\n#include \"../common.hpp\"\n#include \"../algorithm/ext_gcd.hpp\"\ntemplate<u64 mod_, u64 root_, u64 max2p_>\nclass modint64\n{\n    template<typename U = u64&>\n    static U modRef()\n    {\n        static u64 s_mod = 0;\n        return s_mod;\n    }\n    template<typename U = u64&>\n    static U rootRef()\n    {\n        static u64 s_root = 0;\n        return s_root;\n    }\n    template<typename U = u64&>\n    static U max2pRef()\n    {\n        static u64 s_max2p = 0;\n        return s_max2p;\n    }\n\npublic:\n    static_assert(mod_ <= LIMMAX<i64>, \"mod(signed int size) only supported!\");\n    static constexpr bool isDynamic() { return (mod_ == 0); }\n    template<typename U = const u64>\n    static constexpr std::enable_if_t<mod_ != 0, U> mod()\n    {\n        return mod_;\n    }\n    template<typename U = const u64>\n    static std::enable_if_t<mod_ == 0, U> mod()\n    {\n        return modRef();\n    }\n    template<typename U = const u64>\n    static constexpr std::enable_if_t<mod_ != 0, U> root()\n    {\n        return root_;\n    }\n    template<typename U = const u64>\n    static std::enable_if_t<mod_ == 0, U> root()\n    {\n        return rootRef();\n    }\n    template<typename U = const u64>\n    static constexpr std::enable_if_t<mod_ != 0, U> max2p()\n    {\n        return max2p_;\n    }\n    template<typename U = const u64>\n    static std::enable_if_t<mod_ == 0, U> max2p()\n    {\n        return max2pRef();\n    }\n    template<typename U = u64>\n    static void setMod(std::enable_if_t<mod_ == 0, U> m)\n    {\n        assert(1 <= m and m <= LIMMAX<i64>);\n        modRef() = m;\n        sinvRef() = {1, 1};\n        factRef() = {1, 1};\n        ifactRef() = {1, 1};\n    }\n    template<typename U = u64>\n    static void setRoot(std::enable_if_t<mod_ == 0, U> r)\n    {\n        rootRef() = r;\n    }\n    template<typename U = u64>\n    static void setMax2p(std::enable_if_t<mod_ == 0, U> m)\n    {\n        max2pRef() = m;\n    }\n    constexpr modint64() : m_val{0} {}\n    constexpr modint64(const i64 v) : m_val{normLL(v)} {}\n    constexpr void setRaw(const u64 v) { m_val = v; }\n    constexpr modint64 operator+() const { return *this; }\n    constexpr modint64 operator-() const { return modint64{0} - (*this); }\n    constexpr modint64& operator+=(const modint64& m)\n    {\n        m_val = norm(m_val + m.val());\n        return *this;\n    }\n    constexpr modint64& operator-=(const modint64& m)\n    {\n        m_val = norm(m_val + mod() - m.val());\n        return *this;\n    }\n    constexpr modint64& operator*=(const modint64& m)\n    {\n        m_val = normLL((i128)m_val * (i128)m.val() % (i128)mod());\n        return *this;\n    }\n    constexpr modint64& operator/=(const modint64& m) { return *this *= m.inv(); }\n    constexpr modint64 operator+(const modint64& m) const\n    {\n        auto v = *this;\n        return v += m;\n    }\n    constexpr modint64 operator-(const modint64& m) const\n    {\n        auto v = *this;\n        return v -= m;\n    }\n    constexpr modint64 operator*(const modint64& m) const\n    {\n        auto v = *this;\n        return v *= m;\n    }\n    constexpr modint64 operator/(const modint64& m) const\n    {\n        auto v = *this;\n        return v /= m;\n    }\n    constexpr bool operator==(const modint64& m) const { return m_val == m.val(); }\n    constexpr bool operator!=(const modint64& m) const { return not(*this == m); }\n    friend Istream& operator>>(Istream& is, modint64& m)\n    {\n        i64 v;\n        return is >> v, m = v, is;\n    }\n    friend Ostream& operator<<(Ostream& os, const modint64& m) { return os << m.val(); }\n    constexpr u64 val() const { return m_val; }\n    template<typename I>\n    constexpr modint64 pow(I n) const\n    {\n        return powerInt(*this, n);\n    }\n    constexpr modint64 inv() const { return inverse<i64>(m_val, mod()); }\n    modint64 sinv() const { return sinv(m_val); }\n    static modint64 sinv(u32 n)\n    {\n        auto& is = sinvRef();\n        for (u32 i = (u32)is.size(); i <= n; i++) { is.push_back(-is[mod() % i] * (mod() / i)); }\n        return is[n];\n    }\n    static modint64 fact(u32 n)\n    {\n        auto& fs = factRef();\n        for (u32 i = (u32)fs.size(); i <= n; i++) { fs.push_back(fs.back() * i); }\n        return fs[n];\n    }\n    static modint64 ifact(u32 n)\n    {\n        auto& ifs = ifactRef();\n        for (u32 i = (u32)ifs.size(); i <= n; i++) { ifs.push_back(ifs.back() * sinv(i)); }\n        return ifs[n];\n    }\n    static modint64 perm(int n, int k)\n    {\n        return k > n or k < 0 ? modint64{0} : fact(n) * ifact(n - k);\n    }\n    static modint64 comb(int n, int k)\n    {\n        return k > n or k < 0 ? modint64{0} : fact(n) * ifact(n - k) * ifact(k);\n    }\n\nprivate:\n    static Vec<modint64>& sinvRef()\n    {\n        static Vec<modint64> is{1, 1};\n        return is;\n    }\n    static Vec<modint64>& factRef()\n    {\n        static Vec<modint64> fs{1, 1};\n        return fs;\n    }\n    static Vec<modint64>& ifactRef()\n    {\n        static Vec<modint64> ifs{1, 1};\n        return ifs;\n    }\n    static constexpr u64 norm(const u64 x) { return x < mod() ? x : x - mod(); }\n    static constexpr u64 normLL(const i64 x)\n    {\n        return norm(u64((i128)x % (i128)mod() + (i128)mod()));\n    }\n    u64 m_val;\n};\ntemplate<int id>\nusing modint64_dynamic = modint64<0, 0, id>;\n",
    "result": "NOT_TESTED",
    "verified_with": [
        "verifications/number/mod_nthroot.yuki.test.cpp",
        "verifications/number/prime_factors.test.cpp",
        "verifications/number/mod_nthroot.test.cpp"
    ]
}